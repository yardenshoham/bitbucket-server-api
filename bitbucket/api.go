// Package bitbucket provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package bitbucket

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ApplicationUserType.
const (
	ApplicationUserTypeNORMAL  ApplicationUserType = "NORMAL"
	ApplicationUserTypeSERVICE ApplicationUserType = "SERVICE"
)

// Defines values for CommentSeverity.
const (
	CommentSeverityBLOCKER CommentSeverity = "BLOCKER"
	CommentSeverityNORMAL  CommentSeverity = "NORMAL"
)

// Defines values for CommentState.
const (
	CommentStateOPEN     CommentState = "OPEN"
	CommentStatePENDING  CommentState = "PENDING"
	CommentStateRESOLVED CommentState = "RESOLVED"
)

// Defines values for CommentThreadDiffAnchorDiffType.
const (
	CommentThreadDiffAnchorDiffTypeCOMMIT    CommentThreadDiffAnchorDiffType = "COMMIT"
	CommentThreadDiffAnchorDiffTypeEFFECTIVE CommentThreadDiffAnchorDiffType = "EFFECTIVE"
	CommentThreadDiffAnchorDiffTypeRANGE     CommentThreadDiffAnchorDiffType = "RANGE"
)

// Defines values for CommentThreadDiffAnchorFileType.
const (
	CommentThreadDiffAnchorFileTypeFROM CommentThreadDiffAnchorFileType = "FROM"
	CommentThreadDiffAnchorFileTypeTO   CommentThreadDiffAnchorFileType = "TO"
)

// Defines values for CommentThreadDiffAnchorLineType.
const (
	CommentThreadDiffAnchorLineTypeADDED   CommentThreadDiffAnchorLineType = "ADDED"
	CommentThreadDiffAnchorLineTypeCONTEXT CommentThreadDiffAnchorLineType = "CONTEXT"
	CommentThreadDiffAnchorLineTypeREMOVED CommentThreadDiffAnchorLineType = "REMOVED"
)

// Defines values for CommentThreadDiffAnchorMultilineStartLineType.
const (
	CommentThreadDiffAnchorMultilineStartLineTypeADDED   CommentThreadDiffAnchorMultilineStartLineType = "ADDED"
	CommentThreadDiffAnchorMultilineStartLineTypeCONTEXT CommentThreadDiffAnchorMultilineStartLineType = "CONTEXT"
	CommentThreadDiffAnchorMultilineStartLineTypeREMOVED CommentThreadDiffAnchorMultilineStartLineType = "REMOVED"
)

// Defines values for EnrichedRepositoryOriginProjectType.
const (
	EnrichedRepositoryOriginProjectTypeNORMAL   EnrichedRepositoryOriginProjectType = "NORMAL"
	EnrichedRepositoryOriginProjectTypePERSONAL EnrichedRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for EnrichedRepositoryOriginState.
const (
	EnrichedRepositoryOriginStateAVAILABLE            EnrichedRepositoryOriginState = "AVAILABLE"
	EnrichedRepositoryOriginStateINITIALISATIONFAILED EnrichedRepositoryOriginState = "INITIALISATION_FAILED"
	EnrichedRepositoryOriginStateINITIALISING         EnrichedRepositoryOriginState = "INITIALISING"
	EnrichedRepositoryOriginStateOFFLINE              EnrichedRepositoryOriginState = "OFFLINE"
)

// Defines values for EnrichedRepositoryProjectType.
const (
	EnrichedRepositoryProjectTypeNORMAL   EnrichedRepositoryProjectType = "NORMAL"
	EnrichedRepositoryProjectTypePERSONAL EnrichedRepositoryProjectType = "PERSONAL"
)

// Defines values for EnrichedRepositoryState.
const (
	EnrichedRepositoryStateAVAILABLE            EnrichedRepositoryState = "AVAILABLE"
	EnrichedRepositoryStateINITIALISATIONFAILED EnrichedRepositoryState = "INITIALISATION_FAILED"
	EnrichedRepositoryStateINITIALISING         EnrichedRepositoryState = "INITIALISING"
	EnrichedRepositoryStateOFFLINE              EnrichedRepositoryState = "OFFLINE"
)

// Defines values for ProjectType.
const (
	ProjectTypeNORMAL   ProjectType = "NORMAL"
	ProjectTypePERSONAL ProjectType = "PERSONAL"
)

// Defines values for PullRequestState.
const (
	PullRequestStateDECLINED PullRequestState = "DECLINED"
	PullRequestStateMERGED   PullRequestState = "MERGED"
	PullRequestStateOPEN     PullRequestState = "OPEN"
)

// Defines values for PullRequestParticipantRole.
const (
	PullRequestParticipantRoleAUTHOR      PullRequestParticipantRole = "AUTHOR"
	PullRequestParticipantRolePARTICIPANT PullRequestParticipantRole = "PARTICIPANT"
	PullRequestParticipantRoleREVIEWER    PullRequestParticipantRole = "REVIEWER"
)

// Defines values for PullRequestParticipantStatus.
const (
	PullRequestParticipantStatusAPPROVED   PullRequestParticipantStatus = "APPROVED"
	PullRequestParticipantStatusNEEDSWORK  PullRequestParticipantStatus = "NEEDS_WORK"
	PullRequestParticipantStatusUNAPPROVED PullRequestParticipantStatus = "UNAPPROVED"
)

// Defines values for RepositoryState.
const (
	RepositoryStateAVAILABLE            RepositoryState = "AVAILABLE"
	RepositoryStateINITIALISATIONFAILED RepositoryState = "INITIALISATION_FAILED"
	RepositoryStateINITIALISING         RepositoryState = "INITIALISING"
	RepositoryStateOFFLINE              RepositoryState = "OFFLINE"
)

// Defines values for RepositoryHookDetailsSupportedScopes.
const (
	RepositoryHookDetailsSupportedScopesGLOBAL     RepositoryHookDetailsSupportedScopes = "GLOBAL"
	RepositoryHookDetailsSupportedScopesPROJECT    RepositoryHookDetailsSupportedScopes = "PROJECT"
	RepositoryHookDetailsSupportedScopesREPOSITORY RepositoryHookDetailsSupportedScopes = "REPOSITORY"
)

// Defines values for RepositoryHookDetailsType.
const (
	RepositoryHookDetailsTypePOSTRECEIVE         RepositoryHookDetailsType = "POST_RECEIVE"
	RepositoryHookDetailsTypePREPULLREQUESTMERGE RepositoryHookDetailsType = "PRE_PULL_REQUEST_MERGE"
	RepositoryHookDetailsTypePRERECEIVE          RepositoryHookDetailsType = "PRE_RECEIVE"
)

// Defines values for RestAggregateRejectCounterUserType.
const (
	RestAggregateRejectCounterUserTypeNORMAL  RestAggregateRejectCounterUserType = "NORMAL"
	RestAggregateRejectCounterUserTypeSERVICE RestAggregateRejectCounterUserType = "SERVICE"
)

// Defines values for RestAnnouncementBannerAudience.
const (
	RestAnnouncementBannerAudienceALL           RestAnnouncementBannerAudience = "ALL"
	RestAnnouncementBannerAudienceAUTHENTICATED RestAnnouncementBannerAudience = "AUTHENTICATED"
)

// Defines values for RestApplicationUserType.
const (
	RestApplicationUserTypeNORMAL  RestApplicationUserType = "NORMAL"
	RestApplicationUserTypeSERVICE RestApplicationUserType = "SERVICE"
)

// Defines values for RestApplicationUserWithPermissionsType.
const (
	RestApplicationUserWithPermissionsTypeNORMAL  RestApplicationUserWithPermissionsType = "NORMAL"
	RestApplicationUserWithPermissionsTypeSERVICE RestApplicationUserWithPermissionsType = "SERVICE"
)

// Defines values for RestAutoDeclineSettingsScopeType.
const (
	RestAutoDeclineSettingsScopeTypeGLOBAL     RestAutoDeclineSettingsScopeType = "GLOBAL"
	RestAutoDeclineSettingsScopeTypePROJECT    RestAutoDeclineSettingsScopeType = "PROJECT"
	RestAutoDeclineSettingsScopeTypeREPOSITORY RestAutoDeclineSettingsScopeType = "REPOSITORY"
)

// Defines values for RestAutoMergeProcessingResultAutoMergeProcessingStatus.
const (
	RestAutoMergeProcessingResultAutoMergeProcessingStatusCANCELLED   RestAutoMergeProcessingResultAutoMergeProcessingStatus = "CANCELLED"
	RestAutoMergeProcessingResultAutoMergeProcessingStatusLOCKFAILURE RestAutoMergeProcessingResultAutoMergeProcessingStatus = "LOCK_FAILURE"
	RestAutoMergeProcessingResultAutoMergeProcessingStatusMERGED      RestAutoMergeProcessingResultAutoMergeProcessingStatus = "MERGED"
	RestAutoMergeProcessingResultAutoMergeProcessingStatusSTALE       RestAutoMergeProcessingResultAutoMergeProcessingStatus = "STALE"
	RestAutoMergeProcessingResultAutoMergeProcessingStatusUNKNOWN     RestAutoMergeProcessingResultAutoMergeProcessingStatus = "UNKNOWN"
	RestAutoMergeProcessingResultAutoMergeProcessingStatusVETOED      RestAutoMergeProcessingResultAutoMergeProcessingStatus = "VETOED"
)

// Defines values for RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType.
const (
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState.
const (
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginStateAVAILABLE            RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginStateINITIALISING         RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginStateOFFLINE              RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType.
const (
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectTypeNORMAL   RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectTypePERSONAL RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestAutoMergeProcessingResultPullRequestFromRefRepositoryState.
const (
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryStateAVAILABLE            RestAutoMergeProcessingResultPullRequestFromRefRepositoryState = "AVAILABLE"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestAutoMergeProcessingResultPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryStateINITIALISING         RestAutoMergeProcessingResultPullRequestFromRefRepositoryState = "INITIALISING"
	RestAutoMergeProcessingResultPullRequestFromRefRepositoryStateOFFLINE              RestAutoMergeProcessingResultPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestAutoMergeProcessingResultPullRequestFromRefType.
const (
	RestAutoMergeProcessingResultPullRequestFromRefTypeBRANCH RestAutoMergeProcessingResultPullRequestFromRefType = "BRANCH"
	RestAutoMergeProcessingResultPullRequestFromRefTypeTAG    RestAutoMergeProcessingResultPullRequestFromRefType = "TAG"
)

// Defines values for RestAutoMergeProcessingResultPullRequestState.
const (
	RestAutoMergeProcessingResultPullRequestStateDECLINED RestAutoMergeProcessingResultPullRequestState = "DECLINED"
	RestAutoMergeProcessingResultPullRequestStateMERGED   RestAutoMergeProcessingResultPullRequestState = "MERGED"
	RestAutoMergeProcessingResultPullRequestStateOPEN     RestAutoMergeProcessingResultPullRequestState = "OPEN"
)

// Defines values for RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType.
const (
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectTypePERSONAL RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState.
const (
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginStateAVAILABLE            RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginStateINITIALISING         RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginStateOFFLINE              RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType.
const (
	RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectTypeNORMAL   RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType = "NORMAL"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectTypePERSONAL RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestAutoMergeProcessingResultPullRequestToRefRepositoryState.
const (
	RestAutoMergeProcessingResultPullRequestToRefRepositoryStateAVAILABLE            RestAutoMergeProcessingResultPullRequestToRefRepositoryState = "AVAILABLE"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryStateINITIALISATIONFAILED RestAutoMergeProcessingResultPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryStateINITIALISING         RestAutoMergeProcessingResultPullRequestToRefRepositoryState = "INITIALISING"
	RestAutoMergeProcessingResultPullRequestToRefRepositoryStateOFFLINE              RestAutoMergeProcessingResultPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestAutoMergeProcessingResultPullRequestToRefType.
const (
	RestAutoMergeProcessingResultPullRequestToRefTypeBRANCH RestAutoMergeProcessingResultPullRequestToRefType = "BRANCH"
	RestAutoMergeProcessingResultPullRequestToRefTypeTAG    RestAutoMergeProcessingResultPullRequestToRefType = "TAG"
)

// Defines values for RestAutoMergeProjectSettingsRequestRestrictionAction.
const (
	RestAutoMergeProjectSettingsRequestRestrictionActionCREATE RestAutoMergeProjectSettingsRequestRestrictionAction = "CREATE"
	RestAutoMergeProjectSettingsRequestRestrictionActionDELETE RestAutoMergeProjectSettingsRequestRestrictionAction = "DELETE"
	RestAutoMergeProjectSettingsRequestRestrictionActionNONE   RestAutoMergeProjectSettingsRequestRestrictionAction = "NONE"
)

// Defines values for RestAutoMergeRestrictedSettingsRestrictionState.
const (
	RestAutoMergeRestrictedSettingsRestrictionStateNONE                   RestAutoMergeRestrictedSettingsRestrictionState = "NONE"
	RestAutoMergeRestrictedSettingsRestrictionStateRESTRICTEDMODIFIABLE   RestAutoMergeRestrictedSettingsRestrictionState = "RESTRICTED_MODIFIABLE"
	RestAutoMergeRestrictedSettingsRestrictionStateRESTRICTEDUNMODIFIABLE RestAutoMergeRestrictedSettingsRestrictionState = "RESTRICTED_UNMODIFIABLE"
)

// Defines values for RestAutoMergeRestrictedSettingsScopeType.
const (
	RestAutoMergeRestrictedSettingsScopeTypeGLOBAL     RestAutoMergeRestrictedSettingsScopeType = "GLOBAL"
	RestAutoMergeRestrictedSettingsScopeTypePROJECT    RestAutoMergeRestrictedSettingsScopeType = "PROJECT"
	RestAutoMergeRestrictedSettingsScopeTypeREPOSITORY RestAutoMergeRestrictedSettingsScopeType = "REPOSITORY"
)

// Defines values for RestBuildStatusState.
const (
	RestBuildStatusStateCANCELLED  RestBuildStatusState = "CANCELLED"
	RestBuildStatusStateFAILED     RestBuildStatusState = "FAILED"
	RestBuildStatusStateINPROGRESS RestBuildStatusState = "INPROGRESS"
	RestBuildStatusStateSUCCESSFUL RestBuildStatusState = "SUCCESSFUL"
	RestBuildStatusStateUNKNOWN    RestBuildStatusState = "UNKNOWN"
)

// Defines values for RestBuildStatusSetRequestState.
const (
	RestBuildStatusSetRequestStateCANCELLED  RestBuildStatusSetRequestState = "CANCELLED"
	RestBuildStatusSetRequestStateFAILED     RestBuildStatusSetRequestState = "FAILED"
	RestBuildStatusSetRequestStateINPROGRESS RestBuildStatusSetRequestState = "INPROGRESS"
	RestBuildStatusSetRequestStateSUCCESSFUL RestBuildStatusSetRequestState = "SUCCESSFUL"
	RestBuildStatusSetRequestStateUNKNOWN    RestBuildStatusSetRequestState = "UNKNOWN"
)

// Defines values for RestChangeConflictOurChangeType.
const (
	RestChangeConflictOurChangeTypeADD     RestChangeConflictOurChangeType = "ADD"
	RestChangeConflictOurChangeTypeCOPY    RestChangeConflictOurChangeType = "COPY"
	RestChangeConflictOurChangeTypeDELETE  RestChangeConflictOurChangeType = "DELETE"
	RestChangeConflictOurChangeTypeMODIFY  RestChangeConflictOurChangeType = "MODIFY"
	RestChangeConflictOurChangeTypeMOVE    RestChangeConflictOurChangeType = "MOVE"
	RestChangeConflictOurChangeTypeUNKNOWN RestChangeConflictOurChangeType = "UNKNOWN"
)

// Defines values for RestChangeConflictTheirChangeType.
const (
	RestChangeConflictTheirChangeTypeADD     RestChangeConflictTheirChangeType = "ADD"
	RestChangeConflictTheirChangeTypeCOPY    RestChangeConflictTheirChangeType = "COPY"
	RestChangeConflictTheirChangeTypeDELETE  RestChangeConflictTheirChangeType = "DELETE"
	RestChangeConflictTheirChangeTypeMODIFY  RestChangeConflictTheirChangeType = "MODIFY"
	RestChangeConflictTheirChangeTypeMOVE    RestChangeConflictTheirChangeType = "MOVE"
	RestChangeConflictTheirChangeTypeUNKNOWN RestChangeConflictTheirChangeType = "UNKNOWN"
)

// Defines values for RestChangeNodeType.
const (
	DIRECTORY RestChangeNodeType = "DIRECTORY"
	FILE      RestChangeNodeType = "FILE"
	SUBMODULE RestChangeNodeType = "SUBMODULE"
)

// Defines values for RestChangeType.
const (
	RestChangeTypeADD     RestChangeType = "ADD"
	RestChangeTypeCOPY    RestChangeType = "COPY"
	RestChangeTypeDELETE  RestChangeType = "DELETE"
	RestChangeTypeMODIFY  RestChangeType = "MODIFY"
	RestChangeTypeMOVE    RestChangeType = "MOVE"
	RestChangeTypeUNKNOWN RestChangeType = "UNKNOWN"
)

// Defines values for RestChangesetRepositoryOriginProjectType.
const (
	RestChangesetRepositoryOriginProjectTypeNORMAL   RestChangesetRepositoryOriginProjectType = "NORMAL"
	RestChangesetRepositoryOriginProjectTypePERSONAL RestChangesetRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestChangesetRepositoryOriginState.
const (
	RestChangesetRepositoryOriginStateAVAILABLE            RestChangesetRepositoryOriginState = "AVAILABLE"
	RestChangesetRepositoryOriginStateINITIALISATIONFAILED RestChangesetRepositoryOriginState = "INITIALISATION_FAILED"
	RestChangesetRepositoryOriginStateINITIALISING         RestChangesetRepositoryOriginState = "INITIALISING"
	RestChangesetRepositoryOriginStateOFFLINE              RestChangesetRepositoryOriginState = "OFFLINE"
)

// Defines values for RestChangesetRepositoryProjectType.
const (
	RestChangesetRepositoryProjectTypeNORMAL   RestChangesetRepositoryProjectType = "NORMAL"
	RestChangesetRepositoryProjectTypePERSONAL RestChangesetRepositoryProjectType = "PERSONAL"
)

// Defines values for RestChangesetRepositoryState.
const (
	RestChangesetRepositoryStateAVAILABLE            RestChangesetRepositoryState = "AVAILABLE"
	RestChangesetRepositoryStateINITIALISATIONFAILED RestChangesetRepositoryState = "INITIALISATION_FAILED"
	RestChangesetRepositoryStateINITIALISING         RestChangesetRepositoryState = "INITIALISING"
	RestChangesetRepositoryStateOFFLINE              RestChangesetRepositoryState = "OFFLINE"
)

// Defines values for RestCommentAnchorDiffType.
const (
	RestCommentAnchorDiffTypeCOMMIT    RestCommentAnchorDiffType = "COMMIT"
	RestCommentAnchorDiffTypeEFFECTIVE RestCommentAnchorDiffType = "EFFECTIVE"
	RestCommentAnchorDiffTypeRANGE     RestCommentAnchorDiffType = "RANGE"
)

// Defines values for RestCommentAnchorFileType.
const (
	RestCommentAnchorFileTypeFROM RestCommentAnchorFileType = "FROM"
	RestCommentAnchorFileTypeTO   RestCommentAnchorFileType = "TO"
)

// Defines values for RestCommentAnchorLineType.
const (
	RestCommentAnchorLineTypeADDED   RestCommentAnchorLineType = "ADDED"
	RestCommentAnchorLineTypeCONTEXT RestCommentAnchorLineType = "CONTEXT"
	RestCommentAnchorLineTypeREMOVED RestCommentAnchorLineType = "REMOVED"
)

// Defines values for RestCommentAnchorMultilineMarkerStartLineType.
const (
	RestCommentAnchorMultilineMarkerStartLineTypeADDED   RestCommentAnchorMultilineMarkerStartLineType = "ADDED"
	RestCommentAnchorMultilineMarkerStartLineTypeCONTEXT RestCommentAnchorMultilineMarkerStartLineType = "CONTEXT"
	RestCommentAnchorMultilineMarkerStartLineTypeREMOVED RestCommentAnchorMultilineMarkerStartLineType = "REMOVED"
)

// Defines values for RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType.
const (
	RestCommentAnchorPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestCommentAnchorPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestCommentAnchorPullRequestFromRefRepositoryOriginState.
const (
	RestCommentAnchorPullRequestFromRefRepositoryOriginStateAVAILABLE            RestCommentAnchorPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestCommentAnchorPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestCommentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestCommentAnchorPullRequestFromRefRepositoryOriginStateINITIALISING         RestCommentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestCommentAnchorPullRequestFromRefRepositoryOriginStateOFFLINE              RestCommentAnchorPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestCommentAnchorPullRequestFromRefRepositoryProjectType.
const (
	RestCommentAnchorPullRequestFromRefRepositoryProjectTypeNORMAL   RestCommentAnchorPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestCommentAnchorPullRequestFromRefRepositoryProjectTypePERSONAL RestCommentAnchorPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestCommentAnchorPullRequestFromRefRepositoryState.
const (
	RestCommentAnchorPullRequestFromRefRepositoryStateAVAILABLE            RestCommentAnchorPullRequestFromRefRepositoryState = "AVAILABLE"
	RestCommentAnchorPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestCommentAnchorPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestCommentAnchorPullRequestFromRefRepositoryStateINITIALISING         RestCommentAnchorPullRequestFromRefRepositoryState = "INITIALISING"
	RestCommentAnchorPullRequestFromRefRepositoryStateOFFLINE              RestCommentAnchorPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestCommentAnchorPullRequestFromRefType.
const (
	RestCommentAnchorPullRequestFromRefTypeBRANCH RestCommentAnchorPullRequestFromRefType = "BRANCH"
	RestCommentAnchorPullRequestFromRefTypeTAG    RestCommentAnchorPullRequestFromRefType = "TAG"
)

// Defines values for RestCommentAnchorPullRequestState.
const (
	RestCommentAnchorPullRequestStateDECLINED RestCommentAnchorPullRequestState = "DECLINED"
	RestCommentAnchorPullRequestStateMERGED   RestCommentAnchorPullRequestState = "MERGED"
	RestCommentAnchorPullRequestStateOPEN     RestCommentAnchorPullRequestState = "OPEN"
)

// Defines values for RestCommentAnchorPullRequestToRefRepositoryOriginProjectType.
const (
	RestCommentAnchorPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestCommentAnchorPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestCommentAnchorPullRequestToRefRepositoryOriginProjectTypePERSONAL RestCommentAnchorPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestCommentAnchorPullRequestToRefRepositoryOriginState.
const (
	RestCommentAnchorPullRequestToRefRepositoryOriginStateAVAILABLE            RestCommentAnchorPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestCommentAnchorPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestCommentAnchorPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestCommentAnchorPullRequestToRefRepositoryOriginStateINITIALISING         RestCommentAnchorPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestCommentAnchorPullRequestToRefRepositoryOriginStateOFFLINE              RestCommentAnchorPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestCommentAnchorPullRequestToRefRepositoryProjectType.
const (
	RestCommentAnchorPullRequestToRefRepositoryProjectTypeNORMAL   RestCommentAnchorPullRequestToRefRepositoryProjectType = "NORMAL"
	RestCommentAnchorPullRequestToRefRepositoryProjectTypePERSONAL RestCommentAnchorPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestCommentAnchorPullRequestToRefRepositoryState.
const (
	RestCommentAnchorPullRequestToRefRepositoryStateAVAILABLE            RestCommentAnchorPullRequestToRefRepositoryState = "AVAILABLE"
	RestCommentAnchorPullRequestToRefRepositoryStateINITIALISATIONFAILED RestCommentAnchorPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestCommentAnchorPullRequestToRefRepositoryStateINITIALISING         RestCommentAnchorPullRequestToRefRepositoryState = "INITIALISING"
	RestCommentAnchorPullRequestToRefRepositoryStateOFFLINE              RestCommentAnchorPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestCommentAnchorPullRequestToRefType.
const (
	RestCommentAnchorPullRequestToRefTypeBRANCH RestCommentAnchorPullRequestToRefType = "BRANCH"
	RestCommentAnchorPullRequestToRefTypeTAG    RestCommentAnchorPullRequestToRefType = "TAG"
)

// Defines values for RestCommentAuthorType.
const (
	RestCommentAuthorTypeNORMAL  RestCommentAuthorType = "NORMAL"
	RestCommentAuthorTypeSERVICE RestCommentAuthorType = "SERVICE"
)

// Defines values for RestCommentParentAnchorDiffType.
const (
	RestCommentParentAnchorDiffTypeCOMMIT    RestCommentParentAnchorDiffType = "COMMIT"
	RestCommentParentAnchorDiffTypeEFFECTIVE RestCommentParentAnchorDiffType = "EFFECTIVE"
	RestCommentParentAnchorDiffTypeRANGE     RestCommentParentAnchorDiffType = "RANGE"
)

// Defines values for RestCommentParentAnchorFileType.
const (
	RestCommentParentAnchorFileTypeFROM RestCommentParentAnchorFileType = "FROM"
	RestCommentParentAnchorFileTypeTO   RestCommentParentAnchorFileType = "TO"
)

// Defines values for RestCommentParentAnchorLineType.
const (
	RestCommentParentAnchorLineTypeADDED   RestCommentParentAnchorLineType = "ADDED"
	RestCommentParentAnchorLineTypeCONTEXT RestCommentParentAnchorLineType = "CONTEXT"
	RestCommentParentAnchorLineTypeREMOVED RestCommentParentAnchorLineType = "REMOVED"
)

// Defines values for RestCommentParentAnchorMultilineMarkerStartLineType.
const (
	RestCommentParentAnchorMultilineMarkerStartLineTypeADDED   RestCommentParentAnchorMultilineMarkerStartLineType = "ADDED"
	RestCommentParentAnchorMultilineMarkerStartLineTypeCONTEXT RestCommentParentAnchorMultilineMarkerStartLineType = "CONTEXT"
	RestCommentParentAnchorMultilineMarkerStartLineTypeREMOVED RestCommentParentAnchorMultilineMarkerStartLineType = "REMOVED"
)

// Defines values for RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType.
const (
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestCommentParentAnchorPullRequestFromRefRepositoryOriginState.
const (
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginStateAVAILABLE            RestCommentParentAnchorPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestCommentParentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginStateINITIALISING         RestCommentParentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestCommentParentAnchorPullRequestFromRefRepositoryOriginStateOFFLINE              RestCommentParentAnchorPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestCommentParentAnchorPullRequestFromRefRepositoryProjectType.
const (
	RestCommentParentAnchorPullRequestFromRefRepositoryProjectTypeNORMAL   RestCommentParentAnchorPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestCommentParentAnchorPullRequestFromRefRepositoryProjectTypePERSONAL RestCommentParentAnchorPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestCommentParentAnchorPullRequestFromRefRepositoryState.
const (
	RestCommentParentAnchorPullRequestFromRefRepositoryStateAVAILABLE            RestCommentParentAnchorPullRequestFromRefRepositoryState = "AVAILABLE"
	RestCommentParentAnchorPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestCommentParentAnchorPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestCommentParentAnchorPullRequestFromRefRepositoryStateINITIALISING         RestCommentParentAnchorPullRequestFromRefRepositoryState = "INITIALISING"
	RestCommentParentAnchorPullRequestFromRefRepositoryStateOFFLINE              RestCommentParentAnchorPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestCommentParentAnchorPullRequestFromRefType.
const (
	RestCommentParentAnchorPullRequestFromRefTypeBRANCH RestCommentParentAnchorPullRequestFromRefType = "BRANCH"
	RestCommentParentAnchorPullRequestFromRefTypeTAG    RestCommentParentAnchorPullRequestFromRefType = "TAG"
)

// Defines values for RestCommentParentAnchorPullRequestState.
const (
	RestCommentParentAnchorPullRequestStateDECLINED RestCommentParentAnchorPullRequestState = "DECLINED"
	RestCommentParentAnchorPullRequestStateMERGED   RestCommentParentAnchorPullRequestState = "MERGED"
	RestCommentParentAnchorPullRequestStateOPEN     RestCommentParentAnchorPullRequestState = "OPEN"
)

// Defines values for RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType.
const (
	RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectTypePERSONAL RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestCommentParentAnchorPullRequestToRefRepositoryOriginState.
const (
	RestCommentParentAnchorPullRequestToRefRepositoryOriginStateAVAILABLE            RestCommentParentAnchorPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestCommentParentAnchorPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestCommentParentAnchorPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestCommentParentAnchorPullRequestToRefRepositoryOriginStateINITIALISING         RestCommentParentAnchorPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestCommentParentAnchorPullRequestToRefRepositoryOriginStateOFFLINE              RestCommentParentAnchorPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestCommentParentAnchorPullRequestToRefRepositoryProjectType.
const (
	RestCommentParentAnchorPullRequestToRefRepositoryProjectTypeNORMAL   RestCommentParentAnchorPullRequestToRefRepositoryProjectType = "NORMAL"
	RestCommentParentAnchorPullRequestToRefRepositoryProjectTypePERSONAL RestCommentParentAnchorPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestCommentParentAnchorPullRequestToRefRepositoryState.
const (
	RestCommentParentAnchorPullRequestToRefRepositoryStateAVAILABLE            RestCommentParentAnchorPullRequestToRefRepositoryState = "AVAILABLE"
	RestCommentParentAnchorPullRequestToRefRepositoryStateINITIALISATIONFAILED RestCommentParentAnchorPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestCommentParentAnchorPullRequestToRefRepositoryStateINITIALISING         RestCommentParentAnchorPullRequestToRefRepositoryState = "INITIALISING"
	RestCommentParentAnchorPullRequestToRefRepositoryStateOFFLINE              RestCommentParentAnchorPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestCommentParentAnchorPullRequestToRefType.
const (
	RestCommentParentAnchorPullRequestToRefTypeBRANCH RestCommentParentAnchorPullRequestToRefType = "BRANCH"
	RestCommentParentAnchorPullRequestToRefTypeTAG    RestCommentParentAnchorPullRequestToRefType = "TAG"
)

// Defines values for RestCommentParentAuthorType.
const (
	RestCommentParentAuthorTypeNORMAL  RestCommentParentAuthorType = "NORMAL"
	RestCommentParentAuthorTypeSERVICE RestCommentParentAuthorType = "SERVICE"
)

// Defines values for RestCommentParentResolverType.
const (
	RestCommentParentResolverTypeNORMAL  RestCommentParentResolverType = "NORMAL"
	RestCommentParentResolverTypeSERVICE RestCommentParentResolverType = "SERVICE"
)

// Defines values for RestCommentParentThreadResolverType.
const (
	RestCommentParentThreadResolverTypeNORMAL  RestCommentParentThreadResolverType = "NORMAL"
	RestCommentParentThreadResolverTypeSERVICE RestCommentParentThreadResolverType = "SERVICE"
)

// Defines values for RestCommentResolverType.
const (
	RestCommentResolverTypeNORMAL  RestCommentResolverType = "NORMAL"
	RestCommentResolverTypeSERVICE RestCommentResolverType = "SERVICE"
)

// Defines values for RestCommentThreadResolverType.
const (
	RestCommentThreadResolverTypeNORMAL  RestCommentThreadResolverType = "NORMAL"
	RestCommentThreadResolverTypeSERVICE RestCommentThreadResolverType = "SERVICE"
)

// Defines values for RestDefaultReviewersRequestSourceMatcherTypeId.
const (
	RestDefaultReviewersRequestSourceMatcherTypeIdANYREF        RestDefaultReviewersRequestSourceMatcherTypeId = "ANY_REF"
	RestDefaultReviewersRequestSourceMatcherTypeIdBRANCH        RestDefaultReviewersRequestSourceMatcherTypeId = "BRANCH"
	RestDefaultReviewersRequestSourceMatcherTypeIdMODELBRANCH   RestDefaultReviewersRequestSourceMatcherTypeId = "MODEL_BRANCH"
	RestDefaultReviewersRequestSourceMatcherTypeIdMODELCATEGORY RestDefaultReviewersRequestSourceMatcherTypeId = "MODEL_CATEGORY"
	RestDefaultReviewersRequestSourceMatcherTypeIdPATTERN       RestDefaultReviewersRequestSourceMatcherTypeId = "PATTERN"
)

// Defines values for RestDefaultReviewersRequestTargetMatcherTypeId.
const (
	RestDefaultReviewersRequestTargetMatcherTypeIdANYREF        RestDefaultReviewersRequestTargetMatcherTypeId = "ANY_REF"
	RestDefaultReviewersRequestTargetMatcherTypeIdBRANCH        RestDefaultReviewersRequestTargetMatcherTypeId = "BRANCH"
	RestDefaultReviewersRequestTargetMatcherTypeIdMODELBRANCH   RestDefaultReviewersRequestTargetMatcherTypeId = "MODEL_BRANCH"
	RestDefaultReviewersRequestTargetMatcherTypeIdMODELCATEGORY RestDefaultReviewersRequestTargetMatcherTypeId = "MODEL_CATEGORY"
	RestDefaultReviewersRequestTargetMatcherTypeIdPATTERN       RestDefaultReviewersRequestTargetMatcherTypeId = "PATTERN"
)

// Defines values for RestDefaultTaskRequestSourceMatcherTypeId.
const (
	RestDefaultTaskRequestSourceMatcherTypeIdANYREF        RestDefaultTaskRequestSourceMatcherTypeId = "ANY_REF"
	RestDefaultTaskRequestSourceMatcherTypeIdBRANCH        RestDefaultTaskRequestSourceMatcherTypeId = "BRANCH"
	RestDefaultTaskRequestSourceMatcherTypeIdMODELBRANCH   RestDefaultTaskRequestSourceMatcherTypeId = "MODEL_BRANCH"
	RestDefaultTaskRequestSourceMatcherTypeIdMODELCATEGORY RestDefaultTaskRequestSourceMatcherTypeId = "MODEL_CATEGORY"
	RestDefaultTaskRequestSourceMatcherTypeIdPATTERN       RestDefaultTaskRequestSourceMatcherTypeId = "PATTERN"
)

// Defines values for RestDefaultTaskRequestTargetMatcherTypeId.
const (
	RestDefaultTaskRequestTargetMatcherTypeIdANYREF        RestDefaultTaskRequestTargetMatcherTypeId = "ANY_REF"
	RestDefaultTaskRequestTargetMatcherTypeIdBRANCH        RestDefaultTaskRequestTargetMatcherTypeId = "BRANCH"
	RestDefaultTaskRequestTargetMatcherTypeIdMODELBRANCH   RestDefaultTaskRequestTargetMatcherTypeId = "MODEL_BRANCH"
	RestDefaultTaskRequestTargetMatcherTypeIdMODELCATEGORY RestDefaultTaskRequestTargetMatcherTypeId = "MODEL_CATEGORY"
	RestDefaultTaskRequestTargetMatcherTypeIdPATTERN       RestDefaultTaskRequestTargetMatcherTypeId = "PATTERN"
)

// Defines values for RestDeploymentRepositoryOriginProjectType.
const (
	RestDeploymentRepositoryOriginProjectTypeNORMAL   RestDeploymentRepositoryOriginProjectType = "NORMAL"
	RestDeploymentRepositoryOriginProjectTypePERSONAL RestDeploymentRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestDeploymentRepositoryOriginState.
const (
	RestDeploymentRepositoryOriginStateAVAILABLE            RestDeploymentRepositoryOriginState = "AVAILABLE"
	RestDeploymentRepositoryOriginStateINITIALISATIONFAILED RestDeploymentRepositoryOriginState = "INITIALISATION_FAILED"
	RestDeploymentRepositoryOriginStateINITIALISING         RestDeploymentRepositoryOriginState = "INITIALISING"
	RestDeploymentRepositoryOriginStateOFFLINE              RestDeploymentRepositoryOriginState = "OFFLINE"
)

// Defines values for RestDeploymentRepositoryProjectType.
const (
	RestDeploymentRepositoryProjectTypeNORMAL   RestDeploymentRepositoryProjectType = "NORMAL"
	RestDeploymentRepositoryProjectTypePERSONAL RestDeploymentRepositoryProjectType = "PERSONAL"
)

// Defines values for RestDeploymentRepositoryState.
const (
	RestDeploymentRepositoryStateAVAILABLE            RestDeploymentRepositoryState = "AVAILABLE"
	RestDeploymentRepositoryStateINITIALISATIONFAILED RestDeploymentRepositoryState = "INITIALISATION_FAILED"
	RestDeploymentRepositoryStateINITIALISING         RestDeploymentRepositoryState = "INITIALISING"
	RestDeploymentRepositoryStateOFFLINE              RestDeploymentRepositoryState = "OFFLINE"
)

// Defines values for RestDeploymentState.
const (
	RestDeploymentStateCANCELLED  RestDeploymentState = "CANCELLED"
	RestDeploymentStateFAILED     RestDeploymentState = "FAILED"
	RestDeploymentStateINPROGRESS RestDeploymentState = "IN_PROGRESS"
	RestDeploymentStatePENDING    RestDeploymentState = "PENDING"
	RestDeploymentStateROLLEDBACK RestDeploymentState = "ROLLED_BACK"
	RestDeploymentStateSUCCESSFUL RestDeploymentState = "SUCCESSFUL"
	RestDeploymentStateUNKNOWN    RestDeploymentState = "UNKNOWN"
)

// Defines values for RestDeploymentSetRequestState.
const (
	RestDeploymentSetRequestStateCANCELLED  RestDeploymentSetRequestState = "CANCELLED"
	RestDeploymentSetRequestStateFAILED     RestDeploymentSetRequestState = "FAILED"
	RestDeploymentSetRequestStateINPROGRESS RestDeploymentSetRequestState = "IN_PROGRESS"
	RestDeploymentSetRequestStatePENDING    RestDeploymentSetRequestState = "PENDING"
	RestDeploymentSetRequestStateROLLEDBACK RestDeploymentSetRequestState = "ROLLED_BACK"
	RestDeploymentSetRequestStateSUCCESSFUL RestDeploymentSetRequestState = "SUCCESSFUL"
	RestDeploymentSetRequestStateUNKNOWN    RestDeploymentSetRequestState = "UNKNOWN"
)

// Defines values for RestDetailedUserType.
const (
	RestDetailedUserTypeNORMAL  RestDetailedUserType = "NORMAL"
	RestDetailedUserTypeSERVICE RestDetailedUserType = "SERVICE"
)

// Defines values for RestDiffLineConflictMarker.
const (
	MARKER RestDiffLineConflictMarker = "MARKER"
	OURS   RestDiffLineConflictMarker = "OURS"
	THEIRS RestDiffLineConflictMarker = "THEIRS"
)

// Defines values for RestDiffSegmentType.
const (
	RestDiffSegmentTypeADDED   RestDiffSegmentType = "ADDED"
	RestDiffSegmentTypeCONTEXT RestDiffSegmentType = "CONTEXT"
	RestDiffSegmentTypeREMOVED RestDiffSegmentType = "REMOVED"
)

// Defines values for RestFarmSynchronizationRequestType.
const (
	Incremental RestFarmSynchronizationRequestType = "incremental"
	Snapshot    RestFarmSynchronizationRequestType = "snapshot"
)

// Defines values for RestGitTagCreateRequestType.
const (
	ANNOTATED   RestGitTagCreateRequestType = "ANNOTATED"
	LIGHTWEIGHT RestGitTagCreateRequestType = "LIGHTWEIGHT"
)

// Defines values for RestHookScriptType.
const (
	RestHookScriptTypePOST RestHookScriptType = "POST"
	RestHookScriptTypePRE  RestHookScriptType = "PRE"
)

// Defines values for RestHookScriptConfigScopeType.
const (
	RestHookScriptConfigScopeTypeGLOBAL     RestHookScriptConfigScopeType = "GLOBAL"
	RestHookScriptConfigScopeTypePROJECT    RestHookScriptConfigScopeType = "PROJECT"
	RestHookScriptConfigScopeTypeREPOSITORY RestHookScriptConfigScopeType = "REPOSITORY"
)

// Defines values for RestHookScriptConfigScriptType.
const (
	RestHookScriptConfigScriptTypePOST RestHookScriptConfigScriptType = "POST"
	RestHookScriptConfigScriptTypePRE  RestHookScriptConfigScriptType = "PRE"
)

// Defines values for RestInsightReportResult.
const (
	FAIL RestInsightReportResult = "FAIL"
	PASS RestInsightReportResult = "PASS"
)

// Defines values for RestJobInitiatorType.
const (
	RestJobInitiatorTypeNORMAL  RestJobInitiatorType = "NORMAL"
	RestJobInitiatorTypeSERVICE RestJobInitiatorType = "SERVICE"
)

// Defines values for RestJobState.
const (
	RestJobStateABORTED      RestJobState = "ABORTED"
	RestJobStateCANCELED     RestJobState = "CANCELED"
	RestJobStateCANCELING    RestJobState = "CANCELING"
	RestJobStateCOMPLETED    RestJobState = "COMPLETED"
	RestJobStateFAILED       RestJobState = "FAILED"
	RestJobStateFINALISING   RestJobState = "FINALISING"
	RestJobStateINITIALISING RestJobState = "INITIALISING"
	RestJobStateREADY        RestJobState = "READY"
	RestJobStateRUNNING      RestJobState = "RUNNING"
	RestJobStateTIMEDOUT     RestJobState = "TIMED_OUT"
)

// Defines values for RestJobMessageSeverity.
const (
	ERROR RestJobMessageSeverity = "ERROR"
	INFO  RestJobMessageSeverity = "INFO"
	WARN  RestJobMessageSeverity = "WARN"
)

// Defines values for RestLabelableLabelableType.
const (
	RestLabelableLabelableTypeREPOSITORY RestLabelableLabelableType = "REPOSITORY"
)

// Defines values for RestLabelableOriginProjectType.
const (
	RestLabelableOriginProjectTypeNORMAL   RestLabelableOriginProjectType = "NORMAL"
	RestLabelableOriginProjectTypePERSONAL RestLabelableOriginProjectType = "PERSONAL"
)

// Defines values for RestLabelableOriginState.
const (
	RestLabelableOriginStateAVAILABLE            RestLabelableOriginState = "AVAILABLE"
	RestLabelableOriginStateINITIALISATIONFAILED RestLabelableOriginState = "INITIALISATION_FAILED"
	RestLabelableOriginStateINITIALISING         RestLabelableOriginState = "INITIALISING"
	RestLabelableOriginStateOFFLINE              RestLabelableOriginState = "OFFLINE"
)

// Defines values for RestLabelableProjectType.
const (
	RestLabelableProjectTypeNORMAL   RestLabelableProjectType = "NORMAL"
	RestLabelableProjectTypePERSONAL RestLabelableProjectType = "PERSONAL"
)

// Defines values for RestLabelableState.
const (
	RestLabelableStateAVAILABLE            RestLabelableState = "AVAILABLE"
	RestLabelableStateINITIALISATIONFAILED RestLabelableState = "INITIALISATION_FAILED"
	RestLabelableStateINITIALISING         RestLabelableState = "INITIALISING"
	RestLabelableStateOFFLINE              RestLabelableState = "OFFLINE"
)

// Defines values for RestMailConfigurationProtocol.
const (
	RestMailConfigurationProtocolSMTP  RestMailConfigurationProtocol = "SMTP"
	RestMailConfigurationProtocolSMTPS RestMailConfigurationProtocol = "SMTPS"
)

// Defines values for RestMeshNodeState.
const (
	RestMeshNodeStateAVAILABLE RestMeshNodeState = "AVAILABLE"
	RestMeshNodeStateDELETING  RestMeshNodeState = "DELETING"
	RestMeshNodeStateDISABLED  RestMeshNodeState = "DISABLED"
	RestMeshNodeStateDRAINING  RestMeshNodeState = "DRAINING"
	RestMeshNodeStateOFFLINE   RestMeshNodeState = "OFFLINE"
)

// Defines values for RestMigrationRepositoryMigrationState.
const (
	RestMigrationRepositoryMigrationStateCANCELED RestMigrationRepositoryMigrationState = "CANCELED"
	RestMigrationRepositoryMigrationStateFAILED   RestMigrationRepositoryMigrationState = "FAILED"
	RestMigrationRepositoryMigrationStateMIGRATED RestMigrationRepositoryMigrationState = "MIGRATED"
	RestMigrationRepositoryMigrationStateQUEUED   RestMigrationRepositoryMigrationState = "QUEUED"
	RestMigrationRepositoryMigrationStateSKIPPED  RestMigrationRepositoryMigrationState = "SKIPPED"
	RestMigrationRepositoryMigrationStateSTAGED   RestMigrationRepositoryMigrationState = "STAGED"
	RestMigrationRepositoryMigrationStateSTAGING  RestMigrationRepositoryMigrationState = "STAGING"
)

// Defines values for RestMigrationRepositoryRepositoryOriginProjectType.
const (
	RestMigrationRepositoryRepositoryOriginProjectTypeNORMAL   RestMigrationRepositoryRepositoryOriginProjectType = "NORMAL"
	RestMigrationRepositoryRepositoryOriginProjectTypePERSONAL RestMigrationRepositoryRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestMigrationRepositoryRepositoryOriginState.
const (
	RestMigrationRepositoryRepositoryOriginStateAVAILABLE            RestMigrationRepositoryRepositoryOriginState = "AVAILABLE"
	RestMigrationRepositoryRepositoryOriginStateINITIALISATIONFAILED RestMigrationRepositoryRepositoryOriginState = "INITIALISATION_FAILED"
	RestMigrationRepositoryRepositoryOriginStateINITIALISING         RestMigrationRepositoryRepositoryOriginState = "INITIALISING"
	RestMigrationRepositoryRepositoryOriginStateOFFLINE              RestMigrationRepositoryRepositoryOriginState = "OFFLINE"
)

// Defines values for RestMigrationRepositoryRepositoryProjectType.
const (
	RestMigrationRepositoryRepositoryProjectTypeNORMAL   RestMigrationRepositoryRepositoryProjectType = "NORMAL"
	RestMigrationRepositoryRepositoryProjectTypePERSONAL RestMigrationRepositoryRepositoryProjectType = "PERSONAL"
)

// Defines values for RestMigrationRepositoryRepositoryState.
const (
	RestMigrationRepositoryRepositoryStateAVAILABLE            RestMigrationRepositoryRepositoryState = "AVAILABLE"
	RestMigrationRepositoryRepositoryStateINITIALISATIONFAILED RestMigrationRepositoryRepositoryState = "INITIALISATION_FAILED"
	RestMigrationRepositoryRepositoryStateINITIALISING         RestMigrationRepositoryRepositoryState = "INITIALISING"
	RestMigrationRepositoryRepositoryStateOFFLINE              RestMigrationRepositoryRepositoryState = "OFFLINE"
)

// Defines values for RestMinimalRefType.
const (
	RestMinimalRefTypeBRANCH RestMinimalRefType = "BRANCH"
	RestMinimalRefTypeTAG    RestMinimalRefType = "TAG"
)

// Defines values for RestMirrorServerMirrorType.
const (
	RestMirrorServerMirrorTypeFARM   RestMirrorServerMirrorType = "FARM"
	RestMirrorServerMirrorTypeSINGLE RestMirrorServerMirrorType = "SINGLE"
)

// Defines values for RestMirroredRepositoryStatus.
const (
	RestMirroredRepositoryStatusAVAILABLE         RestMirroredRepositoryStatus = "AVAILABLE"
	RestMirroredRepositoryStatusERRORAVAILABLE    RestMirroredRepositoryStatus = "ERROR_AVAILABLE"
	RestMirroredRepositoryStatusERRORINITIALIZING RestMirroredRepositoryStatus = "ERROR_INITIALIZING"
	RestMirroredRepositoryStatusINITIALIZING      RestMirroredRepositoryStatus = "INITIALIZING"
	RestMirroredRepositoryStatusNOTMIRRORED       RestMirroredRepositoryStatus = "NOT_MIRRORED"
)

// Defines values for RestMirroredRepositoryDescriptorMirrorServerMirrorType.
const (
	RestMirroredRepositoryDescriptorMirrorServerMirrorTypeFARM   RestMirroredRepositoryDescriptorMirrorServerMirrorType = "FARM"
	RestMirroredRepositoryDescriptorMirrorServerMirrorTypeSINGLE RestMirroredRepositoryDescriptorMirrorServerMirrorType = "SINGLE"
)

// Defines values for RestMirroringRequestMirrorType.
const (
	FARM   RestMirroringRequestMirrorType = "FARM"
	SINGLE RestMirroringRequestMirrorType = "SINGLE"
)

// Defines values for RestMirroringRequestState.
const (
	RestMirroringRequestStateACCEPTED RestMirroringRequestState = "ACCEPTED"
	RestMirroringRequestStatePENDING  RestMirroringRequestState = "PENDING"
	RestMirroringRequestStateREJECTED RestMirroringRequestState = "REJECTED"
)

// Defines values for RestNodeConnectivityReportNodeType.
const (
	RestNodeConnectivityReportNodeTypeBITBUCKET RestNodeConnectivityReportNodeType = "BITBUCKET"
	RestNodeConnectivityReportNodeTypeMESH      RestNodeConnectivityReportNodeType = "MESH"
)

// Defines values for RestNodeConnectivitySummaryNodeType.
const (
	RestNodeConnectivitySummaryNodeTypeBITBUCKET RestNodeConnectivitySummaryNodeType = "BITBUCKET"
	RestNodeConnectivitySummaryNodeTypeMESH      RestNodeConnectivitySummaryNodeType = "MESH"
)

// Defines values for RestPermittedUserPermission.
const (
	RestPermittedUserPermissionADMIN         RestPermittedUserPermission = "ADMIN"
	RestPermittedUserPermissionLICENSEDUSER  RestPermittedUserPermission = "LICENSED_USER"
	RestPermittedUserPermissionPROJECTADMIN  RestPermittedUserPermission = "PROJECT_ADMIN"
	RestPermittedUserPermissionPROJECTCREATE RestPermittedUserPermission = "PROJECT_CREATE"
	RestPermittedUserPermissionPROJECTREAD   RestPermittedUserPermission = "PROJECT_READ"
	RestPermittedUserPermissionPROJECTVIEW   RestPermittedUserPermission = "PROJECT_VIEW"
	RestPermittedUserPermissionPROJECTWRITE  RestPermittedUserPermission = "PROJECT_WRITE"
	RestPermittedUserPermissionREPOADMIN     RestPermittedUserPermission = "REPO_ADMIN"
	RestPermittedUserPermissionREPOCREATE    RestPermittedUserPermission = "REPO_CREATE"
	RestPermittedUserPermissionREPOREAD      RestPermittedUserPermission = "REPO_READ"
	RestPermittedUserPermissionREPOWRITE     RestPermittedUserPermission = "REPO_WRITE"
	RestPermittedUserPermissionSYSADMIN      RestPermittedUserPermission = "SYS_ADMIN"
	RestPermittedUserPermissionUSERADMIN     RestPermittedUserPermission = "USER_ADMIN"
)

// Defines values for RestPermittedUserUserType.
const (
	RestPermittedUserUserTypeNORMAL  RestPermittedUserUserType = "NORMAL"
	RestPermittedUserUserTypeSERVICE RestPermittedUserUserType = "SERVICE"
)

// Defines values for RestProjectType.
const (
	RestProjectTypeNORMAL   RestProjectType = "NORMAL"
	RestProjectTypePERSONAL RestProjectType = "PERSONAL"
)

// Defines values for RestProjectSettingsRestrictionProcessedState.
const (
	FAILED      RestProjectSettingsRestrictionProcessedState = "FAILED"
	INPROGRESS  RestProjectSettingsRestrictionProcessedState = "IN_PROGRESS"
	PROCESSED   RestProjectSettingsRestrictionProcessedState = "PROCESSED"
	UNPROCESSED RestProjectSettingsRestrictionProcessedState = "UNPROCESSED"
)

// Defines values for RestProjectSettingsRestrictionProjectType.
const (
	RestProjectSettingsRestrictionProjectTypeNORMAL   RestProjectSettingsRestrictionProjectType = "NORMAL"
	RestProjectSettingsRestrictionProjectTypePERSONAL RestProjectSettingsRestrictionProjectType = "PERSONAL"
)

// Defines values for RestPullRequestFromRefRepositoryOriginProjectType.
const (
	RestPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestPullRequestFromRefRepositoryOriginState.
const (
	RestPullRequestFromRefRepositoryOriginStateAVAILABLE            RestPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestPullRequestFromRefRepositoryOriginStateINITIALISING         RestPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestPullRequestFromRefRepositoryOriginStateOFFLINE              RestPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestPullRequestFromRefRepositoryProjectType.
const (
	RestPullRequestFromRefRepositoryProjectTypeNORMAL   RestPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestPullRequestFromRefRepositoryProjectTypePERSONAL RestPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestPullRequestFromRefRepositoryState.
const (
	RestPullRequestFromRefRepositoryStateAVAILABLE            RestPullRequestFromRefRepositoryState = "AVAILABLE"
	RestPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestPullRequestFromRefRepositoryStateINITIALISING         RestPullRequestFromRefRepositoryState = "INITIALISING"
	RestPullRequestFromRefRepositoryStateOFFLINE              RestPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestPullRequestFromRefType.
const (
	RestPullRequestFromRefTypeBRANCH RestPullRequestFromRefType = "BRANCH"
	RestPullRequestFromRefTypeTAG    RestPullRequestFromRefType = "TAG"
)

// Defines values for RestPullRequestState.
const (
	RestPullRequestStateDECLINED RestPullRequestState = "DECLINED"
	RestPullRequestStateMERGED   RestPullRequestState = "MERGED"
	RestPullRequestStateOPEN     RestPullRequestState = "OPEN"
)

// Defines values for RestPullRequestToRefRepositoryOriginProjectType.
const (
	RestPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestPullRequestToRefRepositoryOriginProjectTypePERSONAL RestPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestPullRequestToRefRepositoryOriginState.
const (
	RestPullRequestToRefRepositoryOriginStateAVAILABLE            RestPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestPullRequestToRefRepositoryOriginStateINITIALISING         RestPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestPullRequestToRefRepositoryOriginStateOFFLINE              RestPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestPullRequestToRefRepositoryProjectType.
const (
	RestPullRequestToRefRepositoryProjectTypeNORMAL   RestPullRequestToRefRepositoryProjectType = "NORMAL"
	RestPullRequestToRefRepositoryProjectTypePERSONAL RestPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestPullRequestToRefRepositoryState.
const (
	RestPullRequestToRefRepositoryStateAVAILABLE            RestPullRequestToRefRepositoryState = "AVAILABLE"
	RestPullRequestToRefRepositoryStateINITIALISATIONFAILED RestPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestPullRequestToRefRepositoryStateINITIALISING         RestPullRequestToRefRepositoryState = "INITIALISING"
	RestPullRequestToRefRepositoryStateOFFLINE              RestPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestPullRequestToRefType.
const (
	RestPullRequestToRefTypeBRANCH RestPullRequestToRefType = "BRANCH"
	RestPullRequestToRefTypeTAG    RestPullRequestToRefType = "TAG"
)

// Defines values for RestPullRequestActivityAction.
const (
	RestPullRequestActivityActionAPPROVED           RestPullRequestActivityAction = "APPROVED"
	RestPullRequestActivityActionAUTOMERGECANCELLED RestPullRequestActivityAction = "AUTO_MERGE_CANCELLED"
	RestPullRequestActivityActionAUTOMERGEREQUESTED RestPullRequestActivityAction = "AUTO_MERGE_REQUESTED"
	RestPullRequestActivityActionCOMMENTED          RestPullRequestActivityAction = "COMMENTED"
	RestPullRequestActivityActionDECLINED           RestPullRequestActivityAction = "DECLINED"
	RestPullRequestActivityActionDELETED            RestPullRequestActivityAction = "DELETED"
	RestPullRequestActivityActionMERGED             RestPullRequestActivityAction = "MERGED"
	RestPullRequestActivityActionOPENED             RestPullRequestActivityAction = "OPENED"
	RestPullRequestActivityActionREOPENED           RestPullRequestActivityAction = "REOPENED"
	RestPullRequestActivityActionRESCOPED           RestPullRequestActivityAction = "RESCOPED"
	RestPullRequestActivityActionREVIEWCOMMENTED    RestPullRequestActivityAction = "REVIEW_COMMENTED"
	RestPullRequestActivityActionREVIEWDISCARDED    RestPullRequestActivityAction = "REVIEW_DISCARDED"
	RestPullRequestActivityActionREVIEWED           RestPullRequestActivityAction = "REVIEWED"
	RestPullRequestActivityActionREVIEWFINISHED     RestPullRequestActivityAction = "REVIEW_FINISHED"
	RestPullRequestActivityActionUNAPPROVED         RestPullRequestActivityAction = "UNAPPROVED"
	RestPullRequestActivityActionUPDATED            RestPullRequestActivityAction = "UPDATED"
)

// Defines values for RestPullRequestActivityUserType.
const (
	RestPullRequestActivityUserTypeNORMAL  RestPullRequestActivityUserType = "NORMAL"
	RestPullRequestActivityUserTypeSERVICE RestPullRequestActivityUserType = "SERVICE"
)

// Defines values for RestPullRequestAssignParticipantRoleRequestRole.
const (
	RestPullRequestAssignParticipantRoleRequestRoleAUTHOR      RestPullRequestAssignParticipantRoleRequestRole = "AUTHOR"
	RestPullRequestAssignParticipantRoleRequestRolePARTICIPANT RestPullRequestAssignParticipantRoleRequestRole = "PARTICIPANT"
	RestPullRequestAssignParticipantRoleRequestRoleREVIEWER    RestPullRequestAssignParticipantRoleRequestRole = "REVIEWER"
)

// Defines values for RestPullRequestAssignParticipantRoleRequestUserType.
const (
	RestPullRequestAssignParticipantRoleRequestUserTypeNORMAL  RestPullRequestAssignParticipantRoleRequestUserType = "NORMAL"
	RestPullRequestAssignParticipantRoleRequestUserTypeSERVICE RestPullRequestAssignParticipantRoleRequestUserType = "SERVICE"
)

// Defines values for RestPullRequestAssignStatusRequestStatus.
const (
	RestPullRequestAssignStatusRequestStatusAPPROVED   RestPullRequestAssignStatusRequestStatus = "APPROVED"
	RestPullRequestAssignStatusRequestStatusNEEDSWORK  RestPullRequestAssignStatusRequestStatus = "NEEDS_WORK"
	RestPullRequestAssignStatusRequestStatusUNAPPROVED RestPullRequestAssignStatusRequestStatus = "UNAPPROVED"
)

// Defines values for RestPullRequestConditionScopeType.
const (
	RestPullRequestConditionScopeTypeGLOBAL     RestPullRequestConditionScopeType = "GLOBAL"
	RestPullRequestConditionScopeTypePROJECT    RestPullRequestConditionScopeType = "PROJECT"
	RestPullRequestConditionScopeTypeREPOSITORY RestPullRequestConditionScopeType = "REPOSITORY"
)

// Defines values for RestPullRequestConditionSourceRefMatcherTypeId.
const (
	RestPullRequestConditionSourceRefMatcherTypeIdANYREF        RestPullRequestConditionSourceRefMatcherTypeId = "ANY_REF"
	RestPullRequestConditionSourceRefMatcherTypeIdBRANCH        RestPullRequestConditionSourceRefMatcherTypeId = "BRANCH"
	RestPullRequestConditionSourceRefMatcherTypeIdMODELBRANCH   RestPullRequestConditionSourceRefMatcherTypeId = "MODEL_BRANCH"
	RestPullRequestConditionSourceRefMatcherTypeIdMODELCATEGORY RestPullRequestConditionSourceRefMatcherTypeId = "MODEL_CATEGORY"
	RestPullRequestConditionSourceRefMatcherTypeIdPATTERN       RestPullRequestConditionSourceRefMatcherTypeId = "PATTERN"
)

// Defines values for RestPullRequestConditionTargetRefMatcherTypeId.
const (
	RestPullRequestConditionTargetRefMatcherTypeIdANYREF        RestPullRequestConditionTargetRefMatcherTypeId = "ANY_REF"
	RestPullRequestConditionTargetRefMatcherTypeIdBRANCH        RestPullRequestConditionTargetRefMatcherTypeId = "BRANCH"
	RestPullRequestConditionTargetRefMatcherTypeIdMODELBRANCH   RestPullRequestConditionTargetRefMatcherTypeId = "MODEL_BRANCH"
	RestPullRequestConditionTargetRefMatcherTypeIdMODELCATEGORY RestPullRequestConditionTargetRefMatcherTypeId = "MODEL_CATEGORY"
	RestPullRequestConditionTargetRefMatcherTypeIdPATTERN       RestPullRequestConditionTargetRefMatcherTypeId = "PATTERN"
)

// Defines values for RestPullRequestMergeabilityOutcome.
const (
	RestPullRequestMergeabilityOutcomeCLEAN      RestPullRequestMergeabilityOutcome = "CLEAN"
	RestPullRequestMergeabilityOutcomeCONFLICTED RestPullRequestMergeabilityOutcome = "CONFLICTED"
	RestPullRequestMergeabilityOutcomeUNKNOWN    RestPullRequestMergeabilityOutcome = "UNKNOWN"
)

// Defines values for RestPullRequestParticipantRole.
const (
	AUTHOR      RestPullRequestParticipantRole = "AUTHOR"
	PARTICIPANT RestPullRequestParticipantRole = "PARTICIPANT"
	REVIEWER    RestPullRequestParticipantRole = "REVIEWER"
)

// Defines values for RestPullRequestParticipantStatus.
const (
	RestPullRequestParticipantStatusAPPROVED   RestPullRequestParticipantStatus = "APPROVED"
	RestPullRequestParticipantStatusNEEDSWORK  RestPullRequestParticipantStatus = "NEEDS_WORK"
	RestPullRequestParticipantStatusUNAPPROVED RestPullRequestParticipantStatus = "UNAPPROVED"
)

// Defines values for RestPullRequestParticipantUserType.
const (
	RestPullRequestParticipantUserTypeNORMAL  RestPullRequestParticipantUserType = "NORMAL"
	RestPullRequestParticipantUserTypeSERVICE RestPullRequestParticipantUserType = "SERVICE"
)

// Defines values for RestPullRequestRebaseResultRefChangeRefType.
const (
	RestPullRequestRebaseResultRefChangeRefTypeBRANCH RestPullRequestRebaseResultRefChangeRefType = "BRANCH"
	RestPullRequestRebaseResultRefChangeRefTypeTAG    RestPullRequestRebaseResultRefChangeRefType = "TAG"
)

// Defines values for RestPullRequestRebaseResultRefChangeType.
const (
	RestPullRequestRebaseResultRefChangeTypeADD    RestPullRequestRebaseResultRefChangeType = "ADD"
	RestPullRequestRebaseResultRefChangeTypeDELETE RestPullRequestRebaseResultRefChangeType = "DELETE"
	RestPullRequestRebaseResultRefChangeTypeUPDATE RestPullRequestRebaseResultRefChangeType = "UPDATE"
)

// Defines values for RestPullRequestSuggestionFromRefType.
const (
	RestPullRequestSuggestionFromRefTypeBRANCH RestPullRequestSuggestionFromRefType = "BRANCH"
	RestPullRequestSuggestionFromRefTypeTAG    RestPullRequestSuggestionFromRefType = "TAG"
)

// Defines values for RestPullRequestSuggestionRefChangeRefType.
const (
	RestPullRequestSuggestionRefChangeRefTypeBRANCH RestPullRequestSuggestionRefChangeRefType = "BRANCH"
	RestPullRequestSuggestionRefChangeRefTypeTAG    RestPullRequestSuggestionRefChangeRefType = "TAG"
)

// Defines values for RestPullRequestSuggestionRefChangeType.
const (
	RestPullRequestSuggestionRefChangeTypeADD    RestPullRequestSuggestionRefChangeType = "ADD"
	RestPullRequestSuggestionRefChangeTypeDELETE RestPullRequestSuggestionRefChangeType = "DELETE"
	RestPullRequestSuggestionRefChangeTypeUPDATE RestPullRequestSuggestionRefChangeType = "UPDATE"
)

// Defines values for RestPullRequestSuggestionRepositoryOriginProjectType.
const (
	RestPullRequestSuggestionRepositoryOriginProjectTypeNORMAL   RestPullRequestSuggestionRepositoryOriginProjectType = "NORMAL"
	RestPullRequestSuggestionRepositoryOriginProjectTypePERSONAL RestPullRequestSuggestionRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestPullRequestSuggestionRepositoryOriginState.
const (
	RestPullRequestSuggestionRepositoryOriginStateAVAILABLE            RestPullRequestSuggestionRepositoryOriginState = "AVAILABLE"
	RestPullRequestSuggestionRepositoryOriginStateINITIALISATIONFAILED RestPullRequestSuggestionRepositoryOriginState = "INITIALISATION_FAILED"
	RestPullRequestSuggestionRepositoryOriginStateINITIALISING         RestPullRequestSuggestionRepositoryOriginState = "INITIALISING"
	RestPullRequestSuggestionRepositoryOriginStateOFFLINE              RestPullRequestSuggestionRepositoryOriginState = "OFFLINE"
)

// Defines values for RestPullRequestSuggestionRepositoryProjectType.
const (
	RestPullRequestSuggestionRepositoryProjectTypeNORMAL   RestPullRequestSuggestionRepositoryProjectType = "NORMAL"
	RestPullRequestSuggestionRepositoryProjectTypePERSONAL RestPullRequestSuggestionRepositoryProjectType = "PERSONAL"
)

// Defines values for RestPullRequestSuggestionRepositoryState.
const (
	RestPullRequestSuggestionRepositoryStateAVAILABLE            RestPullRequestSuggestionRepositoryState = "AVAILABLE"
	RestPullRequestSuggestionRepositoryStateINITIALISATIONFAILED RestPullRequestSuggestionRepositoryState = "INITIALISATION_FAILED"
	RestPullRequestSuggestionRepositoryStateINITIALISING         RestPullRequestSuggestionRepositoryState = "INITIALISING"
	RestPullRequestSuggestionRepositoryStateOFFLINE              RestPullRequestSuggestionRepositoryState = "OFFLINE"
)

// Defines values for RestPullRequestSuggestionToRefType.
const (
	RestPullRequestSuggestionToRefTypeBRANCH RestPullRequestSuggestionToRefType = "BRANCH"
	RestPullRequestSuggestionToRefTypeTAG    RestPullRequestSuggestionToRefType = "TAG"
)

// Defines values for RestRefMatcherTypeId.
const (
	RestRefMatcherTypeIdANYREF        RestRefMatcherTypeId = "ANY_REF"
	RestRefMatcherTypeIdBRANCH        RestRefMatcherTypeId = "BRANCH"
	RestRefMatcherTypeIdMODELBRANCH   RestRefMatcherTypeId = "MODEL_BRANCH"
	RestRefMatcherTypeIdMODELCATEGORY RestRefMatcherTypeId = "MODEL_CATEGORY"
	RestRefMatcherTypeIdPATTERN       RestRefMatcherTypeId = "PATTERN"
)

// Defines values for RestRefRestrictionMatcherTypeId.
const (
	RestRefRestrictionMatcherTypeIdANYREF        RestRefRestrictionMatcherTypeId = "ANY_REF"
	RestRefRestrictionMatcherTypeIdBRANCH        RestRefRestrictionMatcherTypeId = "BRANCH"
	RestRefRestrictionMatcherTypeIdMODELBRANCH   RestRefRestrictionMatcherTypeId = "MODEL_BRANCH"
	RestRefRestrictionMatcherTypeIdMODELCATEGORY RestRefRestrictionMatcherTypeId = "MODEL_CATEGORY"
	RestRefRestrictionMatcherTypeIdPATTERN       RestRefRestrictionMatcherTypeId = "PATTERN"
)

// Defines values for RestRefRestrictionScopeType.
const (
	RestRefRestrictionScopeTypeGLOBAL     RestRefRestrictionScopeType = "GLOBAL"
	RestRefRestrictionScopeTypePROJECT    RestRefRestrictionScopeType = "PROJECT"
	RestRefRestrictionScopeTypeREPOSITORY RestRefRestrictionScopeType = "REPOSITORY"
)

// Defines values for RestRefSyncRequestAction.
const (
	DISCARD RestRefSyncRequestAction = "DISCARD"
	MERGE   RestRefSyncRequestAction = "MERGE"
	REBASE  RestRefSyncRequestAction = "REBASE"
)

// Defines values for RestRefSyncStatusAheadRefsState.
const (
	RestRefSyncStatusAheadRefsStateAHEAD    RestRefSyncStatusAheadRefsState = "AHEAD"
	RestRefSyncStatusAheadRefsStateDIVERGED RestRefSyncStatusAheadRefsState = "DIVERGED"
	RestRefSyncStatusAheadRefsStateORPHANED RestRefSyncStatusAheadRefsState = "ORPHANED"
)

// Defines values for RestRefSyncStatusAheadRefsType.
const (
	RestRefSyncStatusAheadRefsTypeBRANCH RestRefSyncStatusAheadRefsType = "BRANCH"
	RestRefSyncStatusAheadRefsTypeTAG    RestRefSyncStatusAheadRefsType = "TAG"
)

// Defines values for RestRefSyncStatusDivergedRefsState.
const (
	RestRefSyncStatusDivergedRefsStateAHEAD    RestRefSyncStatusDivergedRefsState = "AHEAD"
	RestRefSyncStatusDivergedRefsStateDIVERGED RestRefSyncStatusDivergedRefsState = "DIVERGED"
	RestRefSyncStatusDivergedRefsStateORPHANED RestRefSyncStatusDivergedRefsState = "ORPHANED"
)

// Defines values for RestRefSyncStatusDivergedRefsType.
const (
	RestRefSyncStatusDivergedRefsTypeBRANCH RestRefSyncStatusDivergedRefsType = "BRANCH"
	RestRefSyncStatusDivergedRefsTypeTAG    RestRefSyncStatusDivergedRefsType = "TAG"
)

// Defines values for RestRefSyncStatusOrphanedRefsState.
const (
	RestRefSyncStatusOrphanedRefsStateAHEAD    RestRefSyncStatusOrphanedRefsState = "AHEAD"
	RestRefSyncStatusOrphanedRefsStateDIVERGED RestRefSyncStatusOrphanedRefsState = "DIVERGED"
	RestRefSyncStatusOrphanedRefsStateORPHANED RestRefSyncStatusOrphanedRefsState = "ORPHANED"
)

// Defines values for RestRefSyncStatusOrphanedRefsType.
const (
	RestRefSyncStatusOrphanedRefsTypeBRANCH RestRefSyncStatusOrphanedRefsType = "BRANCH"
	RestRefSyncStatusOrphanedRefsTypeTAG    RestRefSyncStatusOrphanedRefsType = "TAG"
)

// Defines values for RestRejectedRefState.
const (
	RestRejectedRefStateAHEAD    RestRejectedRefState = "AHEAD"
	RestRejectedRefStateDIVERGED RestRejectedRefState = "DIVERGED"
	RestRejectedRefStateORPHANED RestRejectedRefState = "ORPHANED"
)

// Defines values for RestRejectedRefType.
const (
	RestRejectedRefTypeBRANCH RestRejectedRefType = "BRANCH"
	RestRejectedRefTypeTAG    RestRejectedRefType = "TAG"
)

// Defines values for RestRepositoryOriginProjectType.
const (
	RestRepositoryOriginProjectTypeNORMAL   RestRepositoryOriginProjectType = "NORMAL"
	RestRepositoryOriginProjectTypePERSONAL RestRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestRepositoryOriginState.
const (
	RestRepositoryOriginStateAVAILABLE            RestRepositoryOriginState = "AVAILABLE"
	RestRepositoryOriginStateINITIALISATIONFAILED RestRepositoryOriginState = "INITIALISATION_FAILED"
	RestRepositoryOriginStateINITIALISING         RestRepositoryOriginState = "INITIALISING"
	RestRepositoryOriginStateOFFLINE              RestRepositoryOriginState = "OFFLINE"
)

// Defines values for RestRepositoryProjectType.
const (
	RestRepositoryProjectTypeNORMAL   RestRepositoryProjectType = "NORMAL"
	RestRepositoryProjectTypePERSONAL RestRepositoryProjectType = "PERSONAL"
)

// Defines values for RestRepositoryState.
const (
	RestRepositoryStateAVAILABLE            RestRepositoryState = "AVAILABLE"
	RestRepositoryStateINITIALISATIONFAILED RestRepositoryState = "INITIALISATION_FAILED"
	RestRepositoryStateINITIALISING         RestRepositoryState = "INITIALISING"
	RestRepositoryStateOFFLINE              RestRepositoryState = "OFFLINE"
)

// Defines values for RestRepositoryHookScopeType.
const (
	RestRepositoryHookScopeTypeGLOBAL     RestRepositoryHookScopeType = "GLOBAL"
	RestRepositoryHookScopeTypePROJECT    RestRepositoryHookScopeType = "PROJECT"
	RestRepositoryHookScopeTypeREPOSITORY RestRepositoryHookScopeType = "REPOSITORY"
)

// Defines values for RestRepositoryMirrorEventType.
const (
	SYNCHRONIZATIONFAILED RestRepositoryMirrorEventType = "SYNCHRONIZATION_FAILED"
	SYNCHRONIZED          RestRepositoryMirrorEventType = "SYNCHRONIZED"
)

// Defines values for RestRepositoryPolicyPermission.
const (
	RestRepositoryPolicyPermissionADMIN        RestRepositoryPolicyPermission = "ADMIN"
	RestRepositoryPolicyPermissionPROJECTADMIN RestRepositoryPolicyPermission = "PROJECT_ADMIN"
	RestRepositoryPolicyPermissionREPOADMIN    RestRepositoryPolicyPermission = "REPO_ADMIN"
	RestRepositoryPolicyPermissionSYSADMIN     RestRepositoryPolicyPermission = "SYS_ADMIN"
)

// Defines values for RestRepositoryRefChangeActivityRefChangeRefType.
const (
	RestRepositoryRefChangeActivityRefChangeRefTypeBRANCH RestRepositoryRefChangeActivityRefChangeRefType = "BRANCH"
	RestRepositoryRefChangeActivityRefChangeRefTypeTAG    RestRepositoryRefChangeActivityRefChangeRefType = "TAG"
)

// Defines values for RestRepositoryRefChangeActivityRefChangeType.
const (
	ADD    RestRepositoryRefChangeActivityRefChangeType = "ADD"
	DELETE RestRepositoryRefChangeActivityRefChangeType = "DELETE"
	UPDATE RestRepositoryRefChangeActivityRefChangeType = "UPDATE"
)

// Defines values for RestRepositoryRefChangeActivityRefChangeUpdatedType.
const (
	RestRepositoryRefChangeActivityRefChangeUpdatedTypeFORCED     RestRepositoryRefChangeActivityRefChangeUpdatedType = "FORCED"
	RestRepositoryRefChangeActivityRefChangeUpdatedTypeNOTFORCED  RestRepositoryRefChangeActivityRefChangeUpdatedType = "NOT_FORCED"
	RestRepositoryRefChangeActivityRefChangeUpdatedTypeUNKNOWN    RestRepositoryRefChangeActivityRefChangeUpdatedType = "UNKNOWN"
	RestRepositoryRefChangeActivityRefChangeUpdatedTypeUNRESOLVED RestRepositoryRefChangeActivityRefChangeUpdatedType = "UNRESOLVED"
)

// Defines values for RestRepositoryRefChangeActivityRepositoryOriginProjectType.
const (
	RestRepositoryRefChangeActivityRepositoryOriginProjectTypeNORMAL   RestRepositoryRefChangeActivityRepositoryOriginProjectType = "NORMAL"
	RestRepositoryRefChangeActivityRepositoryOriginProjectTypePERSONAL RestRepositoryRefChangeActivityRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestRepositoryRefChangeActivityRepositoryOriginState.
const (
	RestRepositoryRefChangeActivityRepositoryOriginStateAVAILABLE            RestRepositoryRefChangeActivityRepositoryOriginState = "AVAILABLE"
	RestRepositoryRefChangeActivityRepositoryOriginStateINITIALISATIONFAILED RestRepositoryRefChangeActivityRepositoryOriginState = "INITIALISATION_FAILED"
	RestRepositoryRefChangeActivityRepositoryOriginStateINITIALISING         RestRepositoryRefChangeActivityRepositoryOriginState = "INITIALISING"
	RestRepositoryRefChangeActivityRepositoryOriginStateOFFLINE              RestRepositoryRefChangeActivityRepositoryOriginState = "OFFLINE"
)

// Defines values for RestRepositoryRefChangeActivityRepositoryProjectType.
const (
	RestRepositoryRefChangeActivityRepositoryProjectTypeNORMAL   RestRepositoryRefChangeActivityRepositoryProjectType = "NORMAL"
	RestRepositoryRefChangeActivityRepositoryProjectTypePERSONAL RestRepositoryRefChangeActivityRepositoryProjectType = "PERSONAL"
)

// Defines values for RestRepositoryRefChangeActivityRepositoryState.
const (
	RestRepositoryRefChangeActivityRepositoryStateAVAILABLE            RestRepositoryRefChangeActivityRepositoryState = "AVAILABLE"
	RestRepositoryRefChangeActivityRepositoryStateINITIALISATIONFAILED RestRepositoryRefChangeActivityRepositoryState = "INITIALISATION_FAILED"
	RestRepositoryRefChangeActivityRepositoryStateINITIALISING         RestRepositoryRefChangeActivityRepositoryState = "INITIALISING"
	RestRepositoryRefChangeActivityRepositoryStateOFFLINE              RestRepositoryRefChangeActivityRepositoryState = "OFFLINE"
)

// Defines values for RestRepositoryRefChangeActivityUserType.
const (
	RestRepositoryRefChangeActivityUserTypeNORMAL  RestRepositoryRefChangeActivityUserType = "NORMAL"
	RestRepositoryRefChangeActivityUserTypeSERVICE RestRepositoryRefChangeActivityUserType = "SERVICE"
)

// Defines values for RestRequiredBuildConditionExemptRefMatcherTypeId.
const (
	RestRequiredBuildConditionExemptRefMatcherTypeIdANYREF        RestRequiredBuildConditionExemptRefMatcherTypeId = "ANY_REF"
	RestRequiredBuildConditionExemptRefMatcherTypeIdBRANCH        RestRequiredBuildConditionExemptRefMatcherTypeId = "BRANCH"
	RestRequiredBuildConditionExemptRefMatcherTypeIdMODELBRANCH   RestRequiredBuildConditionExemptRefMatcherTypeId = "MODEL_BRANCH"
	RestRequiredBuildConditionExemptRefMatcherTypeIdMODELCATEGORY RestRequiredBuildConditionExemptRefMatcherTypeId = "MODEL_CATEGORY"
	RestRequiredBuildConditionExemptRefMatcherTypeIdPATTERN       RestRequiredBuildConditionExemptRefMatcherTypeId = "PATTERN"
)

// Defines values for RestRequiredBuildConditionRefMatcherTypeId.
const (
	RestRequiredBuildConditionRefMatcherTypeIdANYREF        RestRequiredBuildConditionRefMatcherTypeId = "ANY_REF"
	RestRequiredBuildConditionRefMatcherTypeIdBRANCH        RestRequiredBuildConditionRefMatcherTypeId = "BRANCH"
	RestRequiredBuildConditionRefMatcherTypeIdMODELBRANCH   RestRequiredBuildConditionRefMatcherTypeId = "MODEL_BRANCH"
	RestRequiredBuildConditionRefMatcherTypeIdMODELCATEGORY RestRequiredBuildConditionRefMatcherTypeId = "MODEL_CATEGORY"
	RestRequiredBuildConditionRefMatcherTypeIdPATTERN       RestRequiredBuildConditionRefMatcherTypeId = "PATTERN"
)

// Defines values for RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId.
const (
	RestRequiredBuildConditionSetRequestExemptRefMatcherTypeIdANYREF        RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId = "ANY_REF"
	RestRequiredBuildConditionSetRequestExemptRefMatcherTypeIdBRANCH        RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId = "BRANCH"
	RestRequiredBuildConditionSetRequestExemptRefMatcherTypeIdMODELBRANCH   RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId = "MODEL_BRANCH"
	RestRequiredBuildConditionSetRequestExemptRefMatcherTypeIdMODELCATEGORY RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId = "MODEL_CATEGORY"
	RestRequiredBuildConditionSetRequestExemptRefMatcherTypeIdPATTERN       RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId = "PATTERN"
)

// Defines values for RestRestrictionRequestMatcherTypeId.
const (
	RestRestrictionRequestMatcherTypeIdANYREF        RestRestrictionRequestMatcherTypeId = "ANY_REF"
	RestRestrictionRequestMatcherTypeIdBRANCH        RestRestrictionRequestMatcherTypeId = "BRANCH"
	RestRestrictionRequestMatcherTypeIdMODELBRANCH   RestRestrictionRequestMatcherTypeId = "MODEL_BRANCH"
	RestRestrictionRequestMatcherTypeIdMODELCATEGORY RestRestrictionRequestMatcherTypeId = "MODEL_CATEGORY"
	RestRestrictionRequestMatcherTypeIdPATTERN       RestRestrictionRequestMatcherTypeId = "PATTERN"
)

// Defines values for RestRestrictionRequestScopeType.
const (
	RestRestrictionRequestScopeTypeGLOBAL     RestRestrictionRequestScopeType = "GLOBAL"
	RestRestrictionRequestScopeTypePROJECT    RestRestrictionRequestScopeType = "PROJECT"
	RestRestrictionRequestScopeTypeREPOSITORY RestRestrictionRequestScopeType = "REPOSITORY"
)

// Defines values for RestReviewerGroupScopeType.
const (
	RestReviewerGroupScopeTypeGLOBAL     RestReviewerGroupScopeType = "GLOBAL"
	RestReviewerGroupScopeTypePROJECT    RestReviewerGroupScopeType = "PROJECT"
	RestReviewerGroupScopeTypeREPOSITORY RestReviewerGroupScopeType = "REPOSITORY"
)

// Defines values for RestSecretScanningRuleScopeType.
const (
	GLOBAL     RestSecretScanningRuleScopeType = "GLOBAL"
	PROJECT    RestSecretScanningRuleScopeType = "PROJECT"
	REPOSITORY RestSecretScanningRuleScopeType = "REPOSITORY"
)

// Defines values for RestSshAccessKeyPermission.
const (
	RestSshAccessKeyPermissionADMIN         RestSshAccessKeyPermission = "ADMIN"
	RestSshAccessKeyPermissionLICENSEDUSER  RestSshAccessKeyPermission = "LICENSED_USER"
	RestSshAccessKeyPermissionPROJECTADMIN  RestSshAccessKeyPermission = "PROJECT_ADMIN"
	RestSshAccessKeyPermissionPROJECTCREATE RestSshAccessKeyPermission = "PROJECT_CREATE"
	RestSshAccessKeyPermissionPROJECTREAD   RestSshAccessKeyPermission = "PROJECT_READ"
	RestSshAccessKeyPermissionPROJECTVIEW   RestSshAccessKeyPermission = "PROJECT_VIEW"
	RestSshAccessKeyPermissionPROJECTWRITE  RestSshAccessKeyPermission = "PROJECT_WRITE"
	RestSshAccessKeyPermissionREPOADMIN     RestSshAccessKeyPermission = "REPO_ADMIN"
	RestSshAccessKeyPermissionREPOCREATE    RestSshAccessKeyPermission = "REPO_CREATE"
	RestSshAccessKeyPermissionREPOREAD      RestSshAccessKeyPermission = "REPO_READ"
	RestSshAccessKeyPermissionREPOWRITE     RestSshAccessKeyPermission = "REPO_WRITE"
	RestSshAccessKeyPermissionSYSADMIN      RestSshAccessKeyPermission = "SYS_ADMIN"
	RestSshAccessKeyPermissionUSERADMIN     RestSshAccessKeyPermission = "USER_ADMIN"
)

// Defines values for RestSshAccessKeyProjectType.
const (
	RestSshAccessKeyProjectTypeNORMAL   RestSshAccessKeyProjectType = "NORMAL"
	RestSshAccessKeyProjectTypePERSONAL RestSshAccessKeyProjectType = "PERSONAL"
)

// Defines values for RestSshAccessKeyRepositoryOriginProjectType.
const (
	RestSshAccessKeyRepositoryOriginProjectTypeNORMAL   RestSshAccessKeyRepositoryOriginProjectType = "NORMAL"
	RestSshAccessKeyRepositoryOriginProjectTypePERSONAL RestSshAccessKeyRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestSshAccessKeyRepositoryOriginState.
const (
	RestSshAccessKeyRepositoryOriginStateAVAILABLE            RestSshAccessKeyRepositoryOriginState = "AVAILABLE"
	RestSshAccessKeyRepositoryOriginStateINITIALISATIONFAILED RestSshAccessKeyRepositoryOriginState = "INITIALISATION_FAILED"
	RestSshAccessKeyRepositoryOriginStateINITIALISING         RestSshAccessKeyRepositoryOriginState = "INITIALISING"
	RestSshAccessKeyRepositoryOriginStateOFFLINE              RestSshAccessKeyRepositoryOriginState = "OFFLINE"
)

// Defines values for RestSshAccessKeyRepositoryProjectType.
const (
	RestSshAccessKeyRepositoryProjectTypeNORMAL   RestSshAccessKeyRepositoryProjectType = "NORMAL"
	RestSshAccessKeyRepositoryProjectTypePERSONAL RestSshAccessKeyRepositoryProjectType = "PERSONAL"
)

// Defines values for RestSshAccessKeyRepositoryState.
const (
	RestSshAccessKeyRepositoryStateAVAILABLE            RestSshAccessKeyRepositoryState = "AVAILABLE"
	RestSshAccessKeyRepositoryStateINITIALISATIONFAILED RestSshAccessKeyRepositoryState = "INITIALISATION_FAILED"
	RestSshAccessKeyRepositoryStateINITIALISING         RestSshAccessKeyRepositoryState = "INITIALISING"
	RestSshAccessKeyRepositoryStateOFFLINE              RestSshAccessKeyRepositoryState = "OFFLINE"
)

// Defines values for RestTagType.
const (
	RestTagTypeBRANCH RestTagType = "BRANCH"
	RestTagTypeTAG    RestTagType = "TAG"
)

// Defines values for RestUpstreamServerState.
const (
	RestUpstreamServerStateINITIALIZING RestUpstreamServerState = "INITIALIZING"
	RestUpstreamServerStateINSTALLED    RestUpstreamServerState = "INSTALLED"
	RestUpstreamServerStatePENDING      RestUpstreamServerState = "PENDING"
	RestUpstreamServerStateREMOVED      RestUpstreamServerState = "REMOVED"
	RestUpstreamServerStateUNKNOWN      RestUpstreamServerState = "UNKNOWN"
)

// Defines values for RestUpstreamSettingsMode.
const (
	ALLPROJECTS      RestUpstreamSettingsMode = "ALL_PROJECTS"
	SELECTEDPROJECTS RestUpstreamSettingsMode = "SELECTED_PROJECTS"
)

// Defines values for RestUserRateLimitSettingsUserType.
const (
	RestUserRateLimitSettingsUserTypeNORMAL  RestUserRateLimitSettingsUserType = "NORMAL"
	RestUserRateLimitSettingsUserTypeSERVICE RestUserRateLimitSettingsUserType = "SERVICE"
)

// Defines values for RestUserReactionCommentAnchorDiffType.
const (
	RestUserReactionCommentAnchorDiffTypeCOMMIT    RestUserReactionCommentAnchorDiffType = "COMMIT"
	RestUserReactionCommentAnchorDiffTypeEFFECTIVE RestUserReactionCommentAnchorDiffType = "EFFECTIVE"
	RestUserReactionCommentAnchorDiffTypeRANGE     RestUserReactionCommentAnchorDiffType = "RANGE"
)

// Defines values for RestUserReactionCommentAnchorFileType.
const (
	RestUserReactionCommentAnchorFileTypeFROM RestUserReactionCommentAnchorFileType = "FROM"
	RestUserReactionCommentAnchorFileTypeTO   RestUserReactionCommentAnchorFileType = "TO"
)

// Defines values for RestUserReactionCommentAnchorLineType.
const (
	RestUserReactionCommentAnchorLineTypeADDED   RestUserReactionCommentAnchorLineType = "ADDED"
	RestUserReactionCommentAnchorLineTypeCONTEXT RestUserReactionCommentAnchorLineType = "CONTEXT"
	RestUserReactionCommentAnchorLineTypeREMOVED RestUserReactionCommentAnchorLineType = "REMOVED"
)

// Defines values for RestUserReactionCommentAnchorMultilineMarkerStartLineType.
const (
	RestUserReactionCommentAnchorMultilineMarkerStartLineTypeADDED   RestUserReactionCommentAnchorMultilineMarkerStartLineType = "ADDED"
	RestUserReactionCommentAnchorMultilineMarkerStartLineTypeCONTEXT RestUserReactionCommentAnchorMultilineMarkerStartLineType = "CONTEXT"
	RestUserReactionCommentAnchorMultilineMarkerStartLineTypeREMOVED RestUserReactionCommentAnchorMultilineMarkerStartLineType = "REMOVED"
)

// Defines values for RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType.
const (
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState.
const (
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginStateAVAILABLE            RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginStateINITIALISING         RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginStateOFFLINE              RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType.
const (
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectTypeNORMAL   RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectTypePERSONAL RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentAnchorPullRequestFromRefRepositoryState.
const (
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryStateAVAILABLE            RestUserReactionCommentAnchorPullRequestFromRefRepositoryState = "AVAILABLE"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestUserReactionCommentAnchorPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryStateINITIALISING         RestUserReactionCommentAnchorPullRequestFromRefRepositoryState = "INITIALISING"
	RestUserReactionCommentAnchorPullRequestFromRefRepositoryStateOFFLINE              RestUserReactionCommentAnchorPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestUserReactionCommentAnchorPullRequestFromRefType.
const (
	RestUserReactionCommentAnchorPullRequestFromRefTypeBRANCH RestUserReactionCommentAnchorPullRequestFromRefType = "BRANCH"
	RestUserReactionCommentAnchorPullRequestFromRefTypeTAG    RestUserReactionCommentAnchorPullRequestFromRefType = "TAG"
)

// Defines values for RestUserReactionCommentAnchorPullRequestState.
const (
	RestUserReactionCommentAnchorPullRequestStateDECLINED RestUserReactionCommentAnchorPullRequestState = "DECLINED"
	RestUserReactionCommentAnchorPullRequestStateMERGED   RestUserReactionCommentAnchorPullRequestState = "MERGED"
	RestUserReactionCommentAnchorPullRequestStateOPEN     RestUserReactionCommentAnchorPullRequestState = "OPEN"
)

// Defines values for RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType.
const (
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectTypePERSONAL RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState.
const (
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginStateAVAILABLE            RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginStateINITIALISING         RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginStateOFFLINE              RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType.
const (
	RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectTypeNORMAL   RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType = "NORMAL"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectTypePERSONAL RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentAnchorPullRequestToRefRepositoryState.
const (
	RestUserReactionCommentAnchorPullRequestToRefRepositoryStateAVAILABLE            RestUserReactionCommentAnchorPullRequestToRefRepositoryState = "AVAILABLE"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryStateINITIALISATIONFAILED RestUserReactionCommentAnchorPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryStateINITIALISING         RestUserReactionCommentAnchorPullRequestToRefRepositoryState = "INITIALISING"
	RestUserReactionCommentAnchorPullRequestToRefRepositoryStateOFFLINE              RestUserReactionCommentAnchorPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestUserReactionCommentAnchorPullRequestToRefType.
const (
	RestUserReactionCommentAnchorPullRequestToRefTypeBRANCH RestUserReactionCommentAnchorPullRequestToRefType = "BRANCH"
	RestUserReactionCommentAnchorPullRequestToRefTypeTAG    RestUserReactionCommentAnchorPullRequestToRefType = "TAG"
)

// Defines values for RestUserReactionCommentAuthorType.
const (
	RestUserReactionCommentAuthorTypeNORMAL  RestUserReactionCommentAuthorType = "NORMAL"
	RestUserReactionCommentAuthorTypeSERVICE RestUserReactionCommentAuthorType = "SERVICE"
)

// Defines values for RestUserReactionCommentParentAnchorDiffType.
const (
	COMMIT    RestUserReactionCommentParentAnchorDiffType = "COMMIT"
	EFFECTIVE RestUserReactionCommentParentAnchorDiffType = "EFFECTIVE"
	RANGE     RestUserReactionCommentParentAnchorDiffType = "RANGE"
)

// Defines values for RestUserReactionCommentParentAnchorFileType.
const (
	FROM RestUserReactionCommentParentAnchorFileType = "FROM"
	TO   RestUserReactionCommentParentAnchorFileType = "TO"
)

// Defines values for RestUserReactionCommentParentAnchorLineType.
const (
	RestUserReactionCommentParentAnchorLineTypeADDED   RestUserReactionCommentParentAnchorLineType = "ADDED"
	RestUserReactionCommentParentAnchorLineTypeCONTEXT RestUserReactionCommentParentAnchorLineType = "CONTEXT"
	RestUserReactionCommentParentAnchorLineTypeREMOVED RestUserReactionCommentParentAnchorLineType = "REMOVED"
)

// Defines values for RestUserReactionCommentParentAnchorMultilineMarkerStartLineType.
const (
	RestUserReactionCommentParentAnchorMultilineMarkerStartLineTypeADDED   RestUserReactionCommentParentAnchorMultilineMarkerStartLineType = "ADDED"
	RestUserReactionCommentParentAnchorMultilineMarkerStartLineTypeCONTEXT RestUserReactionCommentParentAnchorMultilineMarkerStartLineType = "CONTEXT"
	RestUserReactionCommentParentAnchorMultilineMarkerStartLineTypeREMOVED RestUserReactionCommentParentAnchorMultilineMarkerStartLineType = "REMOVED"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType.
const (
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectTypeNORMAL   RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType = "NORMAL"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectTypePERSONAL RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState.
const (
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginStateAVAILABLE            RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState = "AVAILABLE"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginStateINITIALISATIONFAILED RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginStateINITIALISING         RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState = "INITIALISING"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginStateOFFLINE              RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType.
const (
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectTypeNORMAL   RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType = "NORMAL"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectTypePERSONAL RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState.
const (
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryStateAVAILABLE            RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState = "AVAILABLE"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryStateINITIALISATIONFAILED RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState = "INITIALISATION_FAILED"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryStateINITIALISING         RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState = "INITIALISING"
	RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryStateOFFLINE              RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState = "OFFLINE"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestFromRefType.
const (
	RestUserReactionCommentParentAnchorPullRequestFromRefTypeBRANCH RestUserReactionCommentParentAnchorPullRequestFromRefType = "BRANCH"
	RestUserReactionCommentParentAnchorPullRequestFromRefTypeTAG    RestUserReactionCommentParentAnchorPullRequestFromRefType = "TAG"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestState.
const (
	DECLINED RestUserReactionCommentParentAnchorPullRequestState = "DECLINED"
	MERGED   RestUserReactionCommentParentAnchorPullRequestState = "MERGED"
	OPEN     RestUserReactionCommentParentAnchorPullRequestState = "OPEN"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType.
const (
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectTypeNORMAL   RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType = "NORMAL"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectTypePERSONAL RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState.
const (
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginStateAVAILABLE            RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState = "AVAILABLE"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginStateINITIALISATIONFAILED RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState = "INITIALISATION_FAILED"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginStateINITIALISING         RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState = "INITIALISING"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginStateOFFLINE              RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState = "OFFLINE"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType.
const (
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectTypeNORMAL   RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType = "NORMAL"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectTypePERSONAL RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType = "PERSONAL"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState.
const (
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryStateAVAILABLE            RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState = "AVAILABLE"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryStateINITIALISATIONFAILED RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState = "INITIALISATION_FAILED"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryStateINITIALISING         RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState = "INITIALISING"
	RestUserReactionCommentParentAnchorPullRequestToRefRepositoryStateOFFLINE              RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState = "OFFLINE"
)

// Defines values for RestUserReactionCommentParentAnchorPullRequestToRefType.
const (
	RestUserReactionCommentParentAnchorPullRequestToRefTypeBRANCH RestUserReactionCommentParentAnchorPullRequestToRefType = "BRANCH"
	RestUserReactionCommentParentAnchorPullRequestToRefTypeTAG    RestUserReactionCommentParentAnchorPullRequestToRefType = "TAG"
)

// Defines values for RestUserReactionCommentParentAuthorType.
const (
	RestUserReactionCommentParentAuthorTypeNORMAL  RestUserReactionCommentParentAuthorType = "NORMAL"
	RestUserReactionCommentParentAuthorTypeSERVICE RestUserReactionCommentParentAuthorType = "SERVICE"
)

// Defines values for RestUserReactionCommentParentResolverType.
const (
	RestUserReactionCommentParentResolverTypeNORMAL  RestUserReactionCommentParentResolverType = "NORMAL"
	RestUserReactionCommentParentResolverTypeSERVICE RestUserReactionCommentParentResolverType = "SERVICE"
)

// Defines values for RestUserReactionCommentParentThreadResolverType.
const (
	RestUserReactionCommentParentThreadResolverTypeNORMAL  RestUserReactionCommentParentThreadResolverType = "NORMAL"
	RestUserReactionCommentParentThreadResolverTypeSERVICE RestUserReactionCommentParentThreadResolverType = "SERVICE"
)

// Defines values for RestUserReactionCommentResolverType.
const (
	RestUserReactionCommentResolverTypeNORMAL  RestUserReactionCommentResolverType = "NORMAL"
	RestUserReactionCommentResolverTypeSERVICE RestUserReactionCommentResolverType = "SERVICE"
)

// Defines values for RestUserReactionCommentThreadResolverType.
const (
	RestUserReactionCommentThreadResolverTypeNORMAL  RestUserReactionCommentThreadResolverType = "NORMAL"
	RestUserReactionCommentThreadResolverTypeSERVICE RestUserReactionCommentThreadResolverType = "SERVICE"
)

// Defines values for RestUserReactionUserType.
const (
	RestUserReactionUserTypeNORMAL  RestUserReactionUserType = "NORMAL"
	RestUserReactionUserTypeSERVICE RestUserReactionUserType = "SERVICE"
)

// Defines values for SetBannerJSONBodyAudience.
const (
	SetBannerJSONBodyAudienceALL           SetBannerJSONBodyAudience = "ALL"
	SetBannerJSONBodyAudienceAUTHENTICATED SetBannerJSONBodyAudience = "AUTHENTICATED"
)

// Defines values for SetMailConfigJSONBodyProtocol.
const (
	SetMailConfigJSONBodyProtocolSMTP  SetMailConfigJSONBodyProtocol = "SMTP"
	SetMailConfigJSONBodyProtocolSMTPS SetMailConfigJSONBodyProtocol = "SMTPS"
)

// Defines values for SetPermissionForGroupsParamsPermission.
const (
	SetPermissionForGroupsParamsPermissionADMIN         SetPermissionForGroupsParamsPermission = "ADMIN"
	SetPermissionForGroupsParamsPermissionLICENSEDUSER  SetPermissionForGroupsParamsPermission = "LICENSED_USER"
	SetPermissionForGroupsParamsPermissionPROJECTCREATE SetPermissionForGroupsParamsPermission = "PROJECT_CREATE"
	SetPermissionForGroupsParamsPermissionSYSADMIN      SetPermissionForGroupsParamsPermission = "SYS_ADMIN"
)

// Defines values for SetPermissionForUsersParamsPermission.
const (
	ADMIN         SetPermissionForUsersParamsPermission = "ADMIN"
	LICENSEDUSER  SetPermissionForUsersParamsPermission = "LICENSED_USER"
	PROJECTCREATE SetPermissionForUsersParamsPermission = "PROJECT_CREATE"
	SYSADMIN      SetPermissionForUsersParamsPermission = "SYS_ADMIN"
)

// Defines values for GetHistoryParamsOrder.
const (
	FREQUENCY GetHistoryParamsOrder = "FREQUENCY"
	NEWEST    GetHistoryParamsOrder = "NEWEST"
)

// Defines values for GetBranchesParamsOrderBy.
const (
	ALPHABETICAL GetBranchesParamsOrderBy = "ALPHABETICAL"
	MODIFICATION GetBranchesParamsOrderBy = "MODIFICATION"
)

// Defines values for SetPermissionForGroupParamsPermission.
const (
	SetPermissionForGroupParamsPermissionREPOADMIN SetPermissionForGroupParamsPermission = "REPO_ADMIN"
	SetPermissionForGroupParamsPermissionREPOREAD  SetPermissionForGroupParamsPermission = "REPO_READ"
	SetPermissionForGroupParamsPermissionREPOWRITE SetPermissionForGroupParamsPermission = "REPO_WRITE"
)

// Defines values for SetPermissionForUserParamsPermission.
const (
	SetPermissionForUserParamsPermissionREPOADMIN SetPermissionForUserParamsPermission = "REPO_ADMIN"
	SetPermissionForUserParamsPermissionREPOREAD  SetPermissionForUserParamsPermission = "REPO_READ"
	SetPermissionForUserParamsPermissionREPOWRITE SetPermissionForUserParamsPermission = "REPO_WRITE"
)

// Defines values for Search2ParamsOrder.
const (
	Search2ParamsOrderNAMEASC  Search2ParamsOrder = "NAME_ASC"
	Search2ParamsOrderNAMEDESC Search2ParamsOrder = "NAME_DESC"
)

// Defines values for Search3ParamsOrder.
const (
	Search3ParamsOrderNAMEASC  Search3ParamsOrder = "NAME_ASC"
	Search3ParamsOrderNAMEDESC Search3ParamsOrder = "NAME_DESC"
)

// Defines values for GetRepositoryHooks1ParamsType.
const (
	GetRepositoryHooks1ParamsTypePOSTRECEIVE GetRepositoryHooks1ParamsType = "POST_RECEIVE"
	GetRepositoryHooks1ParamsTypePRERECEIVE  GetRepositoryHooks1ParamsType = "PRE_RECEIVE"
)

// Defines values for SearchAllowlistRuleParamsOrder.
const (
	SearchAllowlistRuleParamsOrderNAMEASC  SearchAllowlistRuleParamsOrder = "NAME_ASC"
	SearchAllowlistRuleParamsOrderNAMEDESC SearchAllowlistRuleParamsOrder = "NAME_DESC"
)

// Defines values for Search1ParamsOrder.
const (
	Search1ParamsOrderNAMEASC  Search1ParamsOrder = "NAME_ASC"
	Search1ParamsOrderNAMEDESC Search1ParamsOrder = "NAME_DESC"
)

// Defines values for GetRepositoryHooksParamsType.
const (
	POSTRECEIVE GetRepositoryHooksParamsType = "POST_RECEIVE"
	PRERECEIVE  GetRepositoryHooksParamsType = "PRE_RECEIVE"
)

// Defines values for GetRepositories1ParamsVisibility.
const (
	Private GetRepositories1ParamsVisibility = "private"
	Public  GetRepositories1ParamsVisibility = "public"
)

// Defines values for GetRepositories1ParamsPermission.
const (
	REPOADMIN GetRepositories1ParamsPermission = "REPO_ADMIN"
	REPOREAD  GetRepositories1ParamsPermission = "REPO_READ"
	REPOWRITE GetRepositories1ParamsPermission = "REPO_WRITE"
)

// Defines values for GetRepositories1ParamsState.
const (
	AVAILABLE            GetRepositories1ParamsState = "AVAILABLE"
	INITIALISATIONFAILED GetRepositories1ParamsState = "INITIALISATION_FAILED"
	INITIALISING         GetRepositories1ParamsState = "INITIALISING"
	OFFLINE              GetRepositories1ParamsState = "OFFLINE"
)

// Defines values for FindExemptReposByScopeParamsOrder.
const (
	FindExemptReposByScopeParamsOrderNAMEASC  FindExemptReposByScopeParamsOrder = "NAME_ASC"
	FindExemptReposByScopeParamsOrderNAMEDESC FindExemptReposByScopeParamsOrder = "NAME_DESC"
)

// Defines values for Search4ParamsOrder.
const (
	Search4ParamsOrderNAMEASC  Search4ParamsOrder = "NAME_ASC"
	Search4ParamsOrderNAMEDESC Search4ParamsOrder = "NAME_DESC"
)

// Defines values for GetRestrictions1ParamsMatcherType.
const (
	GetRestrictions1ParamsMatcherTypeBRANCH        GetRestrictions1ParamsMatcherType = "BRANCH"
	GetRestrictions1ParamsMatcherTypeMODELBRANCH   GetRestrictions1ParamsMatcherType = "MODEL_BRANCH"
	GetRestrictions1ParamsMatcherTypeMODELCATEGORY GetRestrictions1ParamsMatcherType = "MODEL_CATEGORY"
	GetRestrictions1ParamsMatcherTypePATTERN       GetRestrictions1ParamsMatcherType = "PATTERN"
)

// Defines values for GetRestrictions1ParamsType.
const (
	GetRestrictions1ParamsTypeFastForwardOnly GetRestrictions1ParamsType = "fast-forward-only"
	GetRestrictions1ParamsTypeNoDeletes       GetRestrictions1ParamsType = "no-deletes"
	GetRestrictions1ParamsTypePullRequestOnly GetRestrictions1ParamsType = "pull-request-only"
	GetRestrictions1ParamsTypeReadOnly        GetRestrictions1ParamsType = "read-only"
)

// Defines values for GetRestrictionsParamsMatcherType.
const (
	GetRestrictionsParamsMatcherTypeBRANCH        GetRestrictionsParamsMatcherType = "BRANCH"
	GetRestrictionsParamsMatcherTypeMODELBRANCH   GetRestrictionsParamsMatcherType = "MODEL_BRANCH"
	GetRestrictionsParamsMatcherTypeMODELCATEGORY GetRestrictionsParamsMatcherType = "MODEL_CATEGORY"
	GetRestrictionsParamsMatcherTypePATTERN       GetRestrictionsParamsMatcherType = "PATTERN"
)

// Defines values for GetRestrictionsParamsType.
const (
	GetRestrictionsParamsTypeFastForwardOnly GetRestrictionsParamsType = "fast-forward-only"
	GetRestrictionsParamsTypeNoDeletes       GetRestrictionsParamsType = "no-deletes"
	GetRestrictionsParamsTypePullRequestOnly GetRestrictionsParamsType = "pull-request-only"
	GetRestrictionsParamsTypeReadOnly        GetRestrictionsParamsType = "read-only"
)

// Defines values for UpdatePullRequestCondition1JSONBodySourceMatcherTypeId.
const (
	UpdatePullRequestCondition1JSONBodySourceMatcherTypeIdANYREF        UpdatePullRequestCondition1JSONBodySourceMatcherTypeId = "ANY_REF"
	UpdatePullRequestCondition1JSONBodySourceMatcherTypeIdBRANCH        UpdatePullRequestCondition1JSONBodySourceMatcherTypeId = "BRANCH"
	UpdatePullRequestCondition1JSONBodySourceMatcherTypeIdMODELBRANCH   UpdatePullRequestCondition1JSONBodySourceMatcherTypeId = "MODEL_BRANCH"
	UpdatePullRequestCondition1JSONBodySourceMatcherTypeIdMODELCATEGORY UpdatePullRequestCondition1JSONBodySourceMatcherTypeId = "MODEL_CATEGORY"
	UpdatePullRequestCondition1JSONBodySourceMatcherTypeIdPATTERN       UpdatePullRequestCondition1JSONBodySourceMatcherTypeId = "PATTERN"
)

// Defines values for UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId.
const (
	ANYREF        UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId = "ANY_REF"
	BRANCH        UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId = "BRANCH"
	MODELBRANCH   UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId = "MODEL_BRANCH"
	MODELCATEGORY UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId = "MODEL_CATEGORY"
	PATTERN       UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId = "PATTERN"
)

// Defines values for GetAllReposForProjectParamsIncludeDefaultBranch.
const (
	GetAllReposForProjectParamsIncludeDefaultBranchFalse GetAllReposForProjectParamsIncludeDefaultBranch = "false"
	GetAllReposForProjectParamsIncludeDefaultBranchTrue  GetAllReposForProjectParamsIncludeDefaultBranch = "true"
)

// Defines values for GetAllContentHashesParamsIncludeDefaultBranch.
const (
	GetAllContentHashesParamsIncludeDefaultBranchFalse GetAllContentHashesParamsIncludeDefaultBranch = "false"
	GetAllContentHashesParamsIncludeDefaultBranchTrue  GetAllContentHashesParamsIncludeDefaultBranch = "true"
)

// Defines values for ListRequestsParamsState.
const (
	ListRequestsParamsStateACCEPTED ListRequestsParamsState = "ACCEPTED"
	ListRequestsParamsStatePENDING  ListRequestsParamsState = "PENDING"
	ListRequestsParamsStateREJECTED ListRequestsParamsState = "REJECTED"
)

// AdminPasswordUpdate defines model for AdminPasswordUpdate.
type AdminPasswordUpdate struct {
	Name            *string `json:"name,omitempty"`
	Password        *string `json:"password,omitempty"`
	PasswordConfirm *string `json:"passwordConfirm,omitempty"`
}

// ApplicationUser defines model for ApplicationUser.
type ApplicationUser struct {
	Active       *bool                `json:"active,omitempty"`
	DisplayName  *string              `json:"displayName,omitempty"`
	EmailAddress *string              `json:"emailAddress,omitempty"`
	Id           *int32               `json:"id,omitempty"`
	Name         *string              `json:"name,omitempty"`
	Slug         *string              `json:"slug,omitempty"`
	Type         *ApplicationUserType `json:"type,omitempty"`
}

// ApplicationUserType defines model for ApplicationUser.Type.
type ApplicationUserType string

// Comment defines model for Comment.
type Comment struct {
	Anchor              *CommentThreadDiffAnchor `json:"anchor,omitempty"`
	Author              *ApplicationUser         `json:"author,omitempty"`
	Comments            *[]Comment               `json:"comments,omitempty"`
	CreatedDate         *time.Time               `json:"createdDate,omitempty"`
	Id                  *int64                   `json:"id,omitempty"`
	PermittedOperations *CommentOperations       `json:"permittedOperations,omitempty"`
	Properties          *map[string]interface{}  `json:"properties,omitempty"`
	ResolvedDate        *time.Time               `json:"resolvedDate,omitempty"`
	Resolver            *ApplicationUser         `json:"resolver,omitempty"`
	Severity            *CommentSeverity         `json:"severity,omitempty"`
	State               *CommentState            `json:"state,omitempty"`
	Text                *string                  `json:"text,omitempty"`
	Thread              *CommentThread           `json:"thread,omitempty"`
	UpdatedDate         *time.Time               `json:"updatedDate,omitempty"`
	Version             *int32                   `json:"version,omitempty"`
}

// CommentSeverity defines model for Comment.Severity.
type CommentSeverity string

// CommentState defines model for Comment.State.
type CommentState string

// CommentOperations defines model for CommentOperations.
type CommentOperations struct {
	Deletable      *bool `json:"deletable,omitempty"`
	Editable       *bool `json:"editable,omitempty"`
	Transitionable *bool `json:"transitionable,omitempty"`
}

// CommentThread defines model for CommentThread.
type CommentThread struct {
	Anchor       *CommentThreadDiffAnchor `json:"anchor,omitempty"`
	Anchored     *bool                    `json:"anchored,omitempty"`
	Commentable  *Commentable             `json:"commentable,omitempty"`
	CreatedDate  *time.Time               `json:"createdDate,omitempty"`
	Id           *int64                   `json:"id,omitempty"`
	Resolved     *bool                    `json:"resolved,omitempty"`
	ResolvedDate *time.Time               `json:"resolvedDate,omitempty"`
	Resolver     *ApplicationUser         `json:"resolver,omitempty"`
	RootComment  *Comment                 `json:"rootComment,omitempty"`
	UpdatedDate  *time.Time               `json:"updatedDate,omitempty"`
}

// CommentThreadDiffAnchor defines model for CommentThreadDiffAnchor.
type CommentThreadDiffAnchor struct {
	DiffType                  *CommentThreadDiffAnchorDiffType               `json:"diffType,omitempty"`
	FileAnchor                *bool                                          `json:"fileAnchor,omitempty"`
	FileType                  *CommentThreadDiffAnchorFileType               `json:"fileType,omitempty"`
	FromHash                  *string                                        `json:"fromHash,omitempty"`
	Line                      *int32                                         `json:"line,omitempty"`
	LineAnchor                *bool                                          `json:"lineAnchor,omitempty"`
	LineType                  *CommentThreadDiffAnchorLineType               `json:"lineType,omitempty"`
	MultilineAnchor           *bool                                          `json:"multilineAnchor,omitempty"`
	MultilineDestinationRange *LineNumberRange                               `json:"multilineDestinationRange,omitempty"`
	MultilineSourceRange      *LineNumberRange                               `json:"multilineSourceRange,omitempty"`
	MultilineStartLine        *int32                                         `json:"multilineStartLine,omitempty"`
	MultilineStartLineType    *CommentThreadDiffAnchorMultilineStartLineType `json:"multilineStartLineType,omitempty"`
	Orphaned                  *bool                                          `json:"orphaned,omitempty"`
	Path                      *string                                        `json:"path,omitempty"`
	SrcPath                   *string                                        `json:"srcPath,omitempty"`
	ToHash                    *string                                        `json:"toHash,omitempty"`
}

// CommentThreadDiffAnchorDiffType defines model for CommentThreadDiffAnchor.DiffType.
type CommentThreadDiffAnchorDiffType string

// CommentThreadDiffAnchorFileType defines model for CommentThreadDiffAnchor.FileType.
type CommentThreadDiffAnchorFileType string

// CommentThreadDiffAnchorLineType defines model for CommentThreadDiffAnchor.LineType.
type CommentThreadDiffAnchorLineType string

// CommentThreadDiffAnchorMultilineStartLineType defines model for CommentThreadDiffAnchor.MultilineStartLineType.
type CommentThreadDiffAnchorMultilineStartLineType string

// Commentable defines model for Commentable.
type Commentable = map[string]interface{}

// Context defines model for Context.
type Context struct {
	CommitMessage *string `json:"commitMessage,omitempty"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	union json.RawMessage
}

// EnrichedRepository defines model for EnrichedRepository.
type EnrichedRepository struct {
	Archived      *bool                   `json:"archived,omitempty"`
	DefaultBranch *string                 `json:"defaultBranch,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	Forkable      *bool                   `json:"forkable,omitempty"`
	HierarchyId   *string                 `json:"hierarchyId,omitempty"`
	Id            *int32                  `json:"id,omitempty"`
	Links         *map[string]interface{} `json:"links,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Origin        *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Partition     *int32                  `json:"partition,omitempty"`
		Project       *struct {
			Avatar      *string                              `json:"avatar,omitempty"`
			AvatarUrl   *string                              `json:"avatarUrl,omitempty"`
			Description *string                              `json:"description,omitempty"`
			Id          *int32                               `json:"id,omitempty"`
			Key         string                               `json:"key"`
			Links       *map[string]interface{}              `json:"links,omitempty"`
			Name        *string                              `json:"name,omitempty"`
			Public      *bool                                `json:"public,omitempty"`
			Scope       *string                              `json:"scope,omitempty"`
			Type        *EnrichedRepositoryOriginProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                          `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}        `json:"relatedLinks,omitempty"`
		ScmId         *string                        `json:"scmId,omitempty"`
		Scope         *string                        `json:"scope,omitempty"`
		Slug          *string                        `json:"slug,omitempty"`
		State         *EnrichedRepositoryOriginState `json:"state,omitempty"`
		StatusMessage *string                        `json:"statusMessage,omitempty"`
	} `json:"origin,omitempty"`
	Partition *int32 `json:"partition,omitempty"`
	Project   *struct {
		Avatar      *string                        `json:"avatar,omitempty"`
		AvatarUrl   *string                        `json:"avatarUrl,omitempty"`
		Description *string                        `json:"description,omitempty"`
		Id          *int32                         `json:"id,omitempty"`
		Key         string                         `json:"key"`
		Links       *map[string]interface{}        `json:"links,omitempty"`
		Name        *string                        `json:"name,omitempty"`
		Public      *bool                          `json:"public,omitempty"`
		Scope       *string                        `json:"scope,omitempty"`
		Type        *EnrichedRepositoryProjectType `json:"type,omitempty"`
	} `json:"project,omitempty"`
	Properties *struct {
		ContentHash     *string `json:"contentHash,omitempty"`
		DefaultBranchId *string `json:"defaultBranchId,omitempty"`
		MetadataHash    *string `json:"metadataHash,omitempty"`
	} `json:"properties,omitempty"`
	Public        *bool                    `json:"public,omitempty"`
	RelatedLinks  *map[string]interface{}  `json:"relatedLinks,omitempty"`
	ScmId         *string                  `json:"scmId,omitempty"`
	Scope         *string                  `json:"scope,omitempty"`
	Slug          *string                  `json:"slug,omitempty"`
	State         *EnrichedRepositoryState `json:"state,omitempty"`
	StatusMessage *string                  `json:"statusMessage,omitempty"`
}

// EnrichedRepositoryOriginProjectType defines model for EnrichedRepository.Origin.Project.Type.
type EnrichedRepositoryOriginProjectType string

// EnrichedRepositoryOriginState defines model for EnrichedRepository.Origin.State.
type EnrichedRepositoryOriginState string

// EnrichedRepositoryProjectType defines model for EnrichedRepository.Project.Type.
type EnrichedRepositoryProjectType string

// EnrichedRepositoryState defines model for EnrichedRepository.State.
type EnrichedRepositoryState string

// ExampleAvatarMultipartFormData defines model for ExampleAvatarMultipartFormData.
type ExampleAvatarMultipartFormData struct {
	// Avatar The avatar file to upload.
	Avatar *openapi_types.File `json:"avatar,omitempty"`
}

// ExampleCertificateMultipartFormData defines model for ExampleCertificateMultipartFormData.
type ExampleCertificateMultipartFormData struct {
	// Certificate The X.509 certificate file to upload.
	Certificate *openapi_types.File `json:"certificate,omitempty"`
}

// ExampleFiles defines model for ExampleFiles.
type ExampleFiles struct {
	Files *ExampleJsonLastModifiedCallback `json:"files,omitempty"`
}

// ExampleJsonLastModifiedCallback defines model for ExampleJsonLastModifiedCallback.
type ExampleJsonLastModifiedCallback struct {
	LatestCommit *struct {
		Author *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"author,omitempty"`
		AuthorTimestamp *int64 `json:"authorTimestamp,omitempty"`
		Committer       *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"committer,omitempty"`
		CommitterTimestamp *int64               `json:"committerTimestamp,omitempty"`
		DisplayId          *string              `json:"displayId,omitempty"`
		Id                 *string              `json:"id,omitempty"`
		Message            *string              `json:"message,omitempty"`
		Parents            *[]RestMinimalCommit `json:"parents,omitempty"`
	} `json:"latestCommit,omitempty"`
	PomXml *struct {
		Author *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"author,omitempty"`
		AuthorTimestamp *int64 `json:"authorTimestamp,omitempty"`
		Committer       *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"committer,omitempty"`
		CommitterTimestamp *int64               `json:"committerTimestamp,omitempty"`
		DisplayId          *string              `json:"displayId,omitempty"`
		Id                 *string              `json:"id,omitempty"`
		Message            *string              `json:"message,omitempty"`
		Parents            *[]RestMinimalCommit `json:"parents,omitempty"`
	} `json:"pomXml,omitempty"`
	ReadmeMd *struct {
		Author *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"author,omitempty"`
		AuthorTimestamp *int64 `json:"authorTimestamp,omitempty"`
		Committer       *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"committer,omitempty"`
		CommitterTimestamp *int64               `json:"committerTimestamp,omitempty"`
		DisplayId          *string              `json:"displayId,omitempty"`
		Id                 *string              `json:"id,omitempty"`
		Message            *string              `json:"message,omitempty"`
		Parents            *[]RestMinimalCommit `json:"parents,omitempty"`
	} `json:"readmeMd,omitempty"`
}

// ExampleMultipartFormData defines model for ExampleMultipartFormData.
type ExampleMultipartFormData struct {
	// Branch The branch on which the <code>path</code> should be modified or created.
	Branch *string `json:"branch,omitempty"`

	// Content The full content of the file at <code>path</code>.
	Content *string `json:"content,omitempty"`

	// Message The message associated with this change, to be used as the commit message. Or null if the default message should be used.
	Message *string `json:"message,omitempty"`

	// SourceBranch The starting point for <code>branch</code>. If provided and different from <code>branch</code>, <code>branch</code> will be created as a new branch, branching off from <code>sourceBranch</code>.
	SourceBranch *string `json:"sourceBranch,omitempty"`

	// SourceCommitId The commit ID of the file before it was edited, used to identify if content has changed. Or null if this is a new file
	SourceCommitId *string `json:"sourceCommitId,omitempty"`
}

// ExamplePostMultipartFormData defines model for ExamplePostMultipartFormData.
type ExamplePostMultipartFormData struct {
	// Content The hook script contents.
	Content *string `json:"content,omitempty"`

	// Description A description of the hook script (useful when querying registered hook scripts).
	Description *string `json:"description,omitempty"`

	// Name The name of the hook script (useful when querying registered hook scripts).
	Name *string `json:"name,omitempty"`

	// Type The type of hook script; supported values are "PRE" for pre-receive hooks and "POST" for post-receive hooks.
	Type *string `json:"type,omitempty"`
}

// ExamplePreviewMigration defines model for ExamplePreviewMigration.
type ExamplePreviewMigration struct {
	Repositories *[]RestRepository `json:"repositories,omitempty"`
}

// ExamplePutMultipartFormData defines model for ExamplePutMultipartFormData.
type ExamplePutMultipartFormData struct {
	// Content The hook script contents.
	Content *string `json:"content,omitempty"`

	// Description A description of the hook script (useful when querying registered hook scripts).
	Description *string `json:"description,omitempty"`

	// Name The name of the hook script (useful when querying registered hook scripts).
	Name *string `json:"name,omitempty"`
}

// ExampleSettings defines model for ExampleSettings.
type ExampleSettings struct {
	BooleanValue *bool    `json:"booleanValue,omitempty"`
	DoubleValue  *float64 `json:"doubleValue,omitempty"`
	IntegerValue *int32   `json:"integerValue,omitempty"`
	LongValue    *int64   `json:"longValue,omitempty"`
	StringValue  *string  `json:"stringValue,omitempty"`
}

// ExampleSettingsMap defines model for ExampleSettingsMap.
type ExampleSettingsMap struct {
	BooleanKey *bool    `json:"boolean key,omitempty"`
	LongKey    *float32 `json:"long key,omitempty"`
	StringKey  *string  `json:"string key,omitempty"`
}

// FileListResource defines model for FileListResource.
type FileListResource = interface{}

// GroupAndUsers defines model for GroupAndUsers.
type GroupAndUsers struct {
	Group *string  `json:"group,omitempty"`
	Users []string `json:"users"`
}

// GroupPickerContext defines model for GroupPickerContext.
type GroupPickerContext struct {
	Context  *string `json:"context,omitempty"`
	ItemName *string `json:"itemName,omitempty"`
}

// LineNumberRange defines model for LineNumberRange.
type LineNumberRange struct {
	Maximum    *int32 `json:"maximum,omitempty"`
	Minimum    *int32 `json:"minimum,omitempty"`
	SingleLine *bool  `json:"singleLine,omitempty"`
}

// Project defines model for Project.
type Project struct {
	Description *string      `json:"description,omitempty"`
	Id          *int32       `json:"id,omitempty"`
	Key         *string      `json:"key,omitempty"`
	Name        *string      `json:"name,omitempty"`
	Public      *bool        `json:"public,omitempty"`
	Type        *ProjectType `json:"type,omitempty"`
}

// ProjectType defines model for Project.Type.
type ProjectType string

// PullRequest defines model for PullRequest.
type PullRequest struct {
	Author          *PullRequestParticipant   `json:"author,omitempty"`
	Closed          *bool                     `json:"closed,omitempty"`
	ClosedDate      *time.Time                `json:"closedDate,omitempty"`
	CreatedDate     *time.Time                `json:"createdDate,omitempty"`
	CrossRepository *bool                     `json:"crossRepository,omitempty"`
	Description     *string                   `json:"description,omitempty"`
	Draft           *bool                     `json:"draft,omitempty"`
	FromRef         *PullRequestRef           `json:"fromRef,omitempty"`
	Id              *int64                    `json:"id,omitempty"`
	Locked          *bool                     `json:"locked,omitempty"`
	Open            *bool                     `json:"open,omitempty"`
	Participants    *[]PullRequestParticipant `json:"participants,omitempty"`
	Properties      *map[string]interface{}   `json:"properties,omitempty"`
	Reviewers       *[]PullRequestParticipant `json:"reviewers,omitempty"`
	State           *PullRequestState         `json:"state,omitempty"`
	Title           *string                   `json:"title,omitempty"`
	ToRef           *PullRequestRef           `json:"toRef,omitempty"`
	UpdatedDate     *time.Time                `json:"updatedDate,omitempty"`
	Version         *int32                    `json:"version,omitempty"`
}

// PullRequestState defines model for PullRequest.State.
type PullRequestState string

// PullRequestParticipant defines model for PullRequestParticipant.
type PullRequestParticipant struct {
	Approved           *bool                         `json:"approved,omitempty"`
	LastReviewedCommit *string                       `json:"lastReviewedCommit,omitempty"`
	PullRequest        *PullRequest                  `json:"pullRequest,omitempty"`
	Role               *PullRequestParticipantRole   `json:"role,omitempty"`
	Status             *PullRequestParticipantStatus `json:"status,omitempty"`
	User               *ApplicationUser              `json:"user,omitempty"`
}

// PullRequestParticipantRole defines model for PullRequestParticipant.Role.
type PullRequestParticipantRole string

// PullRequestParticipantStatus defines model for PullRequestParticipant.Status.
type PullRequestParticipantStatus string

// PullRequestRef defines model for PullRequestRef.
type PullRequestRef struct {
	DisplayId    *string     `json:"displayId,omitempty"`
	Id           *string     `json:"id,omitempty"`
	LatestCommit *string     `json:"latestCommit,omitempty"`
	Repository   *Repository `json:"repository,omitempty"`
	Type         *RefType    `json:"type,omitempty"`
}

// RefType defines model for RefType.
type RefType = interface{}

// Repository defines model for Repository.
type Repository struct {
	Archived      *bool            `json:"archived,omitempty"`
	Description   *string          `json:"description,omitempty"`
	Fork          *bool            `json:"fork,omitempty"`
	Forkable      *bool            `json:"forkable,omitempty"`
	HierarchyId   *string          `json:"hierarchyId,omitempty"`
	Id            *int32           `json:"id,omitempty"`
	Local         *bool            `json:"local,omitempty"`
	Name          *string          `json:"name,omitempty"`
	Offline       *bool            `json:"offline,omitempty"`
	Origin        *Repository      `json:"origin,omitempty"`
	Partition     *int32           `json:"partition,omitempty"`
	Project       *Project         `json:"project,omitempty"`
	Public        *bool            `json:"public,omitempty"`
	ReadOnly      *bool            `json:"readOnly,omitempty"`
	Remote        *bool            `json:"remote,omitempty"`
	ScmId         *string          `json:"scmId,omitempty"`
	Slug          *string          `json:"slug,omitempty"`
	State         *RepositoryState `json:"state,omitempty"`
	StatusMessage *string          `json:"statusMessage,omitempty"`
}

// RepositoryState defines model for Repository.State.
type RepositoryState string

// RepositoryHookDetails defines model for RepositoryHookDetails.
type RepositoryHookDetails struct {
	ConfigFormKey   *string                                 `json:"configFormKey,omitempty"`
	Description     *string                                 `json:"description,omitempty"`
	Key             *string                                 `json:"key,omitempty"`
	Name            *string                                 `json:"name,omitempty"`
	SupportedScopes *[]RepositoryHookDetailsSupportedScopes `json:"supportedScopes,omitempty"`
	Type            *RepositoryHookDetailsType              `json:"type,omitempty"`
	Version         *string                                 `json:"version,omitempty"`
}

// RepositoryHookDetailsSupportedScopes defines model for RepositoryHookDetails.SupportedScopes.
type RepositoryHookDetailsSupportedScopes string

// RepositoryHookDetailsType defines model for RepositoryHookDetails.Type.
type RepositoryHookDetailsType string

// RestAccessToken defines model for RestAccessToken.
type RestAccessToken struct {
	CreatedDate *time.Time `json:"createdDate,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
}

// RestAccessTokenRequest defines model for RestAccessTokenRequest.
type RestAccessTokenRequest struct {
	ExpiryDays  *int32    `json:"expiryDays,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Permissions *[]string `json:"permissions,omitempty"`
}

// RestAggregateRejectCounter defines model for RestAggregateRejectCounter.
type RestAggregateRejectCounter struct {
	LastRejectTime *float32 `json:"lastRejectTime,omitempty"`
	RejectCount    *int64   `json:"rejectCount,omitempty"`
	User           *struct {
		Active       *bool                               `json:"active,omitempty"`
		AvatarUrl    *string                             `json:"avatarUrl,omitempty"`
		DisplayName  *string                             `json:"displayName,omitempty"`
		EmailAddress *string                             `json:"emailAddress,omitempty"`
		Id           *int32                              `json:"id,omitempty"`
		Links        *map[string]interface{}             `json:"links,omitempty"`
		Name         *string                             `json:"name,omitempty"`
		Slug         *string                             `json:"slug,omitempty"`
		Type         *RestAggregateRejectCounterUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestAggregateRejectCounterUserType defines model for RestAggregateRejectCounter.User.Type.
type RestAggregateRejectCounterUserType string

// RestAnalyticsSettings defines model for RestAnalyticsSettings.
type RestAnalyticsSettings struct {
	CanCollectAnalytics      *bool   `json:"canCollectAnalytics,omitempty"`
	ServerTime               *int64  `json:"serverTime,omitempty"`
	SupportEntitlementNumber *string `json:"supportEntitlementNumber,omitempty"`
}

// RestAnnouncementBanner defines model for RestAnnouncementBanner.
type RestAnnouncementBanner struct {
	Audience *RestAnnouncementBannerAudience `json:"audience,omitempty"`
	Enabled  *bool                           `json:"enabled,omitempty"`
	Message  *string                         `json:"message,omitempty"`
}

// RestAnnouncementBannerAudience defines model for RestAnnouncementBanner.Audience.
type RestAnnouncementBannerAudience string

// RestApplicationProperties defines model for RestApplicationProperties.
type RestApplicationProperties struct {
	BuildDate   *string `json:"buildDate,omitempty"`
	BuildNumber *string `json:"buildNumber,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// RestApplicationUser defines model for RestApplicationUser.
type RestApplicationUser struct {
	Active       *bool                    `json:"active,omitempty"`
	AvatarUrl    *string                  `json:"avatarUrl,omitempty"`
	DisplayName  *string                  `json:"displayName,omitempty"`
	EmailAddress *string                  `json:"emailAddress,omitempty"`
	Id           *int32                   `json:"id,omitempty"`
	Links        *map[string]interface{}  `json:"links,omitempty"`
	Name         *string                  `json:"name,omitempty"`
	Slug         *string                  `json:"slug,omitempty"`
	Type         *RestApplicationUserType `json:"type,omitempty"`
}

// RestApplicationUserType defines model for RestApplicationUser.Type.
type RestApplicationUserType string

// RestApplicationUserWithPermissions defines model for RestApplicationUserWithPermissions.
type RestApplicationUserWithPermissions struct {
	Active               *bool                                   `json:"active,omitempty"`
	AvatarUrl            *string                                 `json:"avatarUrl,omitempty"`
	DisplayName          *string                                 `json:"displayName,omitempty"`
	EffectivePermissions *map[string]interface{}                 `json:"effectivePermissions,omitempty"`
	EmailAddress         *string                                 `json:"emailAddress,omitempty"`
	Id                   *int32                                  `json:"id,omitempty"`
	Links                *map[string]interface{}                 `json:"links,omitempty"`
	Name                 *string                                 `json:"name,omitempty"`
	Slug                 *string                                 `json:"slug,omitempty"`
	Type                 *RestApplicationUserWithPermissionsType `json:"type,omitempty"`
}

// RestApplicationUserWithPermissionsType defines model for RestApplicationUserWithPermissions.Type.
type RestApplicationUserWithPermissionsType string

// RestApplySuggestionRequest defines model for RestApplySuggestionRequest.
type RestApplySuggestionRequest struct {
	CommentVersion *struct {
		AsInt   *int32 `json:"asInt,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"commentVersion,omitempty"`
	CommitMessage      *string `json:"commitMessage,omitempty"`
	PullRequestVersion *struct {
		AsInt   *int32 `json:"asInt,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"pullRequestVersion,omitempty"`
	SuggestionIndex *struct {
		AsInt   *int32 `json:"asInt,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"suggestionIndex,omitempty"`
}

// RestAttachmentMetadata defines model for RestAttachmentMetadata.
type RestAttachmentMetadata struct {
	Id       *int64  `json:"id,omitempty"`
	Metadata *string `json:"metadata,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// RestAuthenticationRequest defines model for RestAuthenticationRequest.
type RestAuthenticationRequest struct {
	Credentials  Credentials `json:"credentials"`
	RepositoryId *int32      `json:"repositoryId,omitempty"`
}

// RestAutoDeclineSettings defines model for RestAutoDeclineSettings.
type RestAutoDeclineSettings struct {
	Enabled         *bool  `json:"enabled,omitempty"`
	InactivityWeeks *int32 `json:"inactivityWeeks,omitempty"`
	Scope           *struct {
		ResourceId *int32                            `json:"resourceId,omitempty"`
		Type       *RestAutoDeclineSettingsScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
}

// RestAutoDeclineSettingsScopeType defines model for RestAutoDeclineSettings.Scope.Type.
type RestAutoDeclineSettingsScopeType string

// RestAutoDeclineSettingsRequest defines model for RestAutoDeclineSettingsRequest.
type RestAutoDeclineSettingsRequest struct {
	Enabled         *bool  `json:"enabled,omitempty"`
	InactivityWeeks *int32 `json:"inactivityWeeks,omitempty"`
}

// RestAutoMergeProcessingResult defines model for RestAutoMergeProcessingResult.
type RestAutoMergeProcessingResult struct {
	AutoMergeProcessingStatus *RestAutoMergeProcessingResultAutoMergeProcessingStatus `json:"autoMergeProcessingStatus,omitempty"`
	PullRequest               *struct {
		Closed            *bool   `json:"closed,omitempty"`
		ClosedDate        *int64  `json:"closedDate,omitempty"`
		CreatedDate       *int64  `json:"createdDate,omitempty"`
		Description       *string `json:"description,omitempty"`
		DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
		Draft             *bool   `json:"draft,omitempty"`
		FromRef           *struct {
			DisplayId    *string `json:"displayId,omitempty"`
			Id           *string `json:"id,omitempty"`
			LatestCommit *string `json:"latestCommit,omitempty"`
			Repository   *struct {
				Archived      *bool                   `json:"archived,omitempty"`
				DefaultBranch *string                 `json:"defaultBranch,omitempty"`
				Description   *string                 `json:"description,omitempty"`
				Forkable      *bool                   `json:"forkable,omitempty"`
				HierarchyId   *string                 `json:"hierarchyId,omitempty"`
				Id            *int32                  `json:"id,omitempty"`
				Links         *map[string]interface{} `json:"links,omitempty"`
				Name          *string                 `json:"name,omitempty"`
				Origin        *struct {
					Archived      *bool                   `json:"archived,omitempty"`
					DefaultBranch *string                 `json:"defaultBranch,omitempty"`
					Description   *string                 `json:"description,omitempty"`
					Forkable      *bool                   `json:"forkable,omitempty"`
					HierarchyId   *string                 `json:"hierarchyId,omitempty"`
					Id            *int32                  `json:"id,omitempty"`
					Links         *map[string]interface{} `json:"links,omitempty"`
					Name          *string                 `json:"name,omitempty"`
					Partition     *int32                  `json:"partition,omitempty"`
					Project       *struct {
						Avatar      *string                                                                     `json:"avatar,omitempty"`
						AvatarUrl   *string                                                                     `json:"avatarUrl,omitempty"`
						Description *string                                                                     `json:"description,omitempty"`
						Id          *int32                                                                      `json:"id,omitempty"`
						Key         string                                                                      `json:"key"`
						Links       *map[string]interface{}                                                     `json:"links,omitempty"`
						Name        *string                                                                     `json:"name,omitempty"`
						Public      *bool                                                                       `json:"public,omitempty"`
						Scope       *string                                                                     `json:"scope,omitempty"`
						Type        *RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
					} `json:"project,omitempty"`
					Public        *bool                                                                 `json:"public,omitempty"`
					RelatedLinks  *map[string]interface{}                                               `json:"relatedLinks,omitempty"`
					ScmId         *string                                                               `json:"scmId,omitempty"`
					Scope         *string                                                               `json:"scope,omitempty"`
					Slug          *string                                                               `json:"slug,omitempty"`
					State         *RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
					StatusMessage *string                                                               `json:"statusMessage,omitempty"`
				} `json:"origin,omitempty"`
				Partition *int32 `json:"partition,omitempty"`
				Project   *struct {
					Avatar      *string                                                               `json:"avatar,omitempty"`
					AvatarUrl   *string                                                               `json:"avatarUrl,omitempty"`
					Description *string                                                               `json:"description,omitempty"`
					Id          *int32                                                                `json:"id,omitempty"`
					Key         string                                                                `json:"key"`
					Links       *map[string]interface{}                                               `json:"links,omitempty"`
					Name        *string                                                               `json:"name,omitempty"`
					Public      *bool                                                                 `json:"public,omitempty"`
					Scope       *string                                                               `json:"scope,omitempty"`
					Type        *RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
				} `json:"project,omitempty"`
				Public        *bool                                                           `json:"public,omitempty"`
				RelatedLinks  *map[string]interface{}                                         `json:"relatedLinks,omitempty"`
				ScmId         *string                                                         `json:"scmId,omitempty"`
				Scope         *string                                                         `json:"scope,omitempty"`
				Slug          *string                                                         `json:"slug,omitempty"`
				State         *RestAutoMergeProcessingResultPullRequestFromRefRepositoryState `json:"state,omitempty"`
				StatusMessage *string                                                         `json:"statusMessage,omitempty"`
			} `json:"repository,omitempty"`
			Type *RestAutoMergeProcessingResultPullRequestFromRefType `json:"type,omitempty"`
		} `json:"fromRef,omitempty"`
		HtmlDescription *string                                        `json:"htmlDescription,omitempty"`
		Id              *int64                                         `json:"id,omitempty"`
		Links           *map[string]interface{}                        `json:"links,omitempty"`
		Locked          *bool                                          `json:"locked,omitempty"`
		Open            *bool                                          `json:"open,omitempty"`
		Participants    *[]RestPullRequestParticipant                  `json:"participants,omitempty"`
		Reviewers       *[]RestPullRequestParticipant                  `json:"reviewers,omitempty"`
		State           *RestAutoMergeProcessingResultPullRequestState `json:"state,omitempty"`
		Title           *string                                        `json:"title,omitempty"`
		ToRef           *struct {
			DisplayId    *string `json:"displayId,omitempty"`
			Id           *string `json:"id,omitempty"`
			LatestCommit *string `json:"latestCommit,omitempty"`
			Repository   *struct {
				Archived      *bool                   `json:"archived,omitempty"`
				DefaultBranch *string                 `json:"defaultBranch,omitempty"`
				Description   *string                 `json:"description,omitempty"`
				Forkable      *bool                   `json:"forkable,omitempty"`
				HierarchyId   *string                 `json:"hierarchyId,omitempty"`
				Id            *int32                  `json:"id,omitempty"`
				Links         *map[string]interface{} `json:"links,omitempty"`
				Name          *string                 `json:"name,omitempty"`
				Origin        *struct {
					Archived      *bool                   `json:"archived,omitempty"`
					DefaultBranch *string                 `json:"defaultBranch,omitempty"`
					Description   *string                 `json:"description,omitempty"`
					Forkable      *bool                   `json:"forkable,omitempty"`
					HierarchyId   *string                 `json:"hierarchyId,omitempty"`
					Id            *int32                  `json:"id,omitempty"`
					Links         *map[string]interface{} `json:"links,omitempty"`
					Name          *string                 `json:"name,omitempty"`
					Partition     *int32                  `json:"partition,omitempty"`
					Project       *struct {
						Avatar      *string                                                                   `json:"avatar,omitempty"`
						AvatarUrl   *string                                                                   `json:"avatarUrl,omitempty"`
						Description *string                                                                   `json:"description,omitempty"`
						Id          *int32                                                                    `json:"id,omitempty"`
						Key         string                                                                    `json:"key"`
						Links       *map[string]interface{}                                                   `json:"links,omitempty"`
						Name        *string                                                                   `json:"name,omitempty"`
						Public      *bool                                                                     `json:"public,omitempty"`
						Scope       *string                                                                   `json:"scope,omitempty"`
						Type        *RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
					} `json:"project,omitempty"`
					Public        *bool                                                               `json:"public,omitempty"`
					RelatedLinks  *map[string]interface{}                                             `json:"relatedLinks,omitempty"`
					ScmId         *string                                                             `json:"scmId,omitempty"`
					Scope         *string                                                             `json:"scope,omitempty"`
					Slug          *string                                                             `json:"slug,omitempty"`
					State         *RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
					StatusMessage *string                                                             `json:"statusMessage,omitempty"`
				} `json:"origin,omitempty"`
				Partition *int32 `json:"partition,omitempty"`
				Project   *struct {
					Avatar      *string                                                             `json:"avatar,omitempty"`
					AvatarUrl   *string                                                             `json:"avatarUrl,omitempty"`
					Description *string                                                             `json:"description,omitempty"`
					Id          *int32                                                              `json:"id,omitempty"`
					Key         string                                                              `json:"key"`
					Links       *map[string]interface{}                                             `json:"links,omitempty"`
					Name        *string                                                             `json:"name,omitempty"`
					Public      *bool                                                               `json:"public,omitempty"`
					Scope       *string                                                             `json:"scope,omitempty"`
					Type        *RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
				} `json:"project,omitempty"`
				Public        *bool                                                         `json:"public,omitempty"`
				RelatedLinks  *map[string]interface{}                                       `json:"relatedLinks,omitempty"`
				ScmId         *string                                                       `json:"scmId,omitempty"`
				Scope         *string                                                       `json:"scope,omitempty"`
				Slug          *string                                                       `json:"slug,omitempty"`
				State         *RestAutoMergeProcessingResultPullRequestToRefRepositoryState `json:"state,omitempty"`
				StatusMessage *string                                                       `json:"statusMessage,omitempty"`
			} `json:"repository,omitempty"`
			Type *RestAutoMergeProcessingResultPullRequestToRefType `json:"type,omitempty"`
		} `json:"toRef,omitempty"`
		UpdatedDate *int64 `json:"updatedDate,omitempty"`
		Version     *int32 `json:"version,omitempty"`
	} `json:"pullRequest,omitempty"`
}

// RestAutoMergeProcessingResultAutoMergeProcessingStatus defines model for RestAutoMergeProcessingResult.AutoMergeProcessingStatus.
type RestAutoMergeProcessingResultAutoMergeProcessingStatus string

// RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType defines model for RestAutoMergeProcessingResult.PullRequest.FromRef.Repository.Origin.Project.Type.
type RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginProjectType string

// RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState defines model for RestAutoMergeProcessingResult.PullRequest.FromRef.Repository.Origin.State.
type RestAutoMergeProcessingResultPullRequestFromRefRepositoryOriginState string

// RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType defines model for RestAutoMergeProcessingResult.PullRequest.FromRef.Repository.Project.Type.
type RestAutoMergeProcessingResultPullRequestFromRefRepositoryProjectType string

// RestAutoMergeProcessingResultPullRequestFromRefRepositoryState defines model for RestAutoMergeProcessingResult.PullRequest.FromRef.Repository.State.
type RestAutoMergeProcessingResultPullRequestFromRefRepositoryState string

// RestAutoMergeProcessingResultPullRequestFromRefType defines model for RestAutoMergeProcessingResult.PullRequest.FromRef.Type.
type RestAutoMergeProcessingResultPullRequestFromRefType string

// RestAutoMergeProcessingResultPullRequestState defines model for RestAutoMergeProcessingResult.PullRequest.State.
type RestAutoMergeProcessingResultPullRequestState string

// RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType defines model for RestAutoMergeProcessingResult.PullRequest.ToRef.Repository.Origin.Project.Type.
type RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginProjectType string

// RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState defines model for RestAutoMergeProcessingResult.PullRequest.ToRef.Repository.Origin.State.
type RestAutoMergeProcessingResultPullRequestToRefRepositoryOriginState string

// RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType defines model for RestAutoMergeProcessingResult.PullRequest.ToRef.Repository.Project.Type.
type RestAutoMergeProcessingResultPullRequestToRefRepositoryProjectType string

// RestAutoMergeProcessingResultPullRequestToRefRepositoryState defines model for RestAutoMergeProcessingResult.PullRequest.ToRef.Repository.State.
type RestAutoMergeProcessingResultPullRequestToRefRepositoryState string

// RestAutoMergeProcessingResultPullRequestToRefType defines model for RestAutoMergeProcessingResult.PullRequest.ToRef.Type.
type RestAutoMergeProcessingResultPullRequestToRefType string

// RestAutoMergeProjectSettingsRequest defines model for RestAutoMergeProjectSettingsRequest.
type RestAutoMergeProjectSettingsRequest struct {
	Enabled           *bool                                                 `json:"enabled,omitempty"`
	RestrictionAction *RestAutoMergeProjectSettingsRequestRestrictionAction `json:"restrictionAction,omitempty"`
}

// RestAutoMergeProjectSettingsRequestRestrictionAction defines model for RestAutoMergeProjectSettingsRequest.RestrictionAction.
type RestAutoMergeProjectSettingsRequestRestrictionAction string

// RestAutoMergeRequest defines model for RestAutoMergeRequest.
type RestAutoMergeRequest struct {
	AutoSubject *bool   `json:"autoSubject,omitempty"`
	CreatedDate *int64  `json:"createdDate,omitempty"`
	FromHash    *string `json:"fromHash,omitempty"`
	Message     *string `json:"message,omitempty"`
	StrategyId  *string `json:"strategyId,omitempty"`
	ToRefId     *string `json:"toRefId,omitempty"`
}

// RestAutoMergeRestrictedSettings defines model for RestAutoMergeRestrictedSettings.
type RestAutoMergeRestrictedSettings struct {
	Enabled *bool `json:"enabled,omitempty"`

	// RestrictionState The restriction state of this scope's project.
	RestrictionState *RestAutoMergeRestrictedSettingsRestrictionState `json:"restrictionState,omitempty"`

	// Scope The scope that these settings apply to.
	Scope *struct {
		ResourceId *int32                                    `json:"resourceId,omitempty"`
		Type       *RestAutoMergeRestrictedSettingsScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
}

// RestAutoMergeRestrictedSettingsRestrictionState The restriction state of this scope's project.
type RestAutoMergeRestrictedSettingsRestrictionState string

// RestAutoMergeRestrictedSettingsScopeType defines model for RestAutoMergeRestrictedSettings.Scope.Type.
type RestAutoMergeRestrictedSettingsScopeType string

// RestAutoMergeSettingsRequest defines model for RestAutoMergeSettingsRequest.
type RestAutoMergeSettingsRequest struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// RestBearerTokenCredentials defines model for RestBearerTokenCredentials.
type RestBearerTokenCredentials struct {
	Token string `json:"token"`
}

// RestBitbucketLicense defines model for RestBitbucketLicense.
type RestBitbucketLicense struct {
	CreationDate                        *int64  `json:"creationDate,omitempty"`
	DaysBeforeExpiry                    *int32  `json:"daysBeforeExpiry,omitempty"`
	ExpiryDate                          *int64  `json:"expiryDate,omitempty"`
	GracePeriodEndDate                  *int64  `json:"gracePeriodEndDate,omitempty"`
	License                             *string `json:"license,omitempty"`
	MaintenanceExpiryDate               *int64  `json:"maintenanceExpiryDate,omitempty"`
	MaximumNumberOfUsers                *int32  `json:"maximumNumberOfUsers,omitempty"`
	NumberOfDaysBeforeExpiry            *int32  `json:"numberOfDaysBeforeExpiry,omitempty"`
	NumberOfDaysBeforeGracePeriodExpiry *int32  `json:"numberOfDaysBeforeGracePeriodExpiry,omitempty"`
	NumberOfDaysBeforeMaintenanceExpiry *int32  `json:"numberOfDaysBeforeMaintenanceExpiry,omitempty"`
	PurchaseDate                        *int64  `json:"purchaseDate,omitempty"`
	ServerId                            *string `json:"serverId,omitempty"`
	Status                              *struct {
		CurrentNumberOfUsers *int32  `json:"currentNumberOfUsers,omitempty"`
		ServerId             *string `json:"serverId,omitempty"`
	} `json:"status,omitempty"`
	SupportEntitlementNumber *string `json:"supportEntitlementNumber,omitempty"`
	UnlimitedNumberOfUsers   *bool   `json:"unlimitedNumberOfUsers,omitempty"`
}

// RestBranch defines model for RestBranch.
type RestBranch struct {
	Default         *bool    `json:"default,omitempty"`
	DisplayId       *string  `json:"displayId,omitempty"`
	Id              *string  `json:"id,omitempty"`
	LatestChangeset *string  `json:"latestChangeset,omitempty"`
	LatestCommit    *string  `json:"latestCommit,omitempty"`
	Type            *RefType `json:"type,omitempty"`
}

// RestBranchCreateRequest defines model for RestBranchCreateRequest.
type RestBranchCreateRequest struct {
	// Name Name of the branch to be created
	Name *string `json:"name,omitempty"`

	// StartPoint Commit ID from which the branch is created
	StartPoint *string `json:"startPoint,omitempty"`
}

// RestBranchDeleteRequest defines model for RestBranchDeleteRequest.
type RestBranchDeleteRequest struct {
	// DryRun Don't actually delete the ref name, just do a dry run
	DryRun *bool `json:"dryRun,omitempty"`

	// EndPoint Commit ID that the provided ref name is expected to point to
	EndPoint *string `json:"endPoint,omitempty"`

	// Name Name of the ref to be deleted
	Name *string `json:"name,omitempty"`
}

// RestBuildCapabilities defines model for RestBuildCapabilities.
type RestBuildCapabilities struct {
	BuildStatus *[]string `json:"buildStatus,omitempty"`
}

// RestBuildStats defines model for RestBuildStats.
type RestBuildStats struct {
	Cancelled  *int32 `json:"cancelled,omitempty"`
	Failed     *int32 `json:"failed,omitempty"`
	InProgress *int32 `json:"inProgress,omitempty"`
	Successful *int32 `json:"successful,omitempty"`
	Unknown    *int32 `json:"unknown,omitempty"`
}

// RestBuildStatus defines model for RestBuildStatus.
type RestBuildStatus struct {
	BuildNumber *string               `json:"buildNumber,omitempty"`
	CreatedDate *int64                `json:"createdDate,omitempty"`
	Description *string               `json:"description,omitempty"`
	Duration    *int64                `json:"duration,omitempty"`
	Key         *string               `json:"key,omitempty"`
	Name        *string               `json:"name,omitempty"`
	Parent      *string               `json:"parent,omitempty"`
	Ref         *string               `json:"ref,omitempty"`
	State       *RestBuildStatusState `json:"state,omitempty"`
	TestResults *struct {
		Failed     *int32 `json:"failed,omitempty"`
		Skipped    *int32 `json:"skipped,omitempty"`
		Successful *int32 `json:"successful,omitempty"`
	} `json:"testResults,omitempty"`
	UpdatedDate *int64  `json:"updatedDate,omitempty"`
	Url         *string `json:"url,omitempty"`
}

// RestBuildStatusState defines model for RestBuildStatus.State.
type RestBuildStatusState string

// RestBuildStatusSetRequest defines model for RestBuildStatusSetRequest.
type RestBuildStatusSetRequest struct {
	BuildNumber *string                        `json:"buildNumber,omitempty"`
	Description *string                        `json:"description,omitempty"`
	Duration    *int64                         `json:"duration,omitempty"`
	Key         string                         `json:"key"`
	LastUpdated *int64                         `json:"lastUpdated,omitempty"`
	Name        *string                        `json:"name,omitempty"`
	Parent      *string                        `json:"parent,omitempty"`
	Ref         *string                        `json:"ref,omitempty"`
	State       RestBuildStatusSetRequestState `json:"state"`
	TestResults *struct {
		Failed     *int32 `json:"failed,omitempty"`
		Skipped    *int32 `json:"skipped,omitempty"`
		Successful *int32 `json:"successful,omitempty"`
	} `json:"testResults,omitempty"`
	Url string `json:"url"`
}

// RestBuildStatusSetRequestState defines model for RestBuildStatusSetRequest.State.
type RestBuildStatusSetRequestState string

// RestBulkAddInsightAnnotationRequest defines model for RestBulkAddInsightAnnotationRequest.
type RestBulkAddInsightAnnotationRequest struct {
	Annotations *[]RestSingleAddInsightAnnotationRequest `json:"annotations,omitempty"`
}

// RestBulkUserRateLimitSettingsUpdateRequest defines model for RestBulkUserRateLimitSettingsUpdateRequest.
type RestBulkUserRateLimitSettingsUpdateRequest struct {
	Settings *struct {
		Capacity *int32 `json:"capacity,omitempty"`
		FillRate *int32 `json:"fillRate,omitempty"`
	} `json:"settings,omitempty"`
	Usernames   *[]string `json:"usernames,omitempty"`
	Whitelisted *bool     `json:"whitelisted,omitempty"`
}

// RestChange defines model for RestChange.
type RestChange struct {
	Conflict *struct {
		OurChange *struct {
			Path *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"path,omitempty"`
			SrcPath *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"srcPath,omitempty"`
			Type *RestChangeConflictOurChangeType `json:"type,omitempty"`
		} `json:"ourChange,omitempty"`
		TheirChange *struct {
			Path *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"path,omitempty"`
			SrcPath *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"srcPath,omitempty"`
			Type *RestChangeConflictTheirChangeType `json:"type,omitempty"`
		} `json:"theirChange,omitempty"`
	} `json:"conflict,omitempty"`
	ContentId     *string                 `json:"contentId,omitempty"`
	Executable    *bool                   `json:"executable,omitempty"`
	FromContentId *string                 `json:"fromContentId,omitempty"`
	Links         *map[string]interface{} `json:"links,omitempty"`
	NodeType      *RestChangeNodeType     `json:"nodeType,omitempty"`
	Path          *struct {
		Components *[]string `json:"components,omitempty"`
		Extension  *string   `json:"extension,omitempty"`
		Name       *string   `json:"name,omitempty"`
		Parent     *string   `json:"parent,omitempty"`
	} `json:"path,omitempty"`
	PercentUnchanged *int32 `json:"percentUnchanged,omitempty"`
	SrcExecutable    *bool  `json:"srcExecutable,omitempty"`
	SrcPath          *struct {
		Components *[]string `json:"components,omitempty"`
		Extension  *string   `json:"extension,omitempty"`
		Name       *string   `json:"name,omitempty"`
		Parent     *string   `json:"parent,omitempty"`
	} `json:"srcPath,omitempty"`
	Type *RestChangeType `json:"type,omitempty"`
}

// RestChangeConflictOurChangeType defines model for RestChange.Conflict.OurChange.Type.
type RestChangeConflictOurChangeType string

// RestChangeConflictTheirChangeType defines model for RestChange.Conflict.TheirChange.Type.
type RestChangeConflictTheirChangeType string

// RestChangeNodeType defines model for RestChange.NodeType.
type RestChangeNodeType string

// RestChangeType defines model for RestChange.Type.
type RestChangeType string

// RestChangeset defines model for RestChangeset.
type RestChangeset struct {
	Changes *struct {
		IsLastPage    *bool                   `json:"isLastPage,omitempty"`
		Limit         *int32                  `json:"limit,omitempty"`
		NextPageStart *int32                  `json:"nextPageStart,omitempty"`
		Size          *int32                  `json:"size,omitempty"`
		Start         *int32                  `json:"start,omitempty"`
		Values        *map[string]interface{} `json:"values,omitempty"`
	} `json:"changes,omitempty"`
	FromCommit *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
	} `json:"fromCommit,omitempty"`
	Links      *map[string]interface{} `json:"links,omitempty"`
	Repository *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                   `json:"avatar,omitempty"`
				AvatarUrl   *string                                   `json:"avatarUrl,omitempty"`
				Description *string                                   `json:"description,omitempty"`
				Id          *int32                                    `json:"id,omitempty"`
				Key         string                                    `json:"key"`
				Links       *map[string]interface{}                   `json:"links,omitempty"`
				Name        *string                                   `json:"name,omitempty"`
				Public      *bool                                     `json:"public,omitempty"`
				Scope       *string                                   `json:"scope,omitempty"`
				Type        *RestChangesetRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                               `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}             `json:"relatedLinks,omitempty"`
			ScmId         *string                             `json:"scmId,omitempty"`
			Scope         *string                             `json:"scope,omitempty"`
			Slug          *string                             `json:"slug,omitempty"`
			State         *RestChangesetRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                             `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                             `json:"avatar,omitempty"`
			AvatarUrl   *string                             `json:"avatarUrl,omitempty"`
			Description *string                             `json:"description,omitempty"`
			Id          *int32                              `json:"id,omitempty"`
			Key         string                              `json:"key"`
			Links       *map[string]interface{}             `json:"links,omitempty"`
			Name        *string                             `json:"name,omitempty"`
			Public      *bool                               `json:"public,omitempty"`
			Scope       *string                             `json:"scope,omitempty"`
			Type        *RestChangesetRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                         `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}       `json:"relatedLinks,omitempty"`
		ScmId         *string                       `json:"scmId,omitempty"`
		Scope         *string                       `json:"scope,omitempty"`
		Slug          *string                       `json:"slug,omitempty"`
		State         *RestChangesetRepositoryState `json:"state,omitempty"`
		StatusMessage *string                       `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
	ToCommit *struct {
		Author *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"author,omitempty"`
		AuthorTimestamp *int64 `json:"authorTimestamp,omitempty"`
		Committer       *struct {
			AvatarUrl    *string `json:"avatarUrl,omitempty"`
			EmailAddress *string `json:"emailAddress,omitempty"`
			Name         *string `json:"name,omitempty"`
		} `json:"committer,omitempty"`
		CommitterTimestamp *int64               `json:"committerTimestamp,omitempty"`
		DisplayId          *string              `json:"displayId,omitempty"`
		Id                 *string              `json:"id,omitempty"`
		Message            *string              `json:"message,omitempty"`
		Parents            *[]RestMinimalCommit `json:"parents,omitempty"`
	} `json:"toCommit,omitempty"`
}

// RestChangesetRepositoryOriginProjectType defines model for RestChangeset.Repository.Origin.Project.Type.
type RestChangesetRepositoryOriginProjectType string

// RestChangesetRepositoryOriginState defines model for RestChangeset.Repository.Origin.State.
type RestChangesetRepositoryOriginState string

// RestChangesetRepositoryProjectType defines model for RestChangeset.Repository.Project.Type.
type RestChangesetRepositoryProjectType string

// RestChangesetRepositoryState defines model for RestChangeset.Repository.State.
type RestChangesetRepositoryState string

// RestClusterInformation defines model for RestClusterInformation.
type RestClusterInformation struct {
	LocalNode *struct {
		Address *struct {
			Address *string `json:"address,omitempty"`
			Port    *int32  `json:"port,omitempty"`
		} `json:"address,omitempty"`
		BuildVersion *string `json:"buildVersion,omitempty"`
		Id           *string `json:"id,omitempty"`
		Local        *bool   `json:"local,omitempty"`
		Name         *string `json:"name,omitempty"`
	} `json:"localNode,omitempty"`
	Nodes   *[]RestClusterNode `json:"nodes,omitempty"`
	Running *bool              `json:"running,omitempty"`
}

// RestClusterNode defines model for RestClusterNode.
type RestClusterNode struct {
	Address *struct {
		Address *string `json:"address,omitempty"`
		Port    *int32  `json:"port,omitempty"`
	} `json:"address,omitempty"`
	BuildVersion *string `json:"buildVersion,omitempty"`
	Id           *string `json:"id,omitempty"`
	Local        *bool   `json:"local,omitempty"`
	Name         *string `json:"name,omitempty"`
}

// RestComment defines model for RestComment.
type RestComment struct {
	Anchor *struct {
		DiffType        *RestCommentAnchorDiffType `json:"diffType,omitempty"`
		FileType        *RestCommentAnchorFileType `json:"fileType,omitempty"`
		FromHash        *string                    `json:"fromHash,omitempty"`
		Line            *int32                     `json:"line,omitempty"`
		LineType        *RestCommentAnchorLineType `json:"lineType,omitempty"`
		MultilineMarker *struct {
			// StartLine The line number where the multiline comment will begin
			StartLine *int32 `json:"startLine,omitempty"`

			// StartLineType The segment type of the start line of the multiline comment
			StartLineType RestCommentAnchorMultilineMarkerStartLineType `json:"startLineType"`
		} `json:"multilineMarker,omitempty"`
		MultilineSpan *struct {
			// DstSpanEnd The line number of the last line on the right-hand side of the diff that the comment spans
			DstSpanEnd *struct {
				AsInt   *int32 `json:"asInt,omitempty"`
				Present *bool  `json:"present,omitempty"`
			} `json:"dstSpanEnd,omitempty"`

			// DstSpanStart The line number of the first line on the right-hand side of the diff that the comment spans
			DstSpanStart *struct {
				AsInt   *int32 `json:"asInt,omitempty"`
				Present *bool  `json:"present,omitempty"`
			} `json:"dstSpanStart,omitempty"`

			// SrcSpanEnd The line number of the last line on the left-hand side of the diff that the comment spans
			SrcSpanEnd *struct {
				AsInt   *int32 `json:"asInt,omitempty"`
				Present *bool  `json:"present,omitempty"`
			} `json:"srcSpanEnd,omitempty"`

			// SrcSpanStart The line number of the first line on the left-hand side of the diff that the comment spans
			SrcSpanStart *struct {
				AsInt   *int32 `json:"asInt,omitempty"`
				Present *bool  `json:"present,omitempty"`
			} `json:"srcSpanStart,omitempty"`
		} `json:"multilineSpan,omitempty"`
		Path *struct {
			Components *[]string `json:"components,omitempty"`
			Extension  *string   `json:"extension,omitempty"`
			Name       *string   `json:"name,omitempty"`
			Parent     *string   `json:"parent,omitempty"`
		} `json:"path,omitempty"`
		PullRequest *struct {
			Closed            *bool   `json:"closed,omitempty"`
			ClosedDate        *int64  `json:"closedDate,omitempty"`
			CreatedDate       *int64  `json:"createdDate,omitempty"`
			Description       *string `json:"description,omitempty"`
			DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
			Draft             *bool   `json:"draft,omitempty"`
			FromRef           *struct {
				DisplayId    *string `json:"displayId,omitempty"`
				Id           *string `json:"id,omitempty"`
				LatestCommit *string `json:"latestCommit,omitempty"`
				Repository   *struct {
					Archived      *bool                   `json:"archived,omitempty"`
					DefaultBranch *string                 `json:"defaultBranch,omitempty"`
					Description   *string                 `json:"description,omitempty"`
					Forkable      *bool                   `json:"forkable,omitempty"`
					HierarchyId   *string                 `json:"hierarchyId,omitempty"`
					Id            *int32                  `json:"id,omitempty"`
					Links         *map[string]interface{} `json:"links,omitempty"`
					Name          *string                 `json:"name,omitempty"`
					Origin        *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Partition     *int32                  `json:"partition,omitempty"`
						Project       *struct {
							Avatar      *string                                                         `json:"avatar,omitempty"`
							AvatarUrl   *string                                                         `json:"avatarUrl,omitempty"`
							Description *string                                                         `json:"description,omitempty"`
							Id          *int32                                                          `json:"id,omitempty"`
							Key         string                                                          `json:"key"`
							Links       *map[string]interface{}                                         `json:"links,omitempty"`
							Name        *string                                                         `json:"name,omitempty"`
							Public      *bool                                                           `json:"public,omitempty"`
							Scope       *string                                                         `json:"scope,omitempty"`
							Type        *RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                     `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                   `json:"relatedLinks,omitempty"`
						ScmId         *string                                                   `json:"scmId,omitempty"`
						Scope         *string                                                   `json:"scope,omitempty"`
						Slug          *string                                                   `json:"slug,omitempty"`
						State         *RestCommentAnchorPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
						StatusMessage *string                                                   `json:"statusMessage,omitempty"`
					} `json:"origin,omitempty"`
					Partition *int32 `json:"partition,omitempty"`
					Project   *struct {
						Avatar      *string                                                   `json:"avatar,omitempty"`
						AvatarUrl   *string                                                   `json:"avatarUrl,omitempty"`
						Description *string                                                   `json:"description,omitempty"`
						Id          *int32                                                    `json:"id,omitempty"`
						Key         string                                                    `json:"key"`
						Links       *map[string]interface{}                                   `json:"links,omitempty"`
						Name        *string                                                   `json:"name,omitempty"`
						Public      *bool                                                     `json:"public,omitempty"`
						Scope       *string                                                   `json:"scope,omitempty"`
						Type        *RestCommentAnchorPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
					} `json:"project,omitempty"`
					Public        *bool                                               `json:"public,omitempty"`
					RelatedLinks  *map[string]interface{}                             `json:"relatedLinks,omitempty"`
					ScmId         *string                                             `json:"scmId,omitempty"`
					Scope         *string                                             `json:"scope,omitempty"`
					Slug          *string                                             `json:"slug,omitempty"`
					State         *RestCommentAnchorPullRequestFromRefRepositoryState `json:"state,omitempty"`
					StatusMessage *string                                             `json:"statusMessage,omitempty"`
				} `json:"repository,omitempty"`
				Type *RestCommentAnchorPullRequestFromRefType `json:"type,omitempty"`
			} `json:"fromRef,omitempty"`
			HtmlDescription *string                            `json:"htmlDescription,omitempty"`
			Id              *int64                             `json:"id,omitempty"`
			Links           *map[string]interface{}            `json:"links,omitempty"`
			Locked          *bool                              `json:"locked,omitempty"`
			Open            *bool                              `json:"open,omitempty"`
			Participants    *[]RestPullRequestParticipant      `json:"participants,omitempty"`
			Reviewers       *[]RestPullRequestParticipant      `json:"reviewers,omitempty"`
			State           *RestCommentAnchorPullRequestState `json:"state,omitempty"`
			Title           *string                            `json:"title,omitempty"`
			ToRef           *struct {
				DisplayId    *string `json:"displayId,omitempty"`
				Id           *string `json:"id,omitempty"`
				LatestCommit *string `json:"latestCommit,omitempty"`
				Repository   *struct {
					Archived      *bool                   `json:"archived,omitempty"`
					DefaultBranch *string                 `json:"defaultBranch,omitempty"`
					Description   *string                 `json:"description,omitempty"`
					Forkable      *bool                   `json:"forkable,omitempty"`
					HierarchyId   *string                 `json:"hierarchyId,omitempty"`
					Id            *int32                  `json:"id,omitempty"`
					Links         *map[string]interface{} `json:"links,omitempty"`
					Name          *string                 `json:"name,omitempty"`
					Origin        *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Partition     *int32                  `json:"partition,omitempty"`
						Project       *struct {
							Avatar      *string                                                       `json:"avatar,omitempty"`
							AvatarUrl   *string                                                       `json:"avatarUrl,omitempty"`
							Description *string                                                       `json:"description,omitempty"`
							Id          *int32                                                        `json:"id,omitempty"`
							Key         string                                                        `json:"key"`
							Links       *map[string]interface{}                                       `json:"links,omitempty"`
							Name        *string                                                       `json:"name,omitempty"`
							Public      *bool                                                         `json:"public,omitempty"`
							Scope       *string                                                       `json:"scope,omitempty"`
							Type        *RestCommentAnchorPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                   `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                 `json:"relatedLinks,omitempty"`
						ScmId         *string                                                 `json:"scmId,omitempty"`
						Scope         *string                                                 `json:"scope,omitempty"`
						Slug          *string                                                 `json:"slug,omitempty"`
						State         *RestCommentAnchorPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
						StatusMessage *string                                                 `json:"statusMessage,omitempty"`
					} `json:"origin,omitempty"`
					Partition *int32 `json:"partition,omitempty"`
					Project   *struct {
						Avatar      *string                                                 `json:"avatar,omitempty"`
						AvatarUrl   *string                                                 `json:"avatarUrl,omitempty"`
						Description *string                                                 `json:"description,omitempty"`
						Id          *int32                                                  `json:"id,omitempty"`
						Key         string                                                  `json:"key"`
						Links       *map[string]interface{}                                 `json:"links,omitempty"`
						Name        *string                                                 `json:"name,omitempty"`
						Public      *bool                                                   `json:"public,omitempty"`
						Scope       *string                                                 `json:"scope,omitempty"`
						Type        *RestCommentAnchorPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
					} `json:"project,omitempty"`
					Public        *bool                                             `json:"public,omitempty"`
					RelatedLinks  *map[string]interface{}                           `json:"relatedLinks,omitempty"`
					ScmId         *string                                           `json:"scmId,omitempty"`
					Scope         *string                                           `json:"scope,omitempty"`
					Slug          *string                                           `json:"slug,omitempty"`
					State         *RestCommentAnchorPullRequestToRefRepositoryState `json:"state,omitempty"`
					StatusMessage *string                                           `json:"statusMessage,omitempty"`
				} `json:"repository,omitempty"`
				Type *RestCommentAnchorPullRequestToRefType `json:"type,omitempty"`
			} `json:"toRef,omitempty"`
			UpdatedDate *int64 `json:"updatedDate,omitempty"`
			Version     *int32 `json:"version,omitempty"`
		} `json:"pullRequest,omitempty"`
		SrcPath *struct {
			Components *[]string `json:"components,omitempty"`
			Extension  *string   `json:"extension,omitempty"`
			Name       *string   `json:"name,omitempty"`
			Parent     *string   `json:"parent,omitempty"`
		} `json:"srcPath,omitempty"`
		ToHash *string `json:"toHash,omitempty"`
	} `json:"anchor,omitempty"`
	Anchored *bool `json:"anchored,omitempty"`
	Author   *struct {
		Active       *bool                   `json:"active,omitempty"`
		AvatarUrl    *string                 `json:"avatarUrl,omitempty"`
		DisplayName  *string                 `json:"displayName,omitempty"`
		EmailAddress *string                 `json:"emailAddress,omitempty"`
		Id           *int32                  `json:"id,omitempty"`
		Links        *map[string]interface{} `json:"links,omitempty"`
		Name         *string                 `json:"name,omitempty"`
		Slug         *string                 `json:"slug,omitempty"`
		Type         *RestCommentAuthorType  `json:"type,omitempty"`
	} `json:"author,omitempty"`
	Comments    *[]RestComment `json:"comments,omitempty"`
	CreatedDate *int64         `json:"createdDate,omitempty"`
	Html        *string        `json:"html,omitempty"`
	Id          *int64         `json:"id,omitempty"`
	Parent      *struct {
		Anchor *struct {
			DiffType        *RestCommentParentAnchorDiffType `json:"diffType,omitempty"`
			FileType        *RestCommentParentAnchorFileType `json:"fileType,omitempty"`
			FromHash        *string                          `json:"fromHash,omitempty"`
			Line            *int32                           `json:"line,omitempty"`
			LineType        *RestCommentParentAnchorLineType `json:"lineType,omitempty"`
			MultilineMarker *struct {
				// StartLine The line number where the multiline comment will begin
				StartLine *int32 `json:"startLine,omitempty"`

				// StartLineType The segment type of the start line of the multiline comment
				StartLineType RestCommentParentAnchorMultilineMarkerStartLineType `json:"startLineType"`
			} `json:"multilineMarker,omitempty"`
			MultilineSpan *struct {
				// DstSpanEnd The line number of the last line on the right-hand side of the diff that the comment spans
				DstSpanEnd *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"dstSpanEnd,omitempty"`

				// DstSpanStart The line number of the first line on the right-hand side of the diff that the comment spans
				DstSpanStart *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"dstSpanStart,omitempty"`

				// SrcSpanEnd The line number of the last line on the left-hand side of the diff that the comment spans
				SrcSpanEnd *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"srcSpanEnd,omitempty"`

				// SrcSpanStart The line number of the first line on the left-hand side of the diff that the comment spans
				SrcSpanStart *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"srcSpanStart,omitempty"`
			} `json:"multilineSpan,omitempty"`
			Path *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"path,omitempty"`
			PullRequest *struct {
				Closed            *bool   `json:"closed,omitempty"`
				ClosedDate        *int64  `json:"closedDate,omitempty"`
				CreatedDate       *int64  `json:"createdDate,omitempty"`
				Description       *string `json:"description,omitempty"`
				DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
				Draft             *bool   `json:"draft,omitempty"`
				FromRef           *struct {
					DisplayId    *string `json:"displayId,omitempty"`
					Id           *string `json:"id,omitempty"`
					LatestCommit *string `json:"latestCommit,omitempty"`
					Repository   *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Origin        *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Partition     *int32                  `json:"partition,omitempty"`
							Project       *struct {
								Avatar      *string                                                               `json:"avatar,omitempty"`
								AvatarUrl   *string                                                               `json:"avatarUrl,omitempty"`
								Description *string                                                               `json:"description,omitempty"`
								Id          *int32                                                                `json:"id,omitempty"`
								Key         string                                                                `json:"key"`
								Links       *map[string]interface{}                                               `json:"links,omitempty"`
								Name        *string                                                               `json:"name,omitempty"`
								Public      *bool                                                                 `json:"public,omitempty"`
								Scope       *string                                                               `json:"scope,omitempty"`
								Type        *RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                           `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                         `json:"relatedLinks,omitempty"`
							ScmId         *string                                                         `json:"scmId,omitempty"`
							Scope         *string                                                         `json:"scope,omitempty"`
							Slug          *string                                                         `json:"slug,omitempty"`
							State         *RestCommentParentAnchorPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
							StatusMessage *string                                                         `json:"statusMessage,omitempty"`
						} `json:"origin,omitempty"`
						Partition *int32 `json:"partition,omitempty"`
						Project   *struct {
							Avatar      *string                                                         `json:"avatar,omitempty"`
							AvatarUrl   *string                                                         `json:"avatarUrl,omitempty"`
							Description *string                                                         `json:"description,omitempty"`
							Id          *int32                                                          `json:"id,omitempty"`
							Key         string                                                          `json:"key"`
							Links       *map[string]interface{}                                         `json:"links,omitempty"`
							Name        *string                                                         `json:"name,omitempty"`
							Public      *bool                                                           `json:"public,omitempty"`
							Scope       *string                                                         `json:"scope,omitempty"`
							Type        *RestCommentParentAnchorPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                     `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                   `json:"relatedLinks,omitempty"`
						ScmId         *string                                                   `json:"scmId,omitempty"`
						Scope         *string                                                   `json:"scope,omitempty"`
						Slug          *string                                                   `json:"slug,omitempty"`
						State         *RestCommentParentAnchorPullRequestFromRefRepositoryState `json:"state,omitempty"`
						StatusMessage *string                                                   `json:"statusMessage,omitempty"`
					} `json:"repository,omitempty"`
					Type *RestCommentParentAnchorPullRequestFromRefType `json:"type,omitempty"`
				} `json:"fromRef,omitempty"`
				HtmlDescription *string                                  `json:"htmlDescription,omitempty"`
				Id              *int64                                   `json:"id,omitempty"`
				Links           *map[string]interface{}                  `json:"links,omitempty"`
				Locked          *bool                                    `json:"locked,omitempty"`
				Open            *bool                                    `json:"open,omitempty"`
				Participants    *[]RestPullRequestParticipant            `json:"participants,omitempty"`
				Reviewers       *[]RestPullRequestParticipant            `json:"reviewers,omitempty"`
				State           *RestCommentParentAnchorPullRequestState `json:"state,omitempty"`
				Title           *string                                  `json:"title,omitempty"`
				ToRef           *struct {
					DisplayId    *string `json:"displayId,omitempty"`
					Id           *string `json:"id,omitempty"`
					LatestCommit *string `json:"latestCommit,omitempty"`
					Repository   *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Origin        *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Partition     *int32                  `json:"partition,omitempty"`
							Project       *struct {
								Avatar      *string                                                             `json:"avatar,omitempty"`
								AvatarUrl   *string                                                             `json:"avatarUrl,omitempty"`
								Description *string                                                             `json:"description,omitempty"`
								Id          *int32                                                              `json:"id,omitempty"`
								Key         string                                                              `json:"key"`
								Links       *map[string]interface{}                                             `json:"links,omitempty"`
								Name        *string                                                             `json:"name,omitempty"`
								Public      *bool                                                               `json:"public,omitempty"`
								Scope       *string                                                             `json:"scope,omitempty"`
								Type        *RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                         `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                       `json:"relatedLinks,omitempty"`
							ScmId         *string                                                       `json:"scmId,omitempty"`
							Scope         *string                                                       `json:"scope,omitempty"`
							Slug          *string                                                       `json:"slug,omitempty"`
							State         *RestCommentParentAnchorPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
							StatusMessage *string                                                       `json:"statusMessage,omitempty"`
						} `json:"origin,omitempty"`
						Partition *int32 `json:"partition,omitempty"`
						Project   *struct {
							Avatar      *string                                                       `json:"avatar,omitempty"`
							AvatarUrl   *string                                                       `json:"avatarUrl,omitempty"`
							Description *string                                                       `json:"description,omitempty"`
							Id          *int32                                                        `json:"id,omitempty"`
							Key         string                                                        `json:"key"`
							Links       *map[string]interface{}                                       `json:"links,omitempty"`
							Name        *string                                                       `json:"name,omitempty"`
							Public      *bool                                                         `json:"public,omitempty"`
							Scope       *string                                                       `json:"scope,omitempty"`
							Type        *RestCommentParentAnchorPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                   `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                 `json:"relatedLinks,omitempty"`
						ScmId         *string                                                 `json:"scmId,omitempty"`
						Scope         *string                                                 `json:"scope,omitempty"`
						Slug          *string                                                 `json:"slug,omitempty"`
						State         *RestCommentParentAnchorPullRequestToRefRepositoryState `json:"state,omitempty"`
						StatusMessage *string                                                 `json:"statusMessage,omitempty"`
					} `json:"repository,omitempty"`
					Type *RestCommentParentAnchorPullRequestToRefType `json:"type,omitempty"`
				} `json:"toRef,omitempty"`
				UpdatedDate *int64 `json:"updatedDate,omitempty"`
				Version     *int32 `json:"version,omitempty"`
			} `json:"pullRequest,omitempty"`
			SrcPath *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"srcPath,omitempty"`
			ToHash *string `json:"toHash,omitempty"`
		} `json:"anchor,omitempty"`
		Anchored *bool `json:"anchored,omitempty"`
		Author   *struct {
			Active       *bool                        `json:"active,omitempty"`
			AvatarUrl    *string                      `json:"avatarUrl,omitempty"`
			DisplayName  *string                      `json:"displayName,omitempty"`
			EmailAddress *string                      `json:"emailAddress,omitempty"`
			Id           *int32                       `json:"id,omitempty"`
			Links        *map[string]interface{}      `json:"links,omitempty"`
			Name         *string                      `json:"name,omitempty"`
			Slug         *string                      `json:"slug,omitempty"`
			Type         *RestCommentParentAuthorType `json:"type,omitempty"`
		} `json:"author,omitempty"`
		CreatedDate  *int64                  `json:"createdDate,omitempty"`
		Html         *string                 `json:"html,omitempty"`
		Id           *int64                  `json:"id,omitempty"`
		Pending      *bool                   `json:"pending,omitempty"`
		Properties   *map[string]interface{} `json:"properties,omitempty"`
		Reply        *bool                   `json:"reply,omitempty"`
		ResolvedDate *int64                  `json:"resolvedDate,omitempty"`
		Resolver     *struct {
			Active       *bool                          `json:"active,omitempty"`
			AvatarUrl    *string                        `json:"avatarUrl,omitempty"`
			DisplayName  *string                        `json:"displayName,omitempty"`
			EmailAddress *string                        `json:"emailAddress,omitempty"`
			Id           *int32                         `json:"id,omitempty"`
			Links        *map[string]interface{}        `json:"links,omitempty"`
			Name         *string                        `json:"name,omitempty"`
			Slug         *string                        `json:"slug,omitempty"`
			Type         *RestCommentParentResolverType `json:"type,omitempty"`
		} `json:"resolver,omitempty"`
		Severity *string `json:"severity,omitempty"`
		State    *string `json:"state,omitempty"`
		Text     *string `json:"text,omitempty"`

		// ThreadResolved Indicates if this comment thread has been marked as resolved or not
		ThreadResolved     *bool  `json:"threadResolved,omitempty"`
		ThreadResolvedDate *int64 `json:"threadResolvedDate,omitempty"`
		ThreadResolver     *struct {
			Active       *bool                                `json:"active,omitempty"`
			AvatarUrl    *string                              `json:"avatarUrl,omitempty"`
			DisplayName  *string                              `json:"displayName,omitempty"`
			EmailAddress *string                              `json:"emailAddress,omitempty"`
			Id           *int32                               `json:"id,omitempty"`
			Links        *map[string]interface{}              `json:"links,omitempty"`
			Name         *string                              `json:"name,omitempty"`
			Slug         *string                              `json:"slug,omitempty"`
			Type         *RestCommentParentThreadResolverType `json:"type,omitempty"`
		} `json:"threadResolver,omitempty"`
		UpdatedDate *int64 `json:"updatedDate,omitempty"`
		Version     *int32 `json:"version,omitempty"`
	} `json:"parent,omitempty"`
	Pending      *bool                   `json:"pending,omitempty"`
	Properties   *map[string]interface{} `json:"properties,omitempty"`
	Reply        *bool                   `json:"reply,omitempty"`
	ResolvedDate *int64                  `json:"resolvedDate,omitempty"`
	Resolver     *struct {
		Active       *bool                    `json:"active,omitempty"`
		AvatarUrl    *string                  `json:"avatarUrl,omitempty"`
		DisplayName  *string                  `json:"displayName,omitempty"`
		EmailAddress *string                  `json:"emailAddress,omitempty"`
		Id           *int32                   `json:"id,omitempty"`
		Links        *map[string]interface{}  `json:"links,omitempty"`
		Name         *string                  `json:"name,omitempty"`
		Slug         *string                  `json:"slug,omitempty"`
		Type         *RestCommentResolverType `json:"type,omitempty"`
	} `json:"resolver,omitempty"`
	Severity *string `json:"severity,omitempty"`
	State    *string `json:"state,omitempty"`
	Text     *string `json:"text,omitempty"`

	// ThreadResolved Indicates if this comment thread has been marked as resolved or not
	ThreadResolved     *bool  `json:"threadResolved,omitempty"`
	ThreadResolvedDate *int64 `json:"threadResolvedDate,omitempty"`
	ThreadResolver     *struct {
		Active       *bool                          `json:"active,omitempty"`
		AvatarUrl    *string                        `json:"avatarUrl,omitempty"`
		DisplayName  *string                        `json:"displayName,omitempty"`
		EmailAddress *string                        `json:"emailAddress,omitempty"`
		Id           *int32                         `json:"id,omitempty"`
		Links        *map[string]interface{}        `json:"links,omitempty"`
		Name         *string                        `json:"name,omitempty"`
		Slug         *string                        `json:"slug,omitempty"`
		Type         *RestCommentThreadResolverType `json:"type,omitempty"`
	} `json:"threadResolver,omitempty"`
	UpdatedDate *int64 `json:"updatedDate,omitempty"`
	Version     *int32 `json:"version,omitempty"`
}

// RestCommentAnchorDiffType defines model for RestComment.Anchor.DiffType.
type RestCommentAnchorDiffType string

// RestCommentAnchorFileType defines model for RestComment.Anchor.FileType.
type RestCommentAnchorFileType string

// RestCommentAnchorLineType defines model for RestComment.Anchor.LineType.
type RestCommentAnchorLineType string

// RestCommentAnchorMultilineMarkerStartLineType The segment type of the start line of the multiline comment
type RestCommentAnchorMultilineMarkerStartLineType string

// RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType defines model for RestComment.Anchor.PullRequest.FromRef.Repository.Origin.Project.Type.
type RestCommentAnchorPullRequestFromRefRepositoryOriginProjectType string

// RestCommentAnchorPullRequestFromRefRepositoryOriginState defines model for RestComment.Anchor.PullRequest.FromRef.Repository.Origin.State.
type RestCommentAnchorPullRequestFromRefRepositoryOriginState string

// RestCommentAnchorPullRequestFromRefRepositoryProjectType defines model for RestComment.Anchor.PullRequest.FromRef.Repository.Project.Type.
type RestCommentAnchorPullRequestFromRefRepositoryProjectType string

// RestCommentAnchorPullRequestFromRefRepositoryState defines model for RestComment.Anchor.PullRequest.FromRef.Repository.State.
type RestCommentAnchorPullRequestFromRefRepositoryState string

// RestCommentAnchorPullRequestFromRefType defines model for RestComment.Anchor.PullRequest.FromRef.Type.
type RestCommentAnchorPullRequestFromRefType string

// RestCommentAnchorPullRequestState defines model for RestComment.Anchor.PullRequest.State.
type RestCommentAnchorPullRequestState string

// RestCommentAnchorPullRequestToRefRepositoryOriginProjectType defines model for RestComment.Anchor.PullRequest.ToRef.Repository.Origin.Project.Type.
type RestCommentAnchorPullRequestToRefRepositoryOriginProjectType string

// RestCommentAnchorPullRequestToRefRepositoryOriginState defines model for RestComment.Anchor.PullRequest.ToRef.Repository.Origin.State.
type RestCommentAnchorPullRequestToRefRepositoryOriginState string

// RestCommentAnchorPullRequestToRefRepositoryProjectType defines model for RestComment.Anchor.PullRequest.ToRef.Repository.Project.Type.
type RestCommentAnchorPullRequestToRefRepositoryProjectType string

// RestCommentAnchorPullRequestToRefRepositoryState defines model for RestComment.Anchor.PullRequest.ToRef.Repository.State.
type RestCommentAnchorPullRequestToRefRepositoryState string

// RestCommentAnchorPullRequestToRefType defines model for RestComment.Anchor.PullRequest.ToRef.Type.
type RestCommentAnchorPullRequestToRefType string

// RestCommentAuthorType defines model for RestComment.Author.Type.
type RestCommentAuthorType string

// RestCommentParentAnchorDiffType defines model for RestComment.Parent.Anchor.DiffType.
type RestCommentParentAnchorDiffType string

// RestCommentParentAnchorFileType defines model for RestComment.Parent.Anchor.FileType.
type RestCommentParentAnchorFileType string

// RestCommentParentAnchorLineType defines model for RestComment.Parent.Anchor.LineType.
type RestCommentParentAnchorLineType string

// RestCommentParentAnchorMultilineMarkerStartLineType The segment type of the start line of the multiline comment
type RestCommentParentAnchorMultilineMarkerStartLineType string

// RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType defines model for RestComment.Parent.Anchor.PullRequest.FromRef.Repository.Origin.Project.Type.
type RestCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType string

// RestCommentParentAnchorPullRequestFromRefRepositoryOriginState defines model for RestComment.Parent.Anchor.PullRequest.FromRef.Repository.Origin.State.
type RestCommentParentAnchorPullRequestFromRefRepositoryOriginState string

// RestCommentParentAnchorPullRequestFromRefRepositoryProjectType defines model for RestComment.Parent.Anchor.PullRequest.FromRef.Repository.Project.Type.
type RestCommentParentAnchorPullRequestFromRefRepositoryProjectType string

// RestCommentParentAnchorPullRequestFromRefRepositoryState defines model for RestComment.Parent.Anchor.PullRequest.FromRef.Repository.State.
type RestCommentParentAnchorPullRequestFromRefRepositoryState string

// RestCommentParentAnchorPullRequestFromRefType defines model for RestComment.Parent.Anchor.PullRequest.FromRef.Type.
type RestCommentParentAnchorPullRequestFromRefType string

// RestCommentParentAnchorPullRequestState defines model for RestComment.Parent.Anchor.PullRequest.State.
type RestCommentParentAnchorPullRequestState string

// RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType defines model for RestComment.Parent.Anchor.PullRequest.ToRef.Repository.Origin.Project.Type.
type RestCommentParentAnchorPullRequestToRefRepositoryOriginProjectType string

// RestCommentParentAnchorPullRequestToRefRepositoryOriginState defines model for RestComment.Parent.Anchor.PullRequest.ToRef.Repository.Origin.State.
type RestCommentParentAnchorPullRequestToRefRepositoryOriginState string

// RestCommentParentAnchorPullRequestToRefRepositoryProjectType defines model for RestComment.Parent.Anchor.PullRequest.ToRef.Repository.Project.Type.
type RestCommentParentAnchorPullRequestToRefRepositoryProjectType string

// RestCommentParentAnchorPullRequestToRefRepositoryState defines model for RestComment.Parent.Anchor.PullRequest.ToRef.Repository.State.
type RestCommentParentAnchorPullRequestToRefRepositoryState string

// RestCommentParentAnchorPullRequestToRefType defines model for RestComment.Parent.Anchor.PullRequest.ToRef.Type.
type RestCommentParentAnchorPullRequestToRefType string

// RestCommentParentAuthorType defines model for RestComment.Parent.Author.Type.
type RestCommentParentAuthorType string

// RestCommentParentResolverType defines model for RestComment.Parent.Resolver.Type.
type RestCommentParentResolverType string

// RestCommentParentThreadResolverType defines model for RestComment.Parent.ThreadResolver.Type.
type RestCommentParentThreadResolverType string

// RestCommentResolverType defines model for RestComment.Resolver.Type.
type RestCommentResolverType string

// RestCommentThreadResolverType defines model for RestComment.ThreadResolver.Type.
type RestCommentThreadResolverType string

// RestCommentJiraIssue defines model for RestCommentJiraIssue.
type RestCommentJiraIssue struct {
	CommentId *int64  `json:"commentId,omitempty"`
	IssueKey  *string `json:"issueKey,omitempty"`
}

// RestCommit defines model for RestCommit.
type RestCommit struct {
	Author *struct {
		AvatarUrl    *string `json:"avatarUrl,omitempty"`
		EmailAddress *string `json:"emailAddress,omitempty"`
		Name         *string `json:"name,omitempty"`
	} `json:"author,omitempty"`
	AuthorTimestamp *int64 `json:"authorTimestamp,omitempty"`
	Committer       *struct {
		AvatarUrl    *string `json:"avatarUrl,omitempty"`
		EmailAddress *string `json:"emailAddress,omitempty"`
		Name         *string `json:"name,omitempty"`
	} `json:"committer,omitempty"`
	CommitterTimestamp *int64               `json:"committerTimestamp,omitempty"`
	DisplayId          *string              `json:"displayId,omitempty"`
	Id                 *string              `json:"id,omitempty"`
	Message            *string              `json:"message,omitempty"`
	Parents            *[]RestMinimalCommit `json:"parents,omitempty"`
}

// RestCommitMessageSuggestion defines model for RestCommitMessageSuggestion.
type RestCommitMessageSuggestion struct {
	Body  *string `json:"body,omitempty"`
	Title *string `json:"title,omitempty"`
}

// RestCreateBranchRequest defines model for RestCreateBranchRequest.
type RestCreateBranchRequest struct {
	Message    *string `json:"message,omitempty"`
	Name       *string `json:"name,omitempty"`
	StartPoint *string `json:"startPoint,omitempty"`
}

// RestCreateTagRequest defines model for RestCreateTagRequest.
type RestCreateTagRequest struct {
	Message    *string `json:"message,omitempty"`
	Name       *string `json:"name,omitempty"`
	StartPoint *string `json:"startPoint,omitempty"`
}

// RestDefaultReviewersRequest defines model for RestDefaultReviewersRequest.
type RestDefaultReviewersRequest struct {
	RequiredApprovals *int32                 `json:"requiredApprovals,omitempty"`
	Reviewers         *[]RestApplicationUser `json:"reviewers,omitempty"`
	SourceMatcher     *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestDefaultReviewersRequestSourceMatcherTypeId `json:"id,omitempty"`
			Name *string                                         `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"sourceMatcher,omitempty"`
	TargetMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestDefaultReviewersRequestTargetMatcherTypeId `json:"id,omitempty"`
			Name *string                                         `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"targetMatcher,omitempty"`
}

// RestDefaultReviewersRequestSourceMatcherTypeId defines model for RestDefaultReviewersRequest.SourceMatcher.Type.Id.
type RestDefaultReviewersRequestSourceMatcherTypeId string

// RestDefaultReviewersRequestTargetMatcherTypeId defines model for RestDefaultReviewersRequest.TargetMatcher.Type.Id.
type RestDefaultReviewersRequestTargetMatcherTypeId string

// RestDefaultTask defines model for RestDefaultTask.
type RestDefaultTask struct {
	Description *string `json:"description,omitempty"`
	Html        *string `json:"html,omitempty"`
	Id          *int64  `json:"id,omitempty"`
}

// RestDefaultTaskRequest defines model for RestDefaultTaskRequest.
type RestDefaultTaskRequest struct {
	Description   *string `json:"description,omitempty"`
	SourceMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestDefaultTaskRequestSourceMatcherTypeId `json:"id,omitempty"`
			Name *string                                    `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"sourceMatcher,omitempty"`
	TargetMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestDefaultTaskRequestTargetMatcherTypeId `json:"id,omitempty"`
			Name *string                                    `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"targetMatcher,omitempty"`
}

// RestDefaultTaskRequestSourceMatcherTypeId defines model for RestDefaultTaskRequest.SourceMatcher.Type.Id.
type RestDefaultTaskRequestSourceMatcherTypeId string

// RestDefaultTaskRequestTargetMatcherTypeId defines model for RestDefaultTaskRequest.TargetMatcher.Type.Id.
type RestDefaultTaskRequestTargetMatcherTypeId string

// RestDeployment defines model for RestDeployment.
type RestDeployment struct {
	DeploymentSequenceNumber *int64  `json:"deploymentSequenceNumber,omitempty"`
	Description              *string `json:"description,omitempty"`
	DisplayName              *string `json:"displayName,omitempty"`
	Environment              *struct {
		DisplayName string  `json:"displayName"`
		Key         string  `json:"key"`
		Type        *string `json:"type,omitempty"`
		Url         *string `json:"url,omitempty"`
	} `json:"environment,omitempty"`
	FromCommit *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
	} `json:"fromCommit,omitempty"`
	Key         *string `json:"key,omitempty"`
	LastUpdated *int64  `json:"lastUpdated,omitempty"`
	Repository  *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                    `json:"avatar,omitempty"`
				AvatarUrl   *string                                    `json:"avatarUrl,omitempty"`
				Description *string                                    `json:"description,omitempty"`
				Id          *int32                                     `json:"id,omitempty"`
				Key         string                                     `json:"key"`
				Links       *map[string]interface{}                    `json:"links,omitempty"`
				Name        *string                                    `json:"name,omitempty"`
				Public      *bool                                      `json:"public,omitempty"`
				Scope       *string                                    `json:"scope,omitempty"`
				Type        *RestDeploymentRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}              `json:"relatedLinks,omitempty"`
			ScmId         *string                              `json:"scmId,omitempty"`
			Scope         *string                              `json:"scope,omitempty"`
			Slug          *string                              `json:"slug,omitempty"`
			State         *RestDeploymentRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                              `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                              `json:"avatar,omitempty"`
			AvatarUrl   *string                              `json:"avatarUrl,omitempty"`
			Description *string                              `json:"description,omitempty"`
			Id          *int32                               `json:"id,omitempty"`
			Key         string                               `json:"key"`
			Links       *map[string]interface{}              `json:"links,omitempty"`
			Name        *string                              `json:"name,omitempty"`
			Public      *bool                                `json:"public,omitempty"`
			Scope       *string                              `json:"scope,omitempty"`
			Type        *RestDeploymentRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                          `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}        `json:"relatedLinks,omitempty"`
		ScmId         *string                        `json:"scmId,omitempty"`
		Scope         *string                        `json:"scope,omitempty"`
		Slug          *string                        `json:"slug,omitempty"`
		State         *RestDeploymentRepositoryState `json:"state,omitempty"`
		StatusMessage *string                        `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
	State    *RestDeploymentState `json:"state,omitempty"`
	ToCommit *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
	} `json:"toCommit,omitempty"`
	Url *string `json:"url,omitempty"`
}

// RestDeploymentRepositoryOriginProjectType defines model for RestDeployment.Repository.Origin.Project.Type.
type RestDeploymentRepositoryOriginProjectType string

// RestDeploymentRepositoryOriginState defines model for RestDeployment.Repository.Origin.State.
type RestDeploymentRepositoryOriginState string

// RestDeploymentRepositoryProjectType defines model for RestDeployment.Repository.Project.Type.
type RestDeploymentRepositoryProjectType string

// RestDeploymentRepositoryState defines model for RestDeployment.Repository.State.
type RestDeploymentRepositoryState string

// RestDeploymentState defines model for RestDeployment.State.
type RestDeploymentState string

// RestDeploymentEnvironment defines model for RestDeploymentEnvironment.
type RestDeploymentEnvironment struct {
	DisplayName *string `json:"displayName,omitempty"`
	Key         *string `json:"key,omitempty"`
	Type        *string `json:"type,omitempty"`
	Url         *string `json:"url,omitempty"`
}

// RestDeploymentSetRequest defines model for RestDeploymentSetRequest.
type RestDeploymentSetRequest struct {
	DeploymentSequenceNumber int64                         `json:"deploymentSequenceNumber"`
	Description              string                        `json:"description"`
	DisplayName              string                        `json:"displayName"`
	Environment              RestDeploymentEnvironment     `json:"environment"`
	Key                      string                        `json:"key"`
	LastUpdated              *int64                        `json:"lastUpdated,omitempty"`
	State                    RestDeploymentSetRequestState `json:"state"`
	Url                      string                        `json:"url"`
}

// RestDeploymentSetRequestState defines model for RestDeploymentSetRequest.State.
type RestDeploymentSetRequestState string

// RestDetailedGroup defines model for RestDetailedGroup.
type RestDetailedGroup struct {
	Deletable *bool   `json:"deletable,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// RestDetailedInvocation defines model for RestDetailedInvocation.
type RestDetailedInvocation struct {
	Duration   *int32  `json:"duration,omitempty"`
	Event      *string `json:"event,omitempty"`
	EventScope *struct {
		Id   *string `json:"id,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"eventScope,omitempty"`
	Finish  *int32                  `json:"finish,omitempty"`
	Id      *int32                  `json:"id,omitempty"`
	Request *map[string]interface{} `json:"request,omitempty"`
	Result  *map[string]interface{} `json:"result,omitempty"`
	Start   *int32                  `json:"start,omitempty"`
}

// RestDetailedUser defines model for RestDetailedUser.
type RestDetailedUser struct {
	Active                      *bool                   `json:"active,omitempty"`
	AvatarUrl                   *string                 `json:"avatarUrl,omitempty"`
	Deletable                   *bool                   `json:"deletable,omitempty"`
	DirectoryName               *string                 `json:"directoryName,omitempty"`
	DisplayName                 *string                 `json:"displayName,omitempty"`
	EmailAddress                *string                 `json:"emailAddress,omitempty"`
	Id                          *int32                  `json:"id,omitempty"`
	LastAuthenticationTimestamp *float32                `json:"lastAuthenticationTimestamp,omitempty"`
	Links                       *map[string]interface{} `json:"links,omitempty"`
	MutableDetails              *bool                   `json:"mutableDetails,omitempty"`
	MutableGroups               *bool                   `json:"mutableGroups,omitempty"`
	Name                        *string                 `json:"name,omitempty"`
	Slug                        *string                 `json:"slug,omitempty"`
	Type                        *RestDetailedUserType   `json:"type,omitempty"`
}

// RestDetailedUserType defines model for RestDetailedUser.Type.
type RestDetailedUserType string

// RestDiff defines model for RestDiff.
type RestDiff struct {
	Binary      *bool `json:"binary,omitempty"`
	Destination *struct {
		Components *[]string `json:"components,omitempty"`
		Extension  *string   `json:"extension,omitempty"`
		Name       *string   `json:"name,omitempty"`
		Parent     *string   `json:"parent,omitempty"`
	} `json:"destination,omitempty"`
	Hunks        *[]RestDiffHunk         `json:"hunks,omitempty"`
	LineComments *[]RestComment          `json:"lineComments,omitempty"`
	Properties   *map[string]interface{} `json:"properties,omitempty"`
	Source       *struct {
		Components *[]string `json:"components,omitempty"`
		Extension  *string   `json:"extension,omitempty"`
		Name       *string   `json:"name,omitempty"`
		Parent     *string   `json:"parent,omitempty"`
	} `json:"source,omitempty"`
	Truncated *bool `json:"truncated,omitempty"`
}

// RestDiffHunk defines model for RestDiffHunk.
type RestDiffHunk struct {
	Context         *string            `json:"context,omitempty"`
	DestinationLine *int32             `json:"destinationLine,omitempty"`
	DestinationSpan *int32             `json:"destinationSpan,omitempty"`
	Segments        *[]RestDiffSegment `json:"segments,omitempty"`
	SourceLine      *int32             `json:"sourceLine,omitempty"`
	SourceSpan      *int32             `json:"sourceSpan,omitempty"`
	Truncated       *bool              `json:"truncated,omitempty"`
}

// RestDiffLine defines model for RestDiffLine.
type RestDiffLine struct {
	CommentIds     *[]int64                    `json:"commentIds,omitempty"`
	ConflictMarker *RestDiffLineConflictMarker `json:"conflictMarker,omitempty"`
	Destination    *int32                      `json:"destination,omitempty"`
	Line           *string                     `json:"line,omitempty"`
	Source         *int32                      `json:"source,omitempty"`
	Truncated      *bool                       `json:"truncated,omitempty"`
}

// RestDiffLineConflictMarker defines model for RestDiffLine.ConflictMarker.
type RestDiffLineConflictMarker string

// RestDiffSegment defines model for RestDiffSegment.
type RestDiffSegment struct {
	Lines     *[]RestDiffLine      `json:"lines,omitempty"`
	Truncated *bool                `json:"truncated,omitempty"`
	Type      *RestDiffSegmentType `json:"type,omitempty"`
}

// RestDiffSegmentType defines model for RestDiffSegment.Type.
type RestDiffSegmentType string

// RestDiffStatsSummary defines model for RestDiffStatsSummary.
type RestDiffStatsSummary = interface{}

// RestEnhancedEntityLink defines model for RestEnhancedEntityLink.
type RestEnhancedEntityLink struct {
	ApplicationLinkId *string `json:"applicationLinkId,omitempty"`
	DisplayUrl        *string `json:"displayUrl,omitempty"`
	ProjectId         *int64  `json:"projectId,omitempty"`
	ProjectKey        *string `json:"projectKey,omitempty"`
	ProjectName       *string `json:"projectName,omitempty"`
}

// RestErasedUser defines model for RestErasedUser.
type RestErasedUser struct {
	NewIdentifier *string `json:"newIdentifier,omitempty"`
}

// RestErrorMessage defines model for RestErrorMessage.
type RestErrorMessage struct {
	Context       *string `json:"context,omitempty"`
	ExceptionName *string `json:"exceptionName,omitempty"`
	Message       *string `json:"message,omitempty"`
}

// RestErrors defines model for RestErrors.
type RestErrors struct {
	Errors *[]RestErrorMessage `json:"errors,omitempty"`
}

// RestExportRequest defines model for RestExportRequest.
type RestExportRequest struct {
	ExportLocation      *string `json:"exportLocation,omitempty"`
	RepositoriesRequest struct {
		Includes []RestRepositorySelector `json:"includes"`
	} `json:"repositoriesRequest"`
}

// RestFarmSynchronizationRequest defines model for RestFarmSynchronizationRequest.
type RestFarmSynchronizationRequest struct {
	Attempt        *int32                              `json:"attempt,omitempty"`
	CreatedAt      *string                             `json:"createdAt,omitempty"`
	ExternalRepoId *string                             `json:"externalRepoId,omitempty"`
	Type           *RestFarmSynchronizationRequestType `json:"type,omitempty"`
}

// RestFarmSynchronizationRequestType defines model for RestFarmSynchronizationRequest.Type.
type RestFarmSynchronizationRequestType string

// RestGitTagCreateRequest defines model for RestGitTagCreateRequest.
type RestGitTagCreateRequest struct {
	Force      *bool                        `json:"force,omitempty"`
	Message    *string                      `json:"message,omitempty"`
	Name       *string                      `json:"name,omitempty"`
	StartPoint *string                      `json:"startPoint,omitempty"`
	Type       *RestGitTagCreateRequestType `json:"type,omitempty"`
}

// RestGitTagCreateRequestType defines model for RestGitTagCreateRequest.Type.
type RestGitTagCreateRequestType string

// RestGpgKey defines model for RestGpgKey.
type RestGpgKey struct {
	EmailAddress *string          `json:"emailAddress,omitempty"`
	ExpiryDate   *int64           `json:"expiryDate,omitempty"`
	Fingerprint  *string          `json:"fingerprint,omitempty"`
	Id           *string          `json:"id,omitempty"`
	SubKeys      *[]RestGpgSubKey `json:"subKeys,omitempty"`
	Text         *string          `json:"text,omitempty"`
}

// RestGpgSubKey defines model for RestGpgSubKey.
type RestGpgSubKey struct {
	ExpiryDate  *time.Time `json:"expiryDate,omitempty"`
	Fingerprint *string    `json:"fingerprint,omitempty"`
}

// RestHookScript defines model for RestHookScript.
type RestHookScript struct {
	CreatedDate *time.Time          `json:"createdDate,omitempty"`
	Description *string             `json:"description,omitempty"`
	Id          *int64              `json:"id,omitempty"`
	Name        *string             `json:"name,omitempty"`
	PluginKey   *string             `json:"pluginKey,omitempty"`
	Type        *RestHookScriptType `json:"type,omitempty"`
	UpdatedDate *time.Time          `json:"updatedDate,omitempty"`
	Version     *int32              `json:"version,omitempty"`
}

// RestHookScriptType defines model for RestHookScript.Type.
type RestHookScriptType string

// RestHookScriptConfig defines model for RestHookScriptConfig.
type RestHookScriptConfig struct {
	Scope *struct {
		ResourceId *int32                         `json:"resourceId,omitempty"`
		Type       *RestHookScriptConfigScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
	Script *struct {
		CreatedDate *time.Time                      `json:"createdDate,omitempty"`
		Description *string                         `json:"description,omitempty"`
		Id          *int64                          `json:"id,omitempty"`
		Name        *string                         `json:"name,omitempty"`
		PluginKey   *string                         `json:"pluginKey,omitempty"`
		Type        *RestHookScriptConfigScriptType `json:"type,omitempty"`
		UpdatedDate *time.Time                      `json:"updatedDate,omitempty"`
		Version     *int32                          `json:"version,omitempty"`
	} `json:"script,omitempty"`
	TriggerIds *[]string `json:"triggerIds,omitempty"`
}

// RestHookScriptConfigScopeType defines model for RestHookScriptConfig.Scope.Type.
type RestHookScriptConfigScopeType string

// RestHookScriptConfigScriptType defines model for RestHookScriptConfig.Script.Type.
type RestHookScriptConfigScriptType string

// RestHookScriptTriggers defines model for RestHookScriptTriggers.
type RestHookScriptTriggers struct {
	TriggerIds *[]string `json:"triggerIds,omitempty"`
}

// RestImportRequest defines model for RestImportRequest.
type RestImportRequest struct {
	ArchivePath *string `json:"archivePath,omitempty"`
}

// RestInsightAnnotation defines model for RestInsightAnnotation.
type RestInsightAnnotation struct {
	ExternalId *string `json:"externalId,omitempty"`
	Line       *int32  `json:"line,omitempty"`
	Link       *string `json:"link,omitempty"`
	Message    *string `json:"message,omitempty"`
	Path       *string `json:"path,omitempty"`
	ReportKey  *string `json:"reportKey,omitempty"`
	Severity   *string `json:"severity,omitempty"`
	Type       *string `json:"type,omitempty"`
}

// RestInsightAnnotationsResponse defines model for RestInsightAnnotationsResponse.
type RestInsightAnnotationsResponse struct {
	Annotations *[]RestInsightAnnotation `json:"annotations,omitempty"`
}

// RestInsightReport defines model for RestInsightReport.
type RestInsightReport struct {
	CreatedDate *float32                 `json:"createdDate,omitempty"`
	Data        *[]RestInsightReportData `json:"data,omitempty"`
	Details     *string                  `json:"details,omitempty"`
	Key         *string                  `json:"key,omitempty"`
	Link        *string                  `json:"link,omitempty"`
	LogoUrl     *string                  `json:"logoUrl,omitempty"`
	Reporter    *string                  `json:"reporter,omitempty"`
	Result      *RestInsightReportResult `json:"result,omitempty"`
	Title       *string                  `json:"title,omitempty"`
}

// RestInsightReportResult defines model for RestInsightReport.Result.
type RestInsightReportResult string

// RestInsightReportData defines model for RestInsightReportData.
type RestInsightReportData struct {
	Title *string                 `json:"title,omitempty"`
	Type  *string                 `json:"type,omitempty"`
	Value *map[string]interface{} `json:"value,omitempty"`
}

// RestInvocationHistory defines model for RestInvocationHistory.
type RestInvocationHistory = interface{}

// RestJiraIssue defines model for RestJiraIssue.
type RestJiraIssue struct {
	Key *string `json:"key,omitempty"`
	Url *string `json:"url,omitempty"`
}

// RestJob defines model for RestJob.
type RestJob struct {
	EndDate   *int64 `json:"endDate,omitempty"`
	Id        *int64 `json:"id,omitempty"`
	Initiator *struct {
		Active       *bool                   `json:"active,omitempty"`
		AvatarUrl    *string                 `json:"avatarUrl,omitempty"`
		DisplayName  *string                 `json:"displayName,omitempty"`
		EmailAddress *string                 `json:"emailAddress,omitempty"`
		Id           *int32                  `json:"id,omitempty"`
		Links        *map[string]interface{} `json:"links,omitempty"`
		Name         *string                 `json:"name,omitempty"`
		Slug         *string                 `json:"slug,omitempty"`
		Type         *RestJobInitiatorType   `json:"type,omitempty"`
	} `json:"initiator,omitempty"`
	NodeId   *string `json:"nodeId,omitempty"`
	Progress *struct {
		Message    *string `json:"message,omitempty"`
		Percentage *int32  `json:"percentage,omitempty"`
	} `json:"progress,omitempty"`
	StartDate   *int64        `json:"startDate,omitempty"`
	State       *RestJobState `json:"state,omitempty"`
	Type        *string       `json:"type,omitempty"`
	UpdatedDate *int64        `json:"updatedDate,omitempty"`
}

// RestJobInitiatorType defines model for RestJob.Initiator.Type.
type RestJobInitiatorType string

// RestJobState defines model for RestJob.State.
type RestJobState string

// RestJobMessage defines model for RestJobMessage.
type RestJobMessage struct {
	CreatedDate *time.Time              `json:"createdDate,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Severity    *RestJobMessageSeverity `json:"severity,omitempty"`
	Subject     *string                 `json:"subject,omitempty"`
	Text        *string                 `json:"text,omitempty"`
}

// RestJobMessageSeverity defines model for RestJobMessage.Severity.
type RestJobMessageSeverity string

// RestLabel defines model for RestLabel.
type RestLabel struct {
	Name *string `json:"name,omitempty"`
}

// RestLabelable defines model for RestLabelable.
type RestLabelable struct {
	Archived      *bool                       `json:"archived,omitempty"`
	DefaultBranch *string                     `json:"defaultBranch,omitempty"`
	Description   *string                     `json:"description,omitempty"`
	Forkable      *bool                       `json:"forkable,omitempty"`
	HierarchyId   *string                     `json:"hierarchyId,omitempty"`
	Id            *int32                      `json:"id,omitempty"`
	LabelableType *RestLabelableLabelableType `json:"labelableType,omitempty"`
	Links         *map[string]interface{}     `json:"links,omitempty"`
	Name          *string                     `json:"name,omitempty"`
	Origin        *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Partition     *int32                  `json:"partition,omitempty"`
		Project       *struct {
			Avatar      *string                         `json:"avatar,omitempty"`
			AvatarUrl   *string                         `json:"avatarUrl,omitempty"`
			Description *string                         `json:"description,omitempty"`
			Id          *int32                          `json:"id,omitempty"`
			Key         string                          `json:"key"`
			Links       *map[string]interface{}         `json:"links,omitempty"`
			Name        *string                         `json:"name,omitempty"`
			Public      *bool                           `json:"public,omitempty"`
			Scope       *string                         `json:"scope,omitempty"`
			Type        *RestLabelableOriginProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                     `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}   `json:"relatedLinks,omitempty"`
		ScmId         *string                   `json:"scmId,omitempty"`
		Scope         *string                   `json:"scope,omitempty"`
		Slug          *string                   `json:"slug,omitempty"`
		State         *RestLabelableOriginState `json:"state,omitempty"`
		StatusMessage *string                   `json:"statusMessage,omitempty"`
	} `json:"origin,omitempty"`
	Partition *int32 `json:"partition,omitempty"`
	Project   *struct {
		Avatar      *string                   `json:"avatar,omitempty"`
		AvatarUrl   *string                   `json:"avatarUrl,omitempty"`
		Description *string                   `json:"description,omitempty"`
		Id          *int32                    `json:"id,omitempty"`
		Key         string                    `json:"key"`
		Links       *map[string]interface{}   `json:"links,omitempty"`
		Name        *string                   `json:"name,omitempty"`
		Public      *bool                     `json:"public,omitempty"`
		Scope       *string                   `json:"scope,omitempty"`
		Type        *RestLabelableProjectType `json:"type,omitempty"`
	} `json:"project,omitempty"`
	Public        *bool                   `json:"public,omitempty"`
	RelatedLinks  *map[string]interface{} `json:"relatedLinks,omitempty"`
	ScmId         *string                 `json:"scmId,omitempty"`
	Scope         *string                 `json:"scope,omitempty"`
	Slug          *string                 `json:"slug,omitempty"`
	State         *RestLabelableState     `json:"state,omitempty"`
	StatusMessage *string                 `json:"statusMessage,omitempty"`
}

// RestLabelableLabelableType defines model for RestLabelable.LabelableType.
type RestLabelableLabelableType string

// RestLabelableOriginProjectType defines model for RestLabelable.Origin.Project.Type.
type RestLabelableOriginProjectType string

// RestLabelableOriginState defines model for RestLabelable.Origin.State.
type RestLabelableOriginState string

// RestLabelableProjectType defines model for RestLabelable.Project.Type.
type RestLabelableProjectType string

// RestLabelableState defines model for RestLabelable.State.
type RestLabelableState string

// RestLogLevel defines model for RestLogLevel.
type RestLogLevel struct {
	LogLevel *string `json:"logLevel,omitempty"`
}

// RestMailConfiguration defines model for RestMailConfiguration.
type RestMailConfiguration struct {
	Hostname        *string                        `json:"hostname,omitempty"`
	Password        *string                        `json:"password,omitempty"`
	Port            *int32                         `json:"port,omitempty"`
	Protocol        *RestMailConfigurationProtocol `json:"protocol,omitempty"`
	RequireStartTls *bool                          `json:"requireStartTls,omitempty"`
	SenderAddress   *string                        `json:"senderAddress,omitempty"`
	UseStartTls     *bool                          `json:"useStartTls,omitempty"`
	Username        *string                        `json:"username,omitempty"`
}

// RestMailConfigurationProtocol defines model for RestMailConfiguration.Protocol.
type RestMailConfigurationProtocol string

// RestMarkup defines model for RestMarkup.
type RestMarkup struct {
	Html *string `json:"html,omitempty"`
}

// RestMeshConnectivityReport defines model for RestMeshConnectivityReport.
type RestMeshConnectivityReport struct {
	Reports *[]RestNodeConnectivityReport `json:"reports,omitempty"`
}

// RestMeshMigrationRequest defines model for RestMeshMigrationRequest.
type RestMeshMigrationRequest struct {
	All               *bool `json:"all,omitempty"`
	MaxBytesPerSecond *struct {
		AsLong  *int64 `json:"asLong,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"maxBytesPerSecond,omitempty"`
	ProjectIds    *[]int32 `json:"projectIds,omitempty"`
	RepositoryIds *[]int32 `json:"repositoryIds,omitempty"`
}

// RestMeshMigrationSummary defines model for RestMeshMigrationSummary.
type RestMeshMigrationSummary struct {
	EndTime      *int64                  `json:"endTime,omitempty"`
	JobId        *int64                  `json:"jobId,omitempty"`
	MaxBandwidth *int64                  `json:"maxBandwidth,omitempty"`
	Progress     *int32                  `json:"progress,omitempty"`
	Queue        *map[string]interface{} `json:"queue,omitempty"`
	StartTime    *int64                  `json:"startTime,omitempty"`
	State        *string                 `json:"state,omitempty"`
}

// RestMeshNode defines model for RestMeshNode.
type RestMeshNode struct {
	AvailabilityZone *string            `json:"availabilityZone,omitempty"`
	Id               *string            `json:"id,omitempty"`
	LastSeenDate     *float32           `json:"lastSeenDate,omitempty"`
	Name             *string            `json:"name,omitempty"`
	Offline          *bool              `json:"offline,omitempty"`
	RpcId            *string            `json:"rpcId,omitempty"`
	RpcUrl           *string            `json:"rpcUrl,omitempty"`
	State            *RestMeshNodeState `json:"state,omitempty"`
}

// RestMeshNodeState defines model for RestMeshNode.State.
type RestMeshNodeState string

// RestMigrationRepository defines model for RestMigrationRepository.
type RestMigrationRepository struct {
	MigrationState *RestMigrationRepositoryMigrationState `json:"migrationState,omitempty"`
	Repository     *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                             `json:"avatar,omitempty"`
				AvatarUrl   *string                                             `json:"avatarUrl,omitempty"`
				Description *string                                             `json:"description,omitempty"`
				Id          *int32                                              `json:"id,omitempty"`
				Key         string                                              `json:"key"`
				Links       *map[string]interface{}                             `json:"links,omitempty"`
				Name        *string                                             `json:"name,omitempty"`
				Public      *bool                                               `json:"public,omitempty"`
				Scope       *string                                             `json:"scope,omitempty"`
				Type        *RestMigrationRepositoryRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                         `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}                       `json:"relatedLinks,omitempty"`
			ScmId         *string                                       `json:"scmId,omitempty"`
			Scope         *string                                       `json:"scope,omitempty"`
			Slug          *string                                       `json:"slug,omitempty"`
			State         *RestMigrationRepositoryRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                                       `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                                       `json:"avatar,omitempty"`
			AvatarUrl   *string                                       `json:"avatarUrl,omitempty"`
			Description *string                                       `json:"description,omitempty"`
			Id          *int32                                        `json:"id,omitempty"`
			Key         string                                        `json:"key"`
			Links       *map[string]interface{}                       `json:"links,omitempty"`
			Name        *string                                       `json:"name,omitempty"`
			Public      *bool                                         `json:"public,omitempty"`
			Scope       *string                                       `json:"scope,omitempty"`
			Type        *RestMigrationRepositoryRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                                   `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}                 `json:"relatedLinks,omitempty"`
		ScmId         *string                                 `json:"scmId,omitempty"`
		Scope         *string                                 `json:"scope,omitempty"`
		Slug          *string                                 `json:"slug,omitempty"`
		State         *RestMigrationRepositoryRepositoryState `json:"state,omitempty"`
		StatusMessage *string                                 `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
}

// RestMigrationRepositoryMigrationState defines model for RestMigrationRepository.MigrationState.
type RestMigrationRepositoryMigrationState string

// RestMigrationRepositoryRepositoryOriginProjectType defines model for RestMigrationRepository.Repository.Origin.Project.Type.
type RestMigrationRepositoryRepositoryOriginProjectType string

// RestMigrationRepositoryRepositoryOriginState defines model for RestMigrationRepository.Repository.Origin.State.
type RestMigrationRepositoryRepositoryOriginState string

// RestMigrationRepositoryRepositoryProjectType defines model for RestMigrationRepository.Repository.Project.Type.
type RestMigrationRepositoryRepositoryProjectType string

// RestMigrationRepositoryRepositoryState defines model for RestMigrationRepository.Repository.State.
type RestMigrationRepositoryRepositoryState string

// RestMinimalCommit defines model for RestMinimalCommit.
type RestMinimalCommit struct {
	DisplayId *string `json:"displayId,omitempty"`
	Id        *string `json:"id,omitempty"`
}

// RestMinimalRef defines model for RestMinimalRef.
type RestMinimalRef struct {
	DisplayId *string             `json:"displayId,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Type      *RestMinimalRefType `json:"type,omitempty"`
}

// RestMinimalRefType defines model for RestMinimalRef.Type.
type RestMinimalRefType string

// RestMirrorRepositorySynchronizationStatus defines model for RestMirrorRepositorySynchronizationStatus.
type RestMirrorRepositorySynchronizationStatus struct {
	ExternalRepoId  *string `json:"externalRepoId,omitempty"`
	FailedSyncCount *int32  `json:"failedSyncCount,omitempty"`
	Hashes          *struct {
		Content  *string `json:"content,omitempty"`
		Metadata *string `json:"metadata,omitempty"`
	} `json:"hashes,omitempty"`
	InitialSyncDate *time.Time `json:"initialSyncDate,omitempty"`
	LastSyncDate    *time.Time `json:"lastSyncDate,omitempty"`
	LocalProjectId  *int32     `json:"localProjectId,omitempty"`
	LocalRepoId     *int32     `json:"localRepoId,omitempty"`
	UpstreamId      *string    `json:"upstreamId,omitempty"`
}

// RestMirrorServer defines model for RestMirrorServer.
type RestMirrorServer struct {
	BaseUrl        *string                     `json:"baseUrl,omitempty"`
	Enabled        *bool                       `json:"enabled,omitempty"`
	Id             *string                     `json:"id,omitempty"`
	LastSeenDate   *time.Time                  `json:"lastSeenDate,omitempty"`
	MirrorType     *RestMirrorServerMirrorType `json:"mirrorType,omitempty"`
	Name           *string                     `json:"name,omitempty"`
	ProductVersion *string                     `json:"productVersion,omitempty"`
}

// RestMirrorServerMirrorType defines model for RestMirrorServer.MirrorType.
type RestMirrorServerMirrorType string

// RestMirrorUpgradeRequest defines model for RestMirrorUpgradeRequest.
type RestMirrorUpgradeRequest struct {
	BaseUrl        *string `json:"baseUrl,omitempty"`
	ProductVersion *string `json:"productVersion,omitempty"`
}

// RestMirroredRepository defines model for RestMirroredRepository.
type RestMirroredRepository struct {
	Available    *bool                         `json:"available,omitempty"`
	CloneUrls    *[]RestNamedLink              `json:"cloneUrls,omitempty"`
	LastUpdated  *time.Time                    `json:"lastUpdated,omitempty"`
	MirrorName   *string                       `json:"mirrorName,omitempty"`
	PushUrls     *[]RestNamedLink              `json:"pushUrls,omitempty"`
	RepositoryId *string                       `json:"repositoryId,omitempty"`
	Status       *RestMirroredRepositoryStatus `json:"status,omitempty"`
}

// RestMirroredRepositoryStatus defines model for RestMirroredRepository.Status.
type RestMirroredRepositoryStatus string

// RestMirroredRepositoryDescriptor defines model for RestMirroredRepositoryDescriptor.
type RestMirroredRepositoryDescriptor struct {
	Links        *map[string]interface{} `json:"links,omitempty"`
	MirrorServer *struct {
		BaseUrl        *string                                                 `json:"baseUrl,omitempty"`
		Enabled        *bool                                                   `json:"enabled,omitempty"`
		Id             *string                                                 `json:"id,omitempty"`
		LastSeenDate   time.Time                                               `json:"lastSeenDate"`
		MirrorType     *RestMirroredRepositoryDescriptorMirrorServerMirrorType `json:"mirrorType,omitempty"`
		Name           *string                                                 `json:"name,omitempty"`
		ProductVersion *string                                                 `json:"productVersion,omitempty"`
	} `json:"mirrorServer,omitempty"`
}

// RestMirroredRepositoryDescriptorMirrorServerMirrorType defines model for RestMirroredRepositoryDescriptor.MirrorServer.MirrorType.
type RestMirroredRepositoryDescriptorMirrorServerMirrorType string

// RestMirroringRequest defines model for RestMirroringRequest.
type RestMirroringRequest struct {
	Id             *int32                          `json:"id,omitempty"`
	MirrorBaseUrl  *string                         `json:"mirrorBaseUrl,omitempty"`
	MirrorId       *string                         `json:"mirrorId,omitempty"`
	MirrorName     *string                         `json:"mirrorName,omitempty"`
	MirrorType     *RestMirroringRequestMirrorType `json:"mirrorType,omitempty"`
	ProductVersion *string                         `json:"productVersion,omitempty"`
	State          *RestMirroringRequestState      `json:"state,omitempty"`
}

// RestMirroringRequestMirrorType defines model for RestMirroringRequest.MirrorType.
type RestMirroringRequestMirrorType string

// RestMirroringRequestState defines model for RestMirroringRequest.State.
type RestMirroringRequestState string

// RestMultipleBuildStats defines model for RestMultipleBuildStats.
type RestMultipleBuildStats = interface{}

// RestNamedLink defines model for RestNamedLink.
type RestNamedLink struct {
	Href *string `json:"href,omitempty"`
	Name *string `json:"name,omitempty"`
}

// RestNodeConnectivityReport defines model for RestNodeConnectivityReport.
type RestNodeConnectivityReport struct {
	Node *struct {
		Id   *string                             `json:"id,omitempty"`
		Name *string                             `json:"name,omitempty"`
		Type *RestNodeConnectivityReportNodeType `json:"type,omitempty"`
	} `json:"node,omitempty"`
	Summaries *[]RestNodeConnectivitySummary `json:"summaries,omitempty"`
}

// RestNodeConnectivityReportNodeType defines model for RestNodeConnectivityReport.Node.Type.
type RestNodeConnectivityReportNodeType string

// RestNodeConnectivitySummary defines model for RestNodeConnectivitySummary.
type RestNodeConnectivitySummary struct {
	Node *struct {
		Id   *string                              `json:"id,omitempty"`
		Name *string                              `json:"name,omitempty"`
		Type *RestNodeConnectivitySummaryNodeType `json:"type,omitempty"`
	} `json:"node,omitempty"`
	Summary *struct {
		ErrorMessage  *string `json:"errorMessage,omitempty"`
		Reachable     *bool   `json:"reachable,omitempty"`
		RoundTripTime *int64  `json:"roundTripTime,omitempty"`
	} `json:"summary,omitempty"`
}

// RestNodeConnectivitySummaryNodeType defines model for RestNodeConnectivitySummary.Node.Type.
type RestNodeConnectivitySummaryNodeType string

// RestPermitted defines model for RestPermitted.
type RestPermitted struct {
	Permitted *bool `json:"permitted,omitempty"`
}

// RestPermittedGroup defines model for RestPermittedGroup.
type RestPermittedGroup struct {
	Group *struct {
		Name *string `json:"name,omitempty"`
	} `json:"group,omitempty"`
	Permission *string `json:"permission,omitempty"`
}

// RestPermittedUser defines model for RestPermittedUser.
type RestPermittedUser struct {
	Permission *RestPermittedUserPermission `json:"permission,omitempty"`
	User       *struct {
		Active       *bool                      `json:"active,omitempty"`
		AvatarUrl    *string                    `json:"avatarUrl,omitempty"`
		DisplayName  *string                    `json:"displayName,omitempty"`
		EmailAddress *string                    `json:"emailAddress,omitempty"`
		Id           *int32                     `json:"id,omitempty"`
		Links        *map[string]interface{}    `json:"links,omitempty"`
		Name         *string                    `json:"name,omitempty"`
		Slug         *string                    `json:"slug,omitempty"`
		Type         *RestPermittedUserUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestPermittedUserPermission defines model for RestPermittedUser.Permission.
type RestPermittedUserPermission string

// RestPermittedUserUserType defines model for RestPermittedUser.User.Type.
type RestPermittedUserUserType string

// RestProject defines model for RestProject.
type RestProject struct {
	Avatar      *string                 `json:"avatar,omitempty"`
	AvatarUrl   *string                 `json:"avatarUrl,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Id          *int32                  `json:"id,omitempty"`
	Key         *string                 `json:"key,omitempty"`
	Links       *map[string]interface{} `json:"links,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Public      *bool                   `json:"public,omitempty"`
	Scope       *string                 `json:"scope,omitempty"`
	Type        *RestProjectType        `json:"type,omitempty"`
}

// RestProjectType defines model for RestProject.Type.
type RestProjectType string

// RestProjectSettingsRestriction defines model for RestProjectSettingsRestriction.
type RestProjectSettingsRestriction struct {
	ComponentKey   *string                                       `json:"componentKey,omitempty"`
	FeatureKey     *string                                       `json:"featureKey,omitempty"`
	Namespace      *string                                       `json:"namespace,omitempty"`
	ProcessedState *RestProjectSettingsRestrictionProcessedState `json:"processedState,omitempty"`
	Project        *struct {
		Avatar      *string                                    `json:"avatar,omitempty"`
		AvatarUrl   *string                                    `json:"avatarUrl,omitempty"`
		Description *string                                    `json:"description,omitempty"`
		Id          *int32                                     `json:"id,omitempty"`
		Key         string                                     `json:"key"`
		Links       *map[string]interface{}                    `json:"links,omitempty"`
		Name        *string                                    `json:"name,omitempty"`
		Public      *bool                                      `json:"public,omitempty"`
		Scope       *string                                    `json:"scope,omitempty"`
		Type        *RestProjectSettingsRestrictionProjectType `json:"type,omitempty"`
	} `json:"project,omitempty"`
}

// RestProjectSettingsRestrictionProcessedState defines model for RestProjectSettingsRestriction.ProcessedState.
type RestProjectSettingsRestrictionProcessedState string

// RestProjectSettingsRestrictionProjectType defines model for RestProjectSettingsRestriction.Project.Type.
type RestProjectSettingsRestrictionProjectType string

// RestProjectSettingsRestrictionRequest defines model for RestProjectSettingsRestrictionRequest.
type RestProjectSettingsRestrictionRequest struct {
	ComponentKey *string `json:"componentKey,omitempty"`
	FeatureKey   string  `json:"featureKey"`
	Namespace    string  `json:"namespace"`
}

// RestPullRequest defines model for RestPullRequest.
type RestPullRequest struct {
	Closed            *bool   `json:"closed,omitempty"`
	ClosedDate        *int64  `json:"closedDate,omitempty"`
	CreatedDate       *int64  `json:"createdDate,omitempty"`
	Description       *string `json:"description,omitempty"`
	DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
	Draft             *bool   `json:"draft,omitempty"`
	FromRef           *struct {
		DisplayId    *string `json:"displayId,omitempty"`
		Id           *string `json:"id,omitempty"`
		LatestCommit *string `json:"latestCommit,omitempty"`
		Repository   *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Origin        *struct {
				Archived      *bool                   `json:"archived,omitempty"`
				DefaultBranch *string                 `json:"defaultBranch,omitempty"`
				Description   *string                 `json:"description,omitempty"`
				Forkable      *bool                   `json:"forkable,omitempty"`
				HierarchyId   *string                 `json:"hierarchyId,omitempty"`
				Id            *int32                  `json:"id,omitempty"`
				Links         *map[string]interface{} `json:"links,omitempty"`
				Name          *string                 `json:"name,omitempty"`
				Partition     *int32                  `json:"partition,omitempty"`
				Project       *struct {
					Avatar      *string                                            `json:"avatar,omitempty"`
					AvatarUrl   *string                                            `json:"avatarUrl,omitempty"`
					Description *string                                            `json:"description,omitempty"`
					Id          *int32                                             `json:"id,omitempty"`
					Key         string                                             `json:"key"`
					Links       *map[string]interface{}                            `json:"links,omitempty"`
					Name        *string                                            `json:"name,omitempty"`
					Public      *bool                                              `json:"public,omitempty"`
					Scope       *string                                            `json:"scope,omitempty"`
					Type        *RestPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
				} `json:"project,omitempty"`
				Public        *bool                                        `json:"public,omitempty"`
				RelatedLinks  *map[string]interface{}                      `json:"relatedLinks,omitempty"`
				ScmId         *string                                      `json:"scmId,omitempty"`
				Scope         *string                                      `json:"scope,omitempty"`
				Slug          *string                                      `json:"slug,omitempty"`
				State         *RestPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
				StatusMessage *string                                      `json:"statusMessage,omitempty"`
			} `json:"origin,omitempty"`
			Partition *int32 `json:"partition,omitempty"`
			Project   *struct {
				Avatar      *string                                      `json:"avatar,omitempty"`
				AvatarUrl   *string                                      `json:"avatarUrl,omitempty"`
				Description *string                                      `json:"description,omitempty"`
				Id          *int32                                       `json:"id,omitempty"`
				Key         string                                       `json:"key"`
				Links       *map[string]interface{}                      `json:"links,omitempty"`
				Name        *string                                      `json:"name,omitempty"`
				Public      *bool                                        `json:"public,omitempty"`
				Scope       *string                                      `json:"scope,omitempty"`
				Type        *RestPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                  `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}                `json:"relatedLinks,omitempty"`
			ScmId         *string                                `json:"scmId,omitempty"`
			Scope         *string                                `json:"scope,omitempty"`
			Slug          *string                                `json:"slug,omitempty"`
			State         *RestPullRequestFromRefRepositoryState `json:"state,omitempty"`
			StatusMessage *string                                `json:"statusMessage,omitempty"`
		} `json:"repository,omitempty"`
		Type *RestPullRequestFromRefType `json:"type,omitempty"`
	} `json:"fromRef,omitempty"`
	HtmlDescription *string                       `json:"htmlDescription,omitempty"`
	Id              *int64                        `json:"id,omitempty"`
	Links           *map[string]interface{}       `json:"links,omitempty"`
	Locked          *bool                         `json:"locked,omitempty"`
	Open            *bool                         `json:"open,omitempty"`
	Participants    *[]RestPullRequestParticipant `json:"participants,omitempty"`
	Reviewers       *[]RestPullRequestParticipant `json:"reviewers,omitempty"`
	State           *RestPullRequestState         `json:"state,omitempty"`
	Title           *string                       `json:"title,omitempty"`
	ToRef           *struct {
		DisplayId    *string `json:"displayId,omitempty"`
		Id           *string `json:"id,omitempty"`
		LatestCommit *string `json:"latestCommit,omitempty"`
		Repository   *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Origin        *struct {
				Archived      *bool                   `json:"archived,omitempty"`
				DefaultBranch *string                 `json:"defaultBranch,omitempty"`
				Description   *string                 `json:"description,omitempty"`
				Forkable      *bool                   `json:"forkable,omitempty"`
				HierarchyId   *string                 `json:"hierarchyId,omitempty"`
				Id            *int32                  `json:"id,omitempty"`
				Links         *map[string]interface{} `json:"links,omitempty"`
				Name          *string                 `json:"name,omitempty"`
				Partition     *int32                  `json:"partition,omitempty"`
				Project       *struct {
					Avatar      *string                                          `json:"avatar,omitempty"`
					AvatarUrl   *string                                          `json:"avatarUrl,omitempty"`
					Description *string                                          `json:"description,omitempty"`
					Id          *int32                                           `json:"id,omitempty"`
					Key         string                                           `json:"key"`
					Links       *map[string]interface{}                          `json:"links,omitempty"`
					Name        *string                                          `json:"name,omitempty"`
					Public      *bool                                            `json:"public,omitempty"`
					Scope       *string                                          `json:"scope,omitempty"`
					Type        *RestPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
				} `json:"project,omitempty"`
				Public        *bool                                      `json:"public,omitempty"`
				RelatedLinks  *map[string]interface{}                    `json:"relatedLinks,omitempty"`
				ScmId         *string                                    `json:"scmId,omitempty"`
				Scope         *string                                    `json:"scope,omitempty"`
				Slug          *string                                    `json:"slug,omitempty"`
				State         *RestPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
				StatusMessage *string                                    `json:"statusMessage,omitempty"`
			} `json:"origin,omitempty"`
			Partition *int32 `json:"partition,omitempty"`
			Project   *struct {
				Avatar      *string                                    `json:"avatar,omitempty"`
				AvatarUrl   *string                                    `json:"avatarUrl,omitempty"`
				Description *string                                    `json:"description,omitempty"`
				Id          *int32                                     `json:"id,omitempty"`
				Key         string                                     `json:"key"`
				Links       *map[string]interface{}                    `json:"links,omitempty"`
				Name        *string                                    `json:"name,omitempty"`
				Public      *bool                                      `json:"public,omitempty"`
				Scope       *string                                    `json:"scope,omitempty"`
				Type        *RestPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}              `json:"relatedLinks,omitempty"`
			ScmId         *string                              `json:"scmId,omitempty"`
			Scope         *string                              `json:"scope,omitempty"`
			Slug          *string                              `json:"slug,omitempty"`
			State         *RestPullRequestToRefRepositoryState `json:"state,omitempty"`
			StatusMessage *string                              `json:"statusMessage,omitempty"`
		} `json:"repository,omitempty"`
		Type *RestPullRequestToRefType `json:"type,omitempty"`
	} `json:"toRef,omitempty"`
	UpdatedDate *int64 `json:"updatedDate,omitempty"`
	Version     *int32 `json:"version,omitempty"`
}

// RestPullRequestFromRefRepositoryOriginProjectType defines model for RestPullRequest.FromRef.Repository.Origin.Project.Type.
type RestPullRequestFromRefRepositoryOriginProjectType string

// RestPullRequestFromRefRepositoryOriginState defines model for RestPullRequest.FromRef.Repository.Origin.State.
type RestPullRequestFromRefRepositoryOriginState string

// RestPullRequestFromRefRepositoryProjectType defines model for RestPullRequest.FromRef.Repository.Project.Type.
type RestPullRequestFromRefRepositoryProjectType string

// RestPullRequestFromRefRepositoryState defines model for RestPullRequest.FromRef.Repository.State.
type RestPullRequestFromRefRepositoryState string

// RestPullRequestFromRefType defines model for RestPullRequest.FromRef.Type.
type RestPullRequestFromRefType string

// RestPullRequestState defines model for RestPullRequest.State.
type RestPullRequestState string

// RestPullRequestToRefRepositoryOriginProjectType defines model for RestPullRequest.ToRef.Repository.Origin.Project.Type.
type RestPullRequestToRefRepositoryOriginProjectType string

// RestPullRequestToRefRepositoryOriginState defines model for RestPullRequest.ToRef.Repository.Origin.State.
type RestPullRequestToRefRepositoryOriginState string

// RestPullRequestToRefRepositoryProjectType defines model for RestPullRequest.ToRef.Repository.Project.Type.
type RestPullRequestToRefRepositoryProjectType string

// RestPullRequestToRefRepositoryState defines model for RestPullRequest.ToRef.Repository.State.
type RestPullRequestToRefRepositoryState string

// RestPullRequestToRefType defines model for RestPullRequest.ToRef.Type.
type RestPullRequestToRefType string

// RestPullRequestActivity defines model for RestPullRequestActivity.
type RestPullRequestActivity struct {
	Action      *RestPullRequestActivityAction `json:"action,omitempty"`
	CreatedDate *int64                         `json:"createdDate,omitempty"`
	Id          *int64                         `json:"id,omitempty"`
	User        *struct {
		Active       *bool                            `json:"active,omitempty"`
		AvatarUrl    *string                          `json:"avatarUrl,omitempty"`
		DisplayName  *string                          `json:"displayName,omitempty"`
		EmailAddress *string                          `json:"emailAddress,omitempty"`
		Id           *int32                           `json:"id,omitempty"`
		Links        *map[string]interface{}          `json:"links,omitempty"`
		Name         *string                          `json:"name,omitempty"`
		Slug         *string                          `json:"slug,omitempty"`
		Type         *RestPullRequestActivityUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestPullRequestActivityAction defines model for RestPullRequestActivity.Action.
type RestPullRequestActivityAction string

// RestPullRequestActivityUserType defines model for RestPullRequestActivity.User.Type.
type RestPullRequestActivityUserType string

// RestPullRequestAssignParticipantRoleRequest defines model for RestPullRequestAssignParticipantRoleRequest.
type RestPullRequestAssignParticipantRoleRequest struct {
	Role *RestPullRequestAssignParticipantRoleRequestRole `json:"role,omitempty"`
	User *struct {
		Active       *bool                                                `json:"active,omitempty"`
		AvatarUrl    *string                                              `json:"avatarUrl,omitempty"`
		DisplayName  *string                                              `json:"displayName,omitempty"`
		EmailAddress *string                                              `json:"emailAddress,omitempty"`
		Id           *int32                                               `json:"id,omitempty"`
		Links        *map[string]interface{}                              `json:"links,omitempty"`
		Name         *string                                              `json:"name,omitempty"`
		Slug         *string                                              `json:"slug,omitempty"`
		Type         *RestPullRequestAssignParticipantRoleRequestUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestPullRequestAssignParticipantRoleRequestRole defines model for RestPullRequestAssignParticipantRoleRequest.Role.
type RestPullRequestAssignParticipantRoleRequestRole string

// RestPullRequestAssignParticipantRoleRequestUserType defines model for RestPullRequestAssignParticipantRoleRequest.User.Type.
type RestPullRequestAssignParticipantRoleRequestUserType string

// RestPullRequestAssignStatusRequest defines model for RestPullRequestAssignStatusRequest.
type RestPullRequestAssignStatusRequest struct {
	LastReviewedCommit *string                                   `json:"lastReviewedCommit,omitempty"`
	Status             *RestPullRequestAssignStatusRequestStatus `json:"status,omitempty"`
}

// RestPullRequestAssignStatusRequestStatus defines model for RestPullRequestAssignStatusRequest.Status.
type RestPullRequestAssignStatusRequestStatus string

// RestPullRequestCondition defines model for RestPullRequestCondition.
type RestPullRequestCondition struct {
	Id                *int32                 `json:"id,omitempty"`
	RequiredApprovals *int32                 `json:"requiredApprovals,omitempty"`
	Reviewers         *[]RestApplicationUser `json:"reviewers,omitempty"`
	Scope             *struct {
		ResourceId *int32                             `json:"resourceId,omitempty"`
		Type       *RestPullRequestConditionScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
	SourceRefMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestPullRequestConditionSourceRefMatcherTypeId `json:"id,omitempty"`
			Name *string                                         `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"sourceRefMatcher,omitempty"`
	TargetRefMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestPullRequestConditionTargetRefMatcherTypeId `json:"id,omitempty"`
			Name *string                                         `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"targetRefMatcher,omitempty"`
}

// RestPullRequestConditionScopeType defines model for RestPullRequestCondition.Scope.Type.
type RestPullRequestConditionScopeType string

// RestPullRequestConditionSourceRefMatcherTypeId defines model for RestPullRequestCondition.SourceRefMatcher.Type.Id.
type RestPullRequestConditionSourceRefMatcherTypeId string

// RestPullRequestConditionTargetRefMatcherTypeId defines model for RestPullRequestCondition.TargetRefMatcher.Type.Id.
type RestPullRequestConditionTargetRefMatcherTypeId string

// RestPullRequestDeclineRequest defines model for RestPullRequestDeclineRequest.
type RestPullRequestDeclineRequest struct {
	Comment *string `json:"comment,omitempty"`
	Version *int32  `json:"version,omitempty"`
}

// RestPullRequestDeleteRequest defines model for RestPullRequestDeleteRequest.
type RestPullRequestDeleteRequest struct {
	Version *int32 `json:"version,omitempty"`
}

// RestPullRequestFinishReviewRequest defines model for RestPullRequestFinishReviewRequest.
type RestPullRequestFinishReviewRequest struct {
	CommentText        *string `json:"commentText,omitempty"`
	LastReviewedCommit *string `json:"lastReviewedCommit,omitempty"`
	ParticipantStatus  *string `json:"participantStatus,omitempty"`
}

// RestPullRequestMergeConfig defines model for RestPullRequestMergeConfig.
type RestPullRequestMergeConfig struct {
	CommitMessageTemplate *struct {
		Body  *string `json:"body,omitempty"`
		Title *string `json:"title,omitempty"`
	} `json:"commitMessageTemplate,omitempty"`
	CommitSummaries *int32 `json:"commitSummaries,omitempty"`
	DefaultStrategy *struct {
		Description *string                 `json:"description,omitempty"`
		Enabled     *bool                   `json:"enabled,omitempty"`
		Flag        *string                 `json:"flag,omitempty"`
		Id          *string                 `json:"id,omitempty"`
		Links       *map[string]interface{} `json:"links,omitempty"`
		Name        *string                 `json:"name,omitempty"`
	} `json:"defaultStrategy,omitempty"`
	Strategies *[]RestPullRequestMergeStrategy `json:"strategies,omitempty"`
	Type       *string                         `json:"type,omitempty"`
}

// RestPullRequestMergeRequest defines model for RestPullRequestMergeRequest.
type RestPullRequestMergeRequest struct {
	AutoMerge   *bool   `json:"autoMerge,omitempty"`
	AutoSubject *string `json:"autoSubject,omitempty"`
	Message     *string `json:"message,omitempty"`
	StrategyId  *string `json:"strategyId,omitempty"`
	Version     *int32  `json:"version,omitempty"`
}

// RestPullRequestMergeStrategy defines model for RestPullRequestMergeStrategy.
type RestPullRequestMergeStrategy struct {
	Description *string                 `json:"description,omitempty"`
	Enabled     *bool                   `json:"enabled,omitempty"`
	Flag        *string                 `json:"flag,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Links       *map[string]interface{} `json:"links,omitempty"`
	Name        *string                 `json:"name,omitempty"`
}

// RestPullRequestMergeability defines model for RestPullRequestMergeability.
type RestPullRequestMergeability struct {
	Conflicted *bool                               `json:"conflicted,omitempty"`
	Outcome    *RestPullRequestMergeabilityOutcome `json:"outcome,omitempty"`
	Vetoes     *[]RestRepositoryHookVeto           `json:"vetoes,omitempty"`
}

// RestPullRequestMergeabilityOutcome defines model for RestPullRequestMergeability.Outcome.
type RestPullRequestMergeabilityOutcome string

// RestPullRequestParticipant defines model for RestPullRequestParticipant.
type RestPullRequestParticipant struct {
	Approved           *bool                             `json:"approved,omitempty"`
	LastReviewedCommit *string                           `json:"lastReviewedCommit,omitempty"`
	Role               *RestPullRequestParticipantRole   `json:"role,omitempty"`
	Status             *RestPullRequestParticipantStatus `json:"status,omitempty"`
	User               *struct {
		Active       *bool                               `json:"active,omitempty"`
		AvatarUrl    *string                             `json:"avatarUrl,omitempty"`
		DisplayName  *string                             `json:"displayName,omitempty"`
		EmailAddress *string                             `json:"emailAddress,omitempty"`
		Id           *int32                              `json:"id,omitempty"`
		Links        *map[string]interface{}             `json:"links,omitempty"`
		Name         *string                             `json:"name,omitempty"`
		Slug         *string                             `json:"slug,omitempty"`
		Type         *RestPullRequestParticipantUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestPullRequestParticipantRole defines model for RestPullRequestParticipant.Role.
type RestPullRequestParticipantRole string

// RestPullRequestParticipantStatus defines model for RestPullRequestParticipant.Status.
type RestPullRequestParticipantStatus string

// RestPullRequestParticipantUserType defines model for RestPullRequestParticipant.User.Type.
type RestPullRequestParticipantUserType string

// RestPullRequestRebaseRequest defines model for RestPullRequestRebaseRequest.
type RestPullRequestRebaseRequest struct {
	Version *int32 `json:"version,omitempty"`
}

// RestPullRequestRebaseResult defines model for RestPullRequestRebaseResult.
type RestPullRequestRebaseResult struct {
	RefChange *struct {
		FromHash *string `json:"fromHash,omitempty"`
		Ref      *struct {
			DisplayId *string                                      `json:"displayId,omitempty"`
			Id        *string                                      `json:"id,omitempty"`
			Type      *RestPullRequestRebaseResultRefChangeRefType `json:"type,omitempty"`
		} `json:"ref,omitempty"`
		RefId  *string                                   `json:"refId,omitempty"`
		ToHash *string                                   `json:"toHash,omitempty"`
		Type   *RestPullRequestRebaseResultRefChangeType `json:"type,omitempty"`
	} `json:"refChange,omitempty"`
}

// RestPullRequestRebaseResultRefChangeRefType defines model for RestPullRequestRebaseResult.RefChange.Ref.Type.
type RestPullRequestRebaseResultRefChangeRefType string

// RestPullRequestRebaseResultRefChangeType defines model for RestPullRequestRebaseResult.RefChange.Type.
type RestPullRequestRebaseResultRefChangeType string

// RestPullRequestRebaseability defines model for RestPullRequestRebaseability.
type RestPullRequestRebaseability struct {
	Vetoes *[]RestRepositoryHookVeto `json:"vetoes,omitempty"`
}

// RestPullRequestReopenRequest defines model for RestPullRequestReopenRequest.
type RestPullRequestReopenRequest struct {
	Version *int32 `json:"version,omitempty"`
}

// RestPullRequestSettings defines model for RestPullRequestSettings.
type RestPullRequestSettings struct {
	MergeConfig *struct {
		CommitMessageTemplate *struct {
			Body  *string `json:"body,omitempty"`
			Title *string `json:"title,omitempty"`
		} `json:"commitMessageTemplate,omitempty"`
		CommitSummaries *int32 `json:"commitSummaries,omitempty"`
		DefaultStrategy *struct {
			Description *string                 `json:"description,omitempty"`
			Enabled     *bool                   `json:"enabled,omitempty"`
			Flag        *string                 `json:"flag,omitempty"`
			Id          *string                 `json:"id,omitempty"`
			Links       *map[string]interface{} `json:"links,omitempty"`
			Name        *string                 `json:"name,omitempty"`
		} `json:"defaultStrategy,omitempty"`
		Strategies *[]RestPullRequestMergeStrategy `json:"strategies,omitempty"`
		Type       *string                         `json:"type,omitempty"`
	} `json:"mergeConfig,omitempty"`
}

// RestPullRequestSuggestion defines model for RestPullRequestSuggestion.
type RestPullRequestSuggestion struct {
	ChangeTme *int64 `json:"changeTme,omitempty"`
	FromRef   *struct {
		DisplayId *string                               `json:"displayId,omitempty"`
		Id        *string                               `json:"id,omitempty"`
		Type      *RestPullRequestSuggestionFromRefType `json:"type,omitempty"`
	} `json:"fromRef,omitempty"`
	RefChange *struct {
		FromHash *string `json:"fromHash,omitempty"`
		Ref      *struct {
			DisplayId *string                                    `json:"displayId,omitempty"`
			Id        *string                                    `json:"id,omitempty"`
			Type      *RestPullRequestSuggestionRefChangeRefType `json:"type,omitempty"`
		} `json:"ref,omitempty"`
		RefId  *string                                 `json:"refId,omitempty"`
		ToHash *string                                 `json:"toHash,omitempty"`
		Type   *RestPullRequestSuggestionRefChangeType `json:"type,omitempty"`
	} `json:"refChange,omitempty"`
	Repository *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                               `json:"avatar,omitempty"`
				AvatarUrl   *string                                               `json:"avatarUrl,omitempty"`
				Description *string                                               `json:"description,omitempty"`
				Id          *int32                                                `json:"id,omitempty"`
				Key         string                                                `json:"key"`
				Links       *map[string]interface{}                               `json:"links,omitempty"`
				Name        *string                                               `json:"name,omitempty"`
				Public      *bool                                                 `json:"public,omitempty"`
				Scope       *string                                               `json:"scope,omitempty"`
				Type        *RestPullRequestSuggestionRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                           `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}                         `json:"relatedLinks,omitempty"`
			ScmId         *string                                         `json:"scmId,omitempty"`
			Scope         *string                                         `json:"scope,omitempty"`
			Slug          *string                                         `json:"slug,omitempty"`
			State         *RestPullRequestSuggestionRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                                         `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                                         `json:"avatar,omitempty"`
			AvatarUrl   *string                                         `json:"avatarUrl,omitempty"`
			Description *string                                         `json:"description,omitempty"`
			Id          *int32                                          `json:"id,omitempty"`
			Key         string                                          `json:"key"`
			Links       *map[string]interface{}                         `json:"links,omitempty"`
			Name        *string                                         `json:"name,omitempty"`
			Public      *bool                                           `json:"public,omitempty"`
			Scope       *string                                         `json:"scope,omitempty"`
			Type        *RestPullRequestSuggestionRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                                     `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}                   `json:"relatedLinks,omitempty"`
		ScmId         *string                                   `json:"scmId,omitempty"`
		Scope         *string                                   `json:"scope,omitempty"`
		Slug          *string                                   `json:"slug,omitempty"`
		State         *RestPullRequestSuggestionRepositoryState `json:"state,omitempty"`
		StatusMessage *string                                   `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
	ToRef *struct {
		DisplayId *string                             `json:"displayId,omitempty"`
		Id        *string                             `json:"id,omitempty"`
		Type      *RestPullRequestSuggestionToRefType `json:"type,omitempty"`
	} `json:"toRef,omitempty"`
}

// RestPullRequestSuggestionFromRefType defines model for RestPullRequestSuggestion.FromRef.Type.
type RestPullRequestSuggestionFromRefType string

// RestPullRequestSuggestionRefChangeRefType defines model for RestPullRequestSuggestion.RefChange.Ref.Type.
type RestPullRequestSuggestionRefChangeRefType string

// RestPullRequestSuggestionRefChangeType defines model for RestPullRequestSuggestion.RefChange.Type.
type RestPullRequestSuggestionRefChangeType string

// RestPullRequestSuggestionRepositoryOriginProjectType defines model for RestPullRequestSuggestion.Repository.Origin.Project.Type.
type RestPullRequestSuggestionRepositoryOriginProjectType string

// RestPullRequestSuggestionRepositoryOriginState defines model for RestPullRequestSuggestion.Repository.Origin.State.
type RestPullRequestSuggestionRepositoryOriginState string

// RestPullRequestSuggestionRepositoryProjectType defines model for RestPullRequestSuggestion.Repository.Project.Type.
type RestPullRequestSuggestionRepositoryProjectType string

// RestPullRequestSuggestionRepositoryState defines model for RestPullRequestSuggestion.Repository.State.
type RestPullRequestSuggestionRepositoryState string

// RestPullRequestSuggestionToRefType defines model for RestPullRequestSuggestion.ToRef.Type.
type RestPullRequestSuggestionToRefType string

// RestRateLimitSettings defines model for RestRateLimitSettings.
type RestRateLimitSettings struct {
	DefaultSettings *struct {
		Capacity *int32 `json:"capacity,omitempty"`
		FillRate *int32 `json:"fillRate,omitempty"`
	} `json:"defaultSettings,omitempty"`
	Enabled *bool `json:"enabled,omitempty"`
}

// RestRawAccessToken defines model for RestRawAccessToken.
type RestRawAccessToken struct {
	CreatedDate *time.Time `json:"createdDate,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Token       *string    `json:"token,omitempty"`
}

// RestRefMatcher defines model for RestRefMatcher.
type RestRefMatcher struct {
	DisplayId *string `json:"displayId,omitempty"`
	Id        *string `json:"id,omitempty"`
	Type      *struct {
		Id   *RestRefMatcherTypeId `json:"id,omitempty"`
		Name *string               `json:"name,omitempty"`
	} `json:"type,omitempty"`
}

// RestRefMatcherTypeId defines model for RestRefMatcher.Type.Id.
type RestRefMatcherTypeId string

// RestRefRestriction defines model for RestRefRestriction.
type RestRefRestriction struct {
	AccessKeys *[]RestSshAccessKey `json:"accessKeys,omitempty"`
	Groups     *[]string           `json:"groups,omitempty"`
	Id         *int32              `json:"id,omitempty"`
	Matcher    *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestRefRestrictionMatcherTypeId `json:"id,omitempty"`
			Name *string                          `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"matcher,omitempty"`
	Scope *struct {
		ResourceId *int32                       `json:"resourceId,omitempty"`
		Type       *RestRefRestrictionScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
	Type  *string                `json:"type,omitempty"`
	Users *[]RestApplicationUser `json:"users,omitempty"`
}

// RestRefRestrictionMatcherTypeId defines model for RestRefRestriction.Matcher.Type.Id.
type RestRefRestrictionMatcherTypeId string

// RestRefRestrictionScopeType defines model for RestRefRestriction.Scope.Type.
type RestRefRestrictionScopeType string

// RestRefSyncQueue defines model for RestRefSyncQueue.
type RestRefSyncQueue struct {
	Values *[]RestFarmSynchronizationRequest `json:"values,omitempty"`
}

// RestRefSyncRequest defines model for RestRefSyncRequest.
type RestRefSyncRequest struct {
	Action  *RestRefSyncRequestAction `json:"action,omitempty"`
	Context *Context                  `json:"context,omitempty"`
	RefId   *string                   `json:"refId,omitempty"`
}

// RestRefSyncRequestAction defines model for RestRefSyncRequest.Action.
type RestRefSyncRequestAction string

// RestRefSyncStatus defines model for RestRefSyncStatus.
type RestRefSyncStatus struct {
	AheadRefs *struct {
		DisplayId *string                          `json:"displayId,omitempty"`
		Id        *string                          `json:"id,omitempty"`
		State     *RestRefSyncStatusAheadRefsState `json:"state,omitempty"`
		Tag       *bool                            `json:"tag,omitempty"`
		Type      *RestRefSyncStatusAheadRefsType  `json:"type,omitempty"`
	} `json:"aheadRefs,omitempty"`
	Available    *bool `json:"available,omitempty"`
	DivergedRefs *struct {
		DisplayId *string                             `json:"displayId,omitempty"`
		Id        *string                             `json:"id,omitempty"`
		State     *RestRefSyncStatusDivergedRefsState `json:"state,omitempty"`
		Tag       *bool                               `json:"tag,omitempty"`
		Type      *RestRefSyncStatusDivergedRefsType  `json:"type,omitempty"`
	} `json:"divergedRefs,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	LastSync     *float32 `json:"lastSync,omitempty"`
	OrphanedRefs *struct {
		DisplayId *string                             `json:"displayId,omitempty"`
		Id        *string                             `json:"id,omitempty"`
		State     *RestRefSyncStatusOrphanedRefsState `json:"state,omitempty"`
		Tag       *bool                               `json:"tag,omitempty"`
		Type      *RestRefSyncStatusOrphanedRefsType  `json:"type,omitempty"`
	} `json:"orphanedRefs,omitempty"`
}

// RestRefSyncStatusAheadRefsState defines model for RestRefSyncStatus.AheadRefs.State.
type RestRefSyncStatusAheadRefsState string

// RestRefSyncStatusAheadRefsType defines model for RestRefSyncStatus.AheadRefs.Type.
type RestRefSyncStatusAheadRefsType string

// RestRefSyncStatusDivergedRefsState defines model for RestRefSyncStatus.DivergedRefs.State.
type RestRefSyncStatusDivergedRefsState string

// RestRefSyncStatusDivergedRefsType defines model for RestRefSyncStatus.DivergedRefs.Type.
type RestRefSyncStatusDivergedRefsType string

// RestRefSyncStatusOrphanedRefsState defines model for RestRefSyncStatus.OrphanedRefs.State.
type RestRefSyncStatusOrphanedRefsState string

// RestRefSyncStatusOrphanedRefsType defines model for RestRefSyncStatus.OrphanedRefs.Type.
type RestRefSyncStatusOrphanedRefsType string

// RestRejectedRef defines model for RestRejectedRef.
type RestRejectedRef struct {
	DisplayId *string               `json:"displayId,omitempty"`
	Id        *string               `json:"id,omitempty"`
	State     *RestRejectedRefState `json:"state,omitempty"`
	Tag       *bool                 `json:"tag,omitempty"`
	Type      *RestRejectedRefType  `json:"type,omitempty"`
}

// RestRejectedRefState defines model for RestRejectedRef.State.
type RestRejectedRefState string

// RestRejectedRefType defines model for RestRejectedRef.Type.
type RestRejectedRefType string

// RestRepository defines model for RestRepository.
type RestRepository struct {
	Archived      *bool                   `json:"archived,omitempty"`
	DefaultBranch *string                 `json:"defaultBranch,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	Forkable      *bool                   `json:"forkable,omitempty"`
	HierarchyId   *string                 `json:"hierarchyId,omitempty"`
	Id            *int32                  `json:"id,omitempty"`
	Links         *map[string]interface{} `json:"links,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Origin        *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Partition     *int32                  `json:"partition,omitempty"`
		Project       *struct {
			Avatar      *string                          `json:"avatar,omitempty"`
			AvatarUrl   *string                          `json:"avatarUrl,omitempty"`
			Description *string                          `json:"description,omitempty"`
			Id          *int32                           `json:"id,omitempty"`
			Key         string                           `json:"key"`
			Links       *map[string]interface{}          `json:"links,omitempty"`
			Name        *string                          `json:"name,omitempty"`
			Public      *bool                            `json:"public,omitempty"`
			Scope       *string                          `json:"scope,omitempty"`
			Type        *RestRepositoryOriginProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                      `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}    `json:"relatedLinks,omitempty"`
		ScmId         *string                    `json:"scmId,omitempty"`
		Scope         *string                    `json:"scope,omitempty"`
		Slug          *string                    `json:"slug,omitempty"`
		State         *RestRepositoryOriginState `json:"state,omitempty"`
		StatusMessage *string                    `json:"statusMessage,omitempty"`
	} `json:"origin,omitempty"`
	Partition *int32 `json:"partition,omitempty"`
	Project   *struct {
		Avatar      *string                    `json:"avatar,omitempty"`
		AvatarUrl   *string                    `json:"avatarUrl,omitempty"`
		Description *string                    `json:"description,omitempty"`
		Id          *int32                     `json:"id,omitempty"`
		Key         string                     `json:"key"`
		Links       *map[string]interface{}    `json:"links,omitempty"`
		Name        *string                    `json:"name,omitempty"`
		Public      *bool                      `json:"public,omitempty"`
		Scope       *string                    `json:"scope,omitempty"`
		Type        *RestRepositoryProjectType `json:"type,omitempty"`
	} `json:"project,omitempty"`
	Public        *bool                   `json:"public,omitempty"`
	RelatedLinks  *map[string]interface{} `json:"relatedLinks,omitempty"`
	ScmId         *string                 `json:"scmId,omitempty"`
	Scope         *string                 `json:"scope,omitempty"`
	Slug          *string                 `json:"slug,omitempty"`
	State         *RestRepositoryState    `json:"state,omitempty"`
	StatusMessage *string                 `json:"statusMessage,omitempty"`
}

// RestRepositoryOriginProjectType defines model for RestRepository.Origin.Project.Type.
type RestRepositoryOriginProjectType string

// RestRepositoryOriginState defines model for RestRepository.Origin.State.
type RestRepositoryOriginState string

// RestRepositoryProjectType defines model for RestRepository.Project.Type.
type RestRepositoryProjectType string

// RestRepositoryState defines model for RestRepository.State.
type RestRepositoryState string

// RestRepositoryHook defines model for RestRepositoryHook.
type RestRepositoryHook struct {
	Configured *bool                  `json:"configured,omitempty"`
	Details    *RepositoryHookDetails `json:"details,omitempty"`
	Enabled    *bool                  `json:"enabled,omitempty"`
	Scope      *struct {
		ResourceId *int32                       `json:"resourceId,omitempty"`
		Type       *RestRepositoryHookScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
}

// RestRepositoryHookScopeType defines model for RestRepositoryHook.Scope.Type.
type RestRepositoryHookScopeType string

// RestRepositoryHookVeto defines model for RestRepositoryHookVeto.
type RestRepositoryHookVeto struct {
	DetailedMessage *string `json:"detailedMessage,omitempty"`
	SummaryMessage  *string `json:"summaryMessage,omitempty"`
}

// RestRepositoryLockOwner defines model for RestRepositoryLockOwner.
type RestRepositoryLockOwner struct {
	// ExternalRepositoryId The repository ID for which the lock is held
	ExternalRepositoryId *string `json:"externalRepositoryId,omitempty"`

	// LockAcquireTime The time at which lock was last acquired
	LockAcquireTime *time.Time `json:"lockAcquireTime,omitempty"`

	// NodeId The ID of the mirror node on which the lock is being held
	NodeId *string `json:"nodeId,omitempty"`

	// RequestId The unique ID of the request for which the lock is being held
	RequestId *string `json:"requestId,omitempty"`

	// ThreadName Name of the thread that is holding the lock
	ThreadName *string `json:"threadName,omitempty"`
}

// RestRepositoryMirrorEvent defines model for RestRepositoryMirrorEvent.
type RestRepositoryMirrorEvent struct {
	MirrorRepoId   *int32                         `json:"mirrorRepoId,omitempty"`
	Type           *RestRepositoryMirrorEventType `json:"type,omitempty"`
	UpstreamRepoId *string                        `json:"upstreamRepoId,omitempty"`
}

// RestRepositoryMirrorEventType defines model for RestRepositoryMirrorEvent.Type.
type RestRepositoryMirrorEventType string

// RestRepositoryPolicy defines model for RestRepositoryPolicy.
type RestRepositoryPolicy struct {
	// Permission The permission required to delete repositories. Must be one of: "SYS_ADMIN", "ADMIN", "PROJECT_ADMIN", "REPO_ADMIN".
	Permission *RestRepositoryPolicyPermission `json:"permission,omitempty"`
}

// RestRepositoryPolicyPermission The permission required to delete repositories. Must be one of: "SYS_ADMIN", "ADMIN", "PROJECT_ADMIN", "REPO_ADMIN".
type RestRepositoryPolicyPermission string

// RestRepositoryPullRequestSettings defines model for RestRepositoryPullRequestSettings.
type RestRepositoryPullRequestSettings struct {
	MergeConfig *struct {
		CommitMessageTemplate *struct {
			Body  *string `json:"body,omitempty"`
			Title *string `json:"title,omitempty"`
		} `json:"commitMessageTemplate,omitempty"`
		CommitSummaries *int32 `json:"commitSummaries,omitempty"`
		DefaultStrategy *struct {
			Description *string                 `json:"description,omitempty"`
			Enabled     *bool                   `json:"enabled,omitempty"`
			Flag        *string                 `json:"flag,omitempty"`
			Id          *string                 `json:"id,omitempty"`
			Links       *map[string]interface{} `json:"links,omitempty"`
			Name        *string                 `json:"name,omitempty"`
		} `json:"defaultStrategy,omitempty"`
		Strategies *[]RestPullRequestMergeStrategy `json:"strategies,omitempty"`
		Type       *string                         `json:"type,omitempty"`
	} `json:"mergeConfig,omitempty"`
	RequiredAllApprovers     *bool `json:"requiredAllApprovers,omitempty"`
	RequiredAllTasksComplete *bool `json:"requiredAllTasksComplete,omitempty"`
	RequiredApprovers        *struct {
		Count   *string `json:"count,omitempty"`
		Enabled *bool   `json:"enabled,omitempty"`
	} `json:"requiredApprovers,omitempty"`
	RequiredApproversDeprecated *int32 `json:"requiredApproversDeprecated,omitempty"`
	RequiredSuccessfulBuilds    *struct {
		Count   *string `json:"count,omitempty"`
		Enabled *bool   `json:"enabled,omitempty"`
	} `json:"requiredSuccessfulBuilds,omitempty"`
	RequiredSuccessfulBuildsDeprecated *int32 `json:"requiredSuccessfulBuildsDeprecated,omitempty"`
}

// RestRepositoryRefChangeActivity defines model for RestRepositoryRefChangeActivity.
type RestRepositoryRefChangeActivity struct {
	CreatedDate *int64 `json:"createdDate,omitempty"`
	Id          *int64 `json:"id,omitempty"`
	RefChange   *struct {
		FromHash *string `json:"fromHash,omitempty"`
		Ref      *struct {
			DisplayId *string                                          `json:"displayId,omitempty"`
			Id        *string                                          `json:"id,omitempty"`
			Type      *RestRepositoryRefChangeActivityRefChangeRefType `json:"type,omitempty"`
		} `json:"ref,omitempty"`
		RefId       *string                                              `json:"refId,omitempty"`
		ToHash      *string                                              `json:"toHash,omitempty"`
		Type        *RestRepositoryRefChangeActivityRefChangeType        `json:"type,omitempty"`
		UpdatedType *RestRepositoryRefChangeActivityRefChangeUpdatedType `json:"updatedType,omitempty"`
	} `json:"refChange,omitempty"`
	Repository *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                                     `json:"avatar,omitempty"`
				AvatarUrl   *string                                                     `json:"avatarUrl,omitempty"`
				Description *string                                                     `json:"description,omitempty"`
				Id          *int32                                                      `json:"id,omitempty"`
				Key         string                                                      `json:"key"`
				Links       *map[string]interface{}                                     `json:"links,omitempty"`
				Name        *string                                                     `json:"name,omitempty"`
				Public      *bool                                                       `json:"public,omitempty"`
				Scope       *string                                                     `json:"scope,omitempty"`
				Type        *RestRepositoryRefChangeActivityRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                                 `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}                               `json:"relatedLinks,omitempty"`
			ScmId         *string                                               `json:"scmId,omitempty"`
			Scope         *string                                               `json:"scope,omitempty"`
			Slug          *string                                               `json:"slug,omitempty"`
			State         *RestRepositoryRefChangeActivityRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                                               `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                                               `json:"avatar,omitempty"`
			AvatarUrl   *string                                               `json:"avatarUrl,omitempty"`
			Description *string                                               `json:"description,omitempty"`
			Id          *int32                                                `json:"id,omitempty"`
			Key         string                                                `json:"key"`
			Links       *map[string]interface{}                               `json:"links,omitempty"`
			Name        *string                                               `json:"name,omitempty"`
			Public      *bool                                                 `json:"public,omitempty"`
			Scope       *string                                               `json:"scope,omitempty"`
			Type        *RestRepositoryRefChangeActivityRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                                           `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}                         `json:"relatedLinks,omitempty"`
		ScmId         *string                                         `json:"scmId,omitempty"`
		Scope         *string                                         `json:"scope,omitempty"`
		Slug          *string                                         `json:"slug,omitempty"`
		State         *RestRepositoryRefChangeActivityRepositoryState `json:"state,omitempty"`
		StatusMessage *string                                         `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
	Trigger *string `json:"trigger,omitempty"`
	User    *struct {
		Active       *bool                                    `json:"active,omitempty"`
		AvatarUrl    *string                                  `json:"avatarUrl,omitempty"`
		DisplayName  *string                                  `json:"displayName,omitempty"`
		EmailAddress *string                                  `json:"emailAddress,omitempty"`
		Id           *int32                                   `json:"id,omitempty"`
		Links        *map[string]interface{}                  `json:"links,omitempty"`
		Name         *string                                  `json:"name,omitempty"`
		Slug         *string                                  `json:"slug,omitempty"`
		Type         *RestRepositoryRefChangeActivityUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestRepositoryRefChangeActivityRefChangeRefType defines model for RestRepositoryRefChangeActivity.RefChange.Ref.Type.
type RestRepositoryRefChangeActivityRefChangeRefType string

// RestRepositoryRefChangeActivityRefChangeType defines model for RestRepositoryRefChangeActivity.RefChange.Type.
type RestRepositoryRefChangeActivityRefChangeType string

// RestRepositoryRefChangeActivityRefChangeUpdatedType defines model for RestRepositoryRefChangeActivity.RefChange.UpdatedType.
type RestRepositoryRefChangeActivityRefChangeUpdatedType string

// RestRepositoryRefChangeActivityRepositoryOriginProjectType defines model for RestRepositoryRefChangeActivity.Repository.Origin.Project.Type.
type RestRepositoryRefChangeActivityRepositoryOriginProjectType string

// RestRepositoryRefChangeActivityRepositoryOriginState defines model for RestRepositoryRefChangeActivity.Repository.Origin.State.
type RestRepositoryRefChangeActivityRepositoryOriginState string

// RestRepositoryRefChangeActivityRepositoryProjectType defines model for RestRepositoryRefChangeActivity.Repository.Project.Type.
type RestRepositoryRefChangeActivityRepositoryProjectType string

// RestRepositoryRefChangeActivityRepositoryState defines model for RestRepositoryRefChangeActivity.Repository.State.
type RestRepositoryRefChangeActivityRepositoryState string

// RestRepositoryRefChangeActivityUserType defines model for RestRepositoryRefChangeActivity.User.Type.
type RestRepositoryRefChangeActivityUserType string

// RestRepositorySelector defines model for RestRepositorySelector.
type RestRepositorySelector struct {
	ProjectKey *string `json:"projectKey,omitempty"`
	Slug       *string `json:"slug,omitempty"`
}

// RestRequiredBuildCondition defines model for RestRequiredBuildCondition.
type RestRequiredBuildCondition struct {
	// BuildParentKeys A non-empty list of build parent keys that require green builds for this merge check to pass
	BuildParentKeys  *[]string `json:"buildParentKeys,omitempty"`
	ExemptRefMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestRequiredBuildConditionExemptRefMatcherTypeId `json:"id,omitempty"`
			Name *string                                           `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"exemptRefMatcher,omitempty"`
	Id         *int64 `json:"id,omitempty"`
	RefMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestRequiredBuildConditionRefMatcherTypeId `json:"id,omitempty"`
			Name *string                                     `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"refMatcher,omitempty"`
}

// RestRequiredBuildConditionExemptRefMatcherTypeId defines model for RestRequiredBuildCondition.ExemptRefMatcher.Type.Id.
type RestRequiredBuildConditionExemptRefMatcherTypeId string

// RestRequiredBuildConditionRefMatcherTypeId defines model for RestRequiredBuildCondition.RefMatcher.Type.Id.
type RestRequiredBuildConditionRefMatcherTypeId string

// RestRequiredBuildConditionSetRequest defines model for RestRequiredBuildConditionSetRequest.
type RestRequiredBuildConditionSetRequest struct {
	// BuildParentKeys A non-empty list of build parent keys that require green builds for this merge check to pass
	BuildParentKeys  []string `json:"buildParentKeys"`
	ExemptRefMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId `json:"id,omitempty"`
			Name *string                                                     `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"exemptRefMatcher,omitempty"`
	RefMatcher RestRefMatcher `json:"refMatcher"`
}

// RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId defines model for RestRequiredBuildConditionSetRequest.ExemptRefMatcher.Type.Id.
type RestRequiredBuildConditionSetRequestExemptRefMatcherTypeId string

// RestRestrictionRequest defines model for RestRestrictionRequest.
type RestRestrictionRequest struct {
	AccessKeyIds *[]int32            `json:"accessKeyIds,omitempty"`
	AccessKeys   *[]RestSshAccessKey `json:"accessKeys,omitempty"`
	GroupNames   *[]string           `json:"groupNames,omitempty"`
	Groups       *[]string           `json:"groups,omitempty"`
	Id           *int32              `json:"id,omitempty"`
	Matcher      *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *RestRestrictionRequestMatcherTypeId `json:"id,omitempty"`
			Name *string                              `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"matcher,omitempty"`
	Scope *struct {
		ResourceId *int32                           `json:"resourceId,omitempty"`
		Type       *RestRestrictionRequestScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
	Type      *string                `json:"type,omitempty"`
	UserSlugs *[]string              `json:"userSlugs,omitempty"`
	Users     *[]RestApplicationUser `json:"users,omitempty"`
}

// RestRestrictionRequestMatcherTypeId defines model for RestRestrictionRequest.Matcher.Type.Id.
type RestRestrictionRequestMatcherTypeId string

// RestRestrictionRequestScopeType defines model for RestRestrictionRequest.Scope.Type.
type RestRestrictionRequestScopeType string

// RestReviewerGroup defines model for RestReviewerGroup.
type RestReviewerGroup struct {
	AvatarUrl   *string `json:"avatarUrl,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *int64  `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Scope       *struct {
		ResourceId *int32                      `json:"resourceId,omitempty"`
		Type       *RestReviewerGroupScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
	Users *[]ApplicationUser `json:"users,omitempty"`
}

// RestReviewerGroupScopeType defines model for RestReviewerGroup.Scope.Type.
type RestReviewerGroupScopeType string

// RestRollingUpgradeState defines model for RestRollingUpgradeState.
type RestRollingUpgradeState struct {
	RollingUpgradeEnabled *bool   `json:"rollingUpgradeEnabled,omitempty"`
	Version               *string `json:"version,omitempty"`
}

// RestScopesExample defines model for RestScopesExample.
type RestScopesExample struct {
	Links  *map[string]interface{}   `json:"links,omitempty"`
	Scopes *[]map[string]interface{} `json:"scopes,omitempty"`
}

// RestSecretScanningAllowlistRule defines model for RestSecretScanningAllowlistRule.
type RestSecretScanningAllowlistRule struct {
	// Id The ID of the rule
	Id *int64 `json:"id,omitempty"`

	// LineRegex If present, regular expression for matching a secret on a code line
	LineRegex *string `json:"lineRegex,omitempty"`

	// Name Human readable name for the rule
	Name *string `json:"name,omitempty"`

	// PathRegex If present, regular expression matching file names
	PathRegex *string `json:"pathRegex,omitempty"`
}

// RestSecretScanningAllowlistRuleSetRequest defines model for RestSecretScanningAllowlistRuleSetRequest.
type RestSecretScanningAllowlistRuleSetRequest struct {
	// LineRegex Regular expression for matching a secret on a code line
	LineRegex *string `json:"lineRegex,omitempty"`

	// Name Human readable name for the rule
	Name *string `json:"name,omitempty"`

	// PathRegex Regular expression matching file names
	PathRegex *string `json:"pathRegex,omitempty"`
}

// RestSecretScanningRule defines model for RestSecretScanningRule.
type RestSecretScanningRule struct {
	// Id The ID of the rule
	Id *int64 `json:"id,omitempty"`

	// LineRegex If present, regular expression for matching a secret on a code line
	LineRegex *string `json:"lineRegex,omitempty"`

	// Name Human readable name for the rule
	Name *string `json:"name,omitempty"`

	// PathRegex If present, regular expression matching file names
	PathRegex *string `json:"pathRegex,omitempty"`

	// Scope The scope in which this rule was configured for.
	Scope *struct {
		ResourceId *int32                           `json:"resourceId,omitempty"`
		Type       *RestSecretScanningRuleScopeType `json:"type,omitempty"`
	} `json:"scope,omitempty"`
}

// RestSecretScanningRuleScopeType defines model for RestSecretScanningRule.Scope.Type.
type RestSecretScanningRuleScopeType string

// RestSecretScanningRuleSetRequest defines model for RestSecretScanningRuleSetRequest.
type RestSecretScanningRuleSetRequest struct {
	// LineRegex Regular expression for matching a secret on a code line
	LineRegex *string `json:"lineRegex,omitempty"`

	// Name Human readable name for the rule
	Name *string `json:"name,omitempty"`

	// PathRegex Regular expression matching file names
	PathRegex *string `json:"pathRegex,omitempty"`
}

// RestSetInsightReportRequest defines model for RestSetInsightReportRequest.
type RestSetInsightReportRequest struct {
	CoverageProviderKey *string                 `json:"coverageProviderKey,omitempty"`
	CreatedDate         *int64                  `json:"createdDate,omitempty"`
	Data                []RestInsightReportData `json:"data"`
	Details             *string                 `json:"details,omitempty"`
	Link                *string                 `json:"link,omitempty"`
	LogoUrl             *string                 `json:"logoUrl,omitempty"`
	Reporter            *string                 `json:"reporter,omitempty"`
	Result              *string                 `json:"result,omitempty"`
	Title               string                  `json:"title"`
}

// RestSingleAddInsightAnnotationRequest defines model for RestSingleAddInsightAnnotationRequest.
type RestSingleAddInsightAnnotationRequest struct {
	ExternalId *string `json:"externalId,omitempty"`
	Line       *int32  `json:"line,omitempty"`
	Link       *string `json:"link,omitempty"`
	Message    string  `json:"message"`
	Path       *string `json:"path,omitempty"`
	Severity   string  `json:"severity"`
	Type       *string `json:"type,omitempty"`
}

// RestSshAccessKey defines model for RestSshAccessKey.
type RestSshAccessKey struct {
	Key *struct {
		AlgorithmType     *string    `json:"algorithmType,omitempty"`
		BitLength         *int32     `json:"bitLength,omitempty"`
		CreatedDate       *time.Time `json:"createdDate,omitempty"`
		ExpiryDays        *int32     `json:"expiryDays,omitempty"`
		Fingerprint       *string    `json:"fingerprint,omitempty"`
		Id                *int32     `json:"id,omitempty"`
		Label             *string    `json:"label,omitempty"`
		LastAuthenticated *string    `json:"lastAuthenticated,omitempty"`
		Text              *string    `json:"text,omitempty"`

		// Warning Contains a warning about the key, for example that it's deprecated
		Warning *string `json:"warning,omitempty"`
	} `json:"key,omitempty"`
	Permission *RestSshAccessKeyPermission `json:"permission,omitempty"`
	Project    *struct {
		Avatar      *string                      `json:"avatar,omitempty"`
		AvatarUrl   *string                      `json:"avatarUrl,omitempty"`
		Description *string                      `json:"description,omitempty"`
		Id          *int32                       `json:"id,omitempty"`
		Key         string                       `json:"key"`
		Links       *map[string]interface{}      `json:"links,omitempty"`
		Name        *string                      `json:"name,omitempty"`
		Public      *bool                        `json:"public,omitempty"`
		Scope       *string                      `json:"scope,omitempty"`
		Type        *RestSshAccessKeyProjectType `json:"type,omitempty"`
	} `json:"project,omitempty"`
	Repository *struct {
		Archived      *bool                   `json:"archived,omitempty"`
		DefaultBranch *string                 `json:"defaultBranch,omitempty"`
		Description   *string                 `json:"description,omitempty"`
		Forkable      *bool                   `json:"forkable,omitempty"`
		HierarchyId   *string                 `json:"hierarchyId,omitempty"`
		Id            *int32                  `json:"id,omitempty"`
		Links         *map[string]interface{} `json:"links,omitempty"`
		Name          *string                 `json:"name,omitempty"`
		Origin        *struct {
			Archived      *bool                   `json:"archived,omitempty"`
			DefaultBranch *string                 `json:"defaultBranch,omitempty"`
			Description   *string                 `json:"description,omitempty"`
			Forkable      *bool                   `json:"forkable,omitempty"`
			HierarchyId   *string                 `json:"hierarchyId,omitempty"`
			Id            *int32                  `json:"id,omitempty"`
			Links         *map[string]interface{} `json:"links,omitempty"`
			Name          *string                 `json:"name,omitempty"`
			Partition     *int32                  `json:"partition,omitempty"`
			Project       *struct {
				Avatar      *string                                      `json:"avatar,omitempty"`
				AvatarUrl   *string                                      `json:"avatarUrl,omitempty"`
				Description *string                                      `json:"description,omitempty"`
				Id          *int32                                       `json:"id,omitempty"`
				Key         string                                       `json:"key"`
				Links       *map[string]interface{}                      `json:"links,omitempty"`
				Name        *string                                      `json:"name,omitempty"`
				Public      *bool                                        `json:"public,omitempty"`
				Scope       *string                                      `json:"scope,omitempty"`
				Type        *RestSshAccessKeyRepositoryOriginProjectType `json:"type,omitempty"`
			} `json:"project,omitempty"`
			Public        *bool                                  `json:"public,omitempty"`
			RelatedLinks  *map[string]interface{}                `json:"relatedLinks,omitempty"`
			ScmId         *string                                `json:"scmId,omitempty"`
			Scope         *string                                `json:"scope,omitempty"`
			Slug          *string                                `json:"slug,omitempty"`
			State         *RestSshAccessKeyRepositoryOriginState `json:"state,omitempty"`
			StatusMessage *string                                `json:"statusMessage,omitempty"`
		} `json:"origin,omitempty"`
		Partition *int32 `json:"partition,omitempty"`
		Project   *struct {
			Avatar      *string                                `json:"avatar,omitempty"`
			AvatarUrl   *string                                `json:"avatarUrl,omitempty"`
			Description *string                                `json:"description,omitempty"`
			Id          *int32                                 `json:"id,omitempty"`
			Key         string                                 `json:"key"`
			Links       *map[string]interface{}                `json:"links,omitempty"`
			Name        *string                                `json:"name,omitempty"`
			Public      *bool                                  `json:"public,omitempty"`
			Scope       *string                                `json:"scope,omitempty"`
			Type        *RestSshAccessKeyRepositoryProjectType `json:"type,omitempty"`
		} `json:"project,omitempty"`
		Public        *bool                            `json:"public,omitempty"`
		RelatedLinks  *map[string]interface{}          `json:"relatedLinks,omitempty"`
		ScmId         *string                          `json:"scmId,omitempty"`
		Scope         *string                          `json:"scope,omitempty"`
		Slug          *string                          `json:"slug,omitempty"`
		State         *RestSshAccessKeyRepositoryState `json:"state,omitempty"`
		StatusMessage *string                          `json:"statusMessage,omitempty"`
	} `json:"repository,omitempty"`
}

// RestSshAccessKeyPermission defines model for RestSshAccessKey.Permission.
type RestSshAccessKeyPermission string

// RestSshAccessKeyProjectType defines model for RestSshAccessKey.Project.Type.
type RestSshAccessKeyProjectType string

// RestSshAccessKeyRepositoryOriginProjectType defines model for RestSshAccessKey.Repository.Origin.Project.Type.
type RestSshAccessKeyRepositoryOriginProjectType string

// RestSshAccessKeyRepositoryOriginState defines model for RestSshAccessKey.Repository.Origin.State.
type RestSshAccessKeyRepositoryOriginState string

// RestSshAccessKeyRepositoryProjectType defines model for RestSshAccessKey.Repository.Project.Type.
type RestSshAccessKeyRepositoryProjectType string

// RestSshAccessKeyRepositoryState defines model for RestSshAccessKey.Repository.State.
type RestSshAccessKeyRepositoryState string

// RestSshCredentials defines model for RestSshCredentials.
type RestSshCredentials struct {
	// Algorithm The key algorithm, if passing in a legacy X.509 encoded key. Do not specify for OpenSSH encoded keys
	Algorithm *string `json:"algorithm,omitempty"`

	// PublicKey The public key text in the OpenSSH format. The algorithm must be specified in case of the legacy X.509 keys
	PublicKey string  `json:"publicKey"`
	Username  *string `json:"username,omitempty"`
}

// RestSshKey defines model for RestSshKey.
type RestSshKey struct {
	AlgorithmType     *string    `json:"algorithmType,omitempty"`
	BitLength         *int32     `json:"bitLength,omitempty"`
	CreatedDate       *time.Time `json:"createdDate,omitempty"`
	ExpiryDays        *int32     `json:"expiryDays,omitempty"`
	Fingerprint       *string    `json:"fingerprint,omitempty"`
	Id                *int32     `json:"id,omitempty"`
	Label             *string    `json:"label,omitempty"`
	LastAuthenticated *string    `json:"lastAuthenticated,omitempty"`
	Text              *string    `json:"text,omitempty"`

	// Warning Contains a warning about the key, for example that it's deprecated
	Warning *string `json:"warning,omitempty"`
}

// RestSshKeySettings defines model for RestSshKeySettings.
type RestSshKeySettings struct {
	KeyTypeRestrictions *[]RestSshKeyTypeRestriction `json:"keyTypeRestrictions,omitempty"`
	MaxExpiryDays       *struct {
		AsInt   *int32 `json:"asInt,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"maxExpiryDays,omitempty"`
}

// RestSshKeyTypeRestriction defines model for RestSshKeyTypeRestriction.
type RestSshKeyTypeRestriction struct {
	Algorithm    *string `json:"algorithm,omitempty"`
	Allowed      *bool   `json:"allowed,omitempty"`
	MinKeyLength *struct {
		AsInt   *int32 `json:"asInt,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"minKeyLength,omitempty"`
}

// RestSshSettings defines model for RestSshSettings.
type RestSshSettings struct {
	AccessKeysEnabled *bool                    `json:"accessKeysEnabled,omitempty"`
	BaseUrl           *string                  `json:"baseUrl,omitempty"`
	Enabled           *bool                    `json:"enabled,omitempty"`
	Fingerprint       *SimpleSshKeyFingerprint `json:"fingerprint,omitempty"`
	Port              *int32                   `json:"port,omitempty"`
}

// RestSyncProgress defines model for RestSyncProgress.
type RestSyncProgress struct {
	Discovering *bool  `json:"discovering,omitempty"`
	SyncedRepos *int32 `json:"syncedRepos,omitempty"`
	TotalRepos  *int32 `json:"totalRepos,omitempty"`
}

// RestSystemSigningConfiguration defines model for RestSystemSigningConfiguration.
type RestSystemSigningConfiguration struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// RestTag defines model for RestTag.
type RestTag struct {
	DisplayId       *string      `json:"displayId,omitempty"`
	Hash            *string      `json:"hash,omitempty"`
	Id              *string      `json:"id,omitempty"`
	LatestChangeset *string      `json:"latestChangeset,omitempty"`
	LatestCommit    *string      `json:"latestCommit,omitempty"`
	Type            *RestTagType `json:"type,omitempty"`
}

// RestTagType defines model for RestTag.Type.
type RestTagType string

// RestUpstreamServer defines model for RestUpstreamServer.
type RestUpstreamServer struct {
	BaseUrl *string                  `json:"baseUrl,omitempty"`
	Id      *string                  `json:"id,omitempty"`
	State   *RestUpstreamServerState `json:"state,omitempty"`
}

// RestUpstreamServerState defines model for RestUpstreamServer.State.
type RestUpstreamServerState string

// RestUpstreamSettings defines model for RestUpstreamSettings.
type RestUpstreamSettings struct {
	Mode       *RestUpstreamSettingsMode `json:"mode,omitempty"`
	ProjectIds *[]string                 `json:"projectIds,omitempty"`
}

// RestUpstreamSettingsMode defines model for RestUpstreamSettings.Mode.
type RestUpstreamSettingsMode string

// RestUserDirectory defines model for RestUserDirectory.
type RestUserDirectory struct {
	Active      *bool   `json:"active,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// RestUserRateLimitSettings defines model for RestUserRateLimitSettings.
type RestUserRateLimitSettings struct {
	Settings *struct {
		Capacity *int32 `json:"capacity,omitempty"`
		FillRate *int32 `json:"fillRate,omitempty"`
	} `json:"settings,omitempty"`
	User *struct {
		Active       *bool                              `json:"active,omitempty"`
		AvatarUrl    *string                            `json:"avatarUrl,omitempty"`
		DisplayName  *string                            `json:"displayName,omitempty"`
		EmailAddress *string                            `json:"emailAddress,omitempty"`
		Id           *int32                             `json:"id,omitempty"`
		Links        *map[string]interface{}            `json:"links,omitempty"`
		Name         *string                            `json:"name,omitempty"`
		Slug         *string                            `json:"slug,omitempty"`
		Type         *RestUserRateLimitSettingsUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
	Whitelisted *bool `json:"whitelisted,omitempty"`
}

// RestUserRateLimitSettingsUserType defines model for RestUserRateLimitSettings.User.Type.
type RestUserRateLimitSettingsUserType string

// RestUserRateLimitSettingsUpdateRequest defines model for RestUserRateLimitSettingsUpdateRequest.
type RestUserRateLimitSettingsUpdateRequest struct {
	Settings *struct {
		Capacity *int32 `json:"capacity,omitempty"`
		FillRate *int32 `json:"fillRate,omitempty"`
	} `json:"settings,omitempty"`
	Whitelisted *bool `json:"whitelisted,omitempty"`
}

// RestUserReaction defines model for RestUserReaction.
type RestUserReaction struct {
	Comment *struct {
		Anchor *struct {
			DiffType        *RestUserReactionCommentAnchorDiffType `json:"diffType,omitempty"`
			FileType        *RestUserReactionCommentAnchorFileType `json:"fileType,omitempty"`
			FromHash        *string                                `json:"fromHash,omitempty"`
			Line            *int32                                 `json:"line,omitempty"`
			LineType        *RestUserReactionCommentAnchorLineType `json:"lineType,omitempty"`
			MultilineMarker *struct {
				// StartLine The line number where the multiline comment will begin
				StartLine *int32 `json:"startLine,omitempty"`

				// StartLineType The segment type of the start line of the multiline comment
				StartLineType RestUserReactionCommentAnchorMultilineMarkerStartLineType `json:"startLineType"`
			} `json:"multilineMarker,omitempty"`
			MultilineSpan *struct {
				// DstSpanEnd The line number of the last line on the right-hand side of the diff that the comment spans
				DstSpanEnd *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"dstSpanEnd,omitempty"`

				// DstSpanStart The line number of the first line on the right-hand side of the diff that the comment spans
				DstSpanStart *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"dstSpanStart,omitempty"`

				// SrcSpanEnd The line number of the last line on the left-hand side of the diff that the comment spans
				SrcSpanEnd *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"srcSpanEnd,omitempty"`

				// SrcSpanStart The line number of the first line on the left-hand side of the diff that the comment spans
				SrcSpanStart *struct {
					AsInt   *int32 `json:"asInt,omitempty"`
					Present *bool  `json:"present,omitempty"`
				} `json:"srcSpanStart,omitempty"`
			} `json:"multilineSpan,omitempty"`
			Path *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"path,omitempty"`
			PullRequest *struct {
				Closed            *bool   `json:"closed,omitempty"`
				ClosedDate        *int64  `json:"closedDate,omitempty"`
				CreatedDate       *int64  `json:"createdDate,omitempty"`
				Description       *string `json:"description,omitempty"`
				DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
				Draft             *bool   `json:"draft,omitempty"`
				FromRef           *struct {
					DisplayId    *string `json:"displayId,omitempty"`
					Id           *string `json:"id,omitempty"`
					LatestCommit *string `json:"latestCommit,omitempty"`
					Repository   *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Origin        *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Partition     *int32                  `json:"partition,omitempty"`
							Project       *struct {
								Avatar      *string                                                                     `json:"avatar,omitempty"`
								AvatarUrl   *string                                                                     `json:"avatarUrl,omitempty"`
								Description *string                                                                     `json:"description,omitempty"`
								Id          *int32                                                                      `json:"id,omitempty"`
								Key         string                                                                      `json:"key"`
								Links       *map[string]interface{}                                                     `json:"links,omitempty"`
								Name        *string                                                                     `json:"name,omitempty"`
								Public      *bool                                                                       `json:"public,omitempty"`
								Scope       *string                                                                     `json:"scope,omitempty"`
								Type        *RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                                 `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                               `json:"relatedLinks,omitempty"`
							ScmId         *string                                                               `json:"scmId,omitempty"`
							Scope         *string                                                               `json:"scope,omitempty"`
							Slug          *string                                                               `json:"slug,omitempty"`
							State         *RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
							StatusMessage *string                                                               `json:"statusMessage,omitempty"`
						} `json:"origin,omitempty"`
						Partition *int32 `json:"partition,omitempty"`
						Project   *struct {
							Avatar      *string                                                               `json:"avatar,omitempty"`
							AvatarUrl   *string                                                               `json:"avatarUrl,omitempty"`
							Description *string                                                               `json:"description,omitempty"`
							Id          *int32                                                                `json:"id,omitempty"`
							Key         string                                                                `json:"key"`
							Links       *map[string]interface{}                                               `json:"links,omitempty"`
							Name        *string                                                               `json:"name,omitempty"`
							Public      *bool                                                                 `json:"public,omitempty"`
							Scope       *string                                                               `json:"scope,omitempty"`
							Type        *RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                           `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                         `json:"relatedLinks,omitempty"`
						ScmId         *string                                                         `json:"scmId,omitempty"`
						Scope         *string                                                         `json:"scope,omitempty"`
						Slug          *string                                                         `json:"slug,omitempty"`
						State         *RestUserReactionCommentAnchorPullRequestFromRefRepositoryState `json:"state,omitempty"`
						StatusMessage *string                                                         `json:"statusMessage,omitempty"`
					} `json:"repository,omitempty"`
					Type *RestUserReactionCommentAnchorPullRequestFromRefType `json:"type,omitempty"`
				} `json:"fromRef,omitempty"`
				HtmlDescription *string                                        `json:"htmlDescription,omitempty"`
				Id              *int64                                         `json:"id,omitempty"`
				Links           *map[string]interface{}                        `json:"links,omitempty"`
				Locked          *bool                                          `json:"locked,omitempty"`
				Open            *bool                                          `json:"open,omitempty"`
				Participants    *[]RestPullRequestParticipant                  `json:"participants,omitempty"`
				Reviewers       *[]RestPullRequestParticipant                  `json:"reviewers,omitempty"`
				State           *RestUserReactionCommentAnchorPullRequestState `json:"state,omitempty"`
				Title           *string                                        `json:"title,omitempty"`
				ToRef           *struct {
					DisplayId    *string `json:"displayId,omitempty"`
					Id           *string `json:"id,omitempty"`
					LatestCommit *string `json:"latestCommit,omitempty"`
					Repository   *struct {
						Archived      *bool                   `json:"archived,omitempty"`
						DefaultBranch *string                 `json:"defaultBranch,omitempty"`
						Description   *string                 `json:"description,omitempty"`
						Forkable      *bool                   `json:"forkable,omitempty"`
						HierarchyId   *string                 `json:"hierarchyId,omitempty"`
						Id            *int32                  `json:"id,omitempty"`
						Links         *map[string]interface{} `json:"links,omitempty"`
						Name          *string                 `json:"name,omitempty"`
						Origin        *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Partition     *int32                  `json:"partition,omitempty"`
							Project       *struct {
								Avatar      *string                                                                   `json:"avatar,omitempty"`
								AvatarUrl   *string                                                                   `json:"avatarUrl,omitempty"`
								Description *string                                                                   `json:"description,omitempty"`
								Id          *int32                                                                    `json:"id,omitempty"`
								Key         string                                                                    `json:"key"`
								Links       *map[string]interface{}                                                   `json:"links,omitempty"`
								Name        *string                                                                   `json:"name,omitempty"`
								Public      *bool                                                                     `json:"public,omitempty"`
								Scope       *string                                                                   `json:"scope,omitempty"`
								Type        *RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                               `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                             `json:"relatedLinks,omitempty"`
							ScmId         *string                                                             `json:"scmId,omitempty"`
							Scope         *string                                                             `json:"scope,omitempty"`
							Slug          *string                                                             `json:"slug,omitempty"`
							State         *RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
							StatusMessage *string                                                             `json:"statusMessage,omitempty"`
						} `json:"origin,omitempty"`
						Partition *int32 `json:"partition,omitempty"`
						Project   *struct {
							Avatar      *string                                                             `json:"avatar,omitempty"`
							AvatarUrl   *string                                                             `json:"avatarUrl,omitempty"`
							Description *string                                                             `json:"description,omitempty"`
							Id          *int32                                                              `json:"id,omitempty"`
							Key         string                                                              `json:"key"`
							Links       *map[string]interface{}                                             `json:"links,omitempty"`
							Name        *string                                                             `json:"name,omitempty"`
							Public      *bool                                                               `json:"public,omitempty"`
							Scope       *string                                                             `json:"scope,omitempty"`
							Type        *RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
						} `json:"project,omitempty"`
						Public        *bool                                                         `json:"public,omitempty"`
						RelatedLinks  *map[string]interface{}                                       `json:"relatedLinks,omitempty"`
						ScmId         *string                                                       `json:"scmId,omitempty"`
						Scope         *string                                                       `json:"scope,omitempty"`
						Slug          *string                                                       `json:"slug,omitempty"`
						State         *RestUserReactionCommentAnchorPullRequestToRefRepositoryState `json:"state,omitempty"`
						StatusMessage *string                                                       `json:"statusMessage,omitempty"`
					} `json:"repository,omitempty"`
					Type *RestUserReactionCommentAnchorPullRequestToRefType `json:"type,omitempty"`
				} `json:"toRef,omitempty"`
				UpdatedDate *int64 `json:"updatedDate,omitempty"`
				Version     *int32 `json:"version,omitempty"`
			} `json:"pullRequest,omitempty"`
			SrcPath *struct {
				Components *[]string `json:"components,omitempty"`
				Extension  *string   `json:"extension,omitempty"`
				Name       *string   `json:"name,omitempty"`
				Parent     *string   `json:"parent,omitempty"`
			} `json:"srcPath,omitempty"`
			ToHash *string `json:"toHash,omitempty"`
		} `json:"anchor,omitempty"`
		Anchored *bool `json:"anchored,omitempty"`
		Author   *struct {
			Active       *bool                              `json:"active,omitempty"`
			AvatarUrl    *string                            `json:"avatarUrl,omitempty"`
			DisplayName  *string                            `json:"displayName,omitempty"`
			EmailAddress *string                            `json:"emailAddress,omitempty"`
			Id           *int32                             `json:"id,omitempty"`
			Links        *map[string]interface{}            `json:"links,omitempty"`
			Name         *string                            `json:"name,omitempty"`
			Slug         *string                            `json:"slug,omitempty"`
			Type         *RestUserReactionCommentAuthorType `json:"type,omitempty"`
		} `json:"author,omitempty"`
		Comments    *[]RestComment `json:"comments,omitempty"`
		CreatedDate *int64         `json:"createdDate,omitempty"`
		Html        *string        `json:"html,omitempty"`
		Id          *int64         `json:"id,omitempty"`
		Parent      *struct {
			Anchor *struct {
				DiffType        *RestUserReactionCommentParentAnchorDiffType `json:"diffType,omitempty"`
				FileType        *RestUserReactionCommentParentAnchorFileType `json:"fileType,omitempty"`
				FromHash        *string                                      `json:"fromHash,omitempty"`
				Line            *int32                                       `json:"line,omitempty"`
				LineType        *RestUserReactionCommentParentAnchorLineType `json:"lineType,omitempty"`
				MultilineMarker *struct {
					// StartLine The line number where the multiline comment will begin
					StartLine *int32 `json:"startLine,omitempty"`

					// StartLineType The segment type of the start line of the multiline comment
					StartLineType RestUserReactionCommentParentAnchorMultilineMarkerStartLineType `json:"startLineType"`
				} `json:"multilineMarker,omitempty"`
				MultilineSpan *struct {
					// DstSpanEnd The line number of the last line on the right-hand side of the diff that the comment spans
					DstSpanEnd *struct {
						AsInt   *int32 `json:"asInt,omitempty"`
						Present *bool  `json:"present,omitempty"`
					} `json:"dstSpanEnd,omitempty"`

					// DstSpanStart The line number of the first line on the right-hand side of the diff that the comment spans
					DstSpanStart *struct {
						AsInt   *int32 `json:"asInt,omitempty"`
						Present *bool  `json:"present,omitempty"`
					} `json:"dstSpanStart,omitempty"`

					// SrcSpanEnd The line number of the last line on the left-hand side of the diff that the comment spans
					SrcSpanEnd *struct {
						AsInt   *int32 `json:"asInt,omitempty"`
						Present *bool  `json:"present,omitempty"`
					} `json:"srcSpanEnd,omitempty"`

					// SrcSpanStart The line number of the first line on the left-hand side of the diff that the comment spans
					SrcSpanStart *struct {
						AsInt   *int32 `json:"asInt,omitempty"`
						Present *bool  `json:"present,omitempty"`
					} `json:"srcSpanStart,omitempty"`
				} `json:"multilineSpan,omitempty"`
				Path *struct {
					Components *[]string `json:"components,omitempty"`
					Extension  *string   `json:"extension,omitempty"`
					Name       *string   `json:"name,omitempty"`
					Parent     *string   `json:"parent,omitempty"`
				} `json:"path,omitempty"`
				PullRequest *struct {
					Closed            *bool   `json:"closed,omitempty"`
					ClosedDate        *int64  `json:"closedDate,omitempty"`
					CreatedDate       *int64  `json:"createdDate,omitempty"`
					Description       *string `json:"description,omitempty"`
					DescriptionAsHtml *string `json:"descriptionAsHtml,omitempty"`
					Draft             *bool   `json:"draft,omitempty"`
					FromRef           *struct {
						DisplayId    *string `json:"displayId,omitempty"`
						Id           *string `json:"id,omitempty"`
						LatestCommit *string `json:"latestCommit,omitempty"`
						Repository   *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Origin        *struct {
								Archived      *bool                   `json:"archived,omitempty"`
								DefaultBranch *string                 `json:"defaultBranch,omitempty"`
								Description   *string                 `json:"description,omitempty"`
								Forkable      *bool                   `json:"forkable,omitempty"`
								HierarchyId   *string                 `json:"hierarchyId,omitempty"`
								Id            *int32                  `json:"id,omitempty"`
								Links         *map[string]interface{} `json:"links,omitempty"`
								Name          *string                 `json:"name,omitempty"`
								Partition     *int32                  `json:"partition,omitempty"`
								Project       *struct {
									Avatar      *string                                                                           `json:"avatar,omitempty"`
									AvatarUrl   *string                                                                           `json:"avatarUrl,omitempty"`
									Description *string                                                                           `json:"description,omitempty"`
									Id          *int32                                                                            `json:"id,omitempty"`
									Key         string                                                                            `json:"key"`
									Links       *map[string]interface{}                                                           `json:"links,omitempty"`
									Name        *string                                                                           `json:"name,omitempty"`
									Public      *bool                                                                             `json:"public,omitempty"`
									Scope       *string                                                                           `json:"scope,omitempty"`
									Type        *RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType `json:"type,omitempty"`
								} `json:"project,omitempty"`
								Public        *bool                                                                       `json:"public,omitempty"`
								RelatedLinks  *map[string]interface{}                                                     `json:"relatedLinks,omitempty"`
								ScmId         *string                                                                     `json:"scmId,omitempty"`
								Scope         *string                                                                     `json:"scope,omitempty"`
								Slug          *string                                                                     `json:"slug,omitempty"`
								State         *RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState `json:"state,omitempty"`
								StatusMessage *string                                                                     `json:"statusMessage,omitempty"`
							} `json:"origin,omitempty"`
							Partition *int32 `json:"partition,omitempty"`
							Project   *struct {
								Avatar      *string                                                                     `json:"avatar,omitempty"`
								AvatarUrl   *string                                                                     `json:"avatarUrl,omitempty"`
								Description *string                                                                     `json:"description,omitempty"`
								Id          *int32                                                                      `json:"id,omitempty"`
								Key         string                                                                      `json:"key"`
								Links       *map[string]interface{}                                                     `json:"links,omitempty"`
								Name        *string                                                                     `json:"name,omitempty"`
								Public      *bool                                                                       `json:"public,omitempty"`
								Scope       *string                                                                     `json:"scope,omitempty"`
								Type        *RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                                 `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                               `json:"relatedLinks,omitempty"`
							ScmId         *string                                                               `json:"scmId,omitempty"`
							Scope         *string                                                               `json:"scope,omitempty"`
							Slug          *string                                                               `json:"slug,omitempty"`
							State         *RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState `json:"state,omitempty"`
							StatusMessage *string                                                               `json:"statusMessage,omitempty"`
						} `json:"repository,omitempty"`
						Type *RestUserReactionCommentParentAnchorPullRequestFromRefType `json:"type,omitempty"`
					} `json:"fromRef,omitempty"`
					HtmlDescription *string                                              `json:"htmlDescription,omitempty"`
					Id              *int64                                               `json:"id,omitempty"`
					Links           *map[string]interface{}                              `json:"links,omitempty"`
					Locked          *bool                                                `json:"locked,omitempty"`
					Open            *bool                                                `json:"open,omitempty"`
					Participants    *[]RestPullRequestParticipant                        `json:"participants,omitempty"`
					Reviewers       *[]RestPullRequestParticipant                        `json:"reviewers,omitempty"`
					State           *RestUserReactionCommentParentAnchorPullRequestState `json:"state,omitempty"`
					Title           *string                                              `json:"title,omitempty"`
					ToRef           *struct {
						DisplayId    *string `json:"displayId,omitempty"`
						Id           *string `json:"id,omitempty"`
						LatestCommit *string `json:"latestCommit,omitempty"`
						Repository   *struct {
							Archived      *bool                   `json:"archived,omitempty"`
							DefaultBranch *string                 `json:"defaultBranch,omitempty"`
							Description   *string                 `json:"description,omitempty"`
							Forkable      *bool                   `json:"forkable,omitempty"`
							HierarchyId   *string                 `json:"hierarchyId,omitempty"`
							Id            *int32                  `json:"id,omitempty"`
							Links         *map[string]interface{} `json:"links,omitempty"`
							Name          *string                 `json:"name,omitempty"`
							Origin        *struct {
								Archived      *bool                   `json:"archived,omitempty"`
								DefaultBranch *string                 `json:"defaultBranch,omitempty"`
								Description   *string                 `json:"description,omitempty"`
								Forkable      *bool                   `json:"forkable,omitempty"`
								HierarchyId   *string                 `json:"hierarchyId,omitempty"`
								Id            *int32                  `json:"id,omitempty"`
								Links         *map[string]interface{} `json:"links,omitempty"`
								Name          *string                 `json:"name,omitempty"`
								Partition     *int32                  `json:"partition,omitempty"`
								Project       *struct {
									Avatar      *string                                                                         `json:"avatar,omitempty"`
									AvatarUrl   *string                                                                         `json:"avatarUrl,omitempty"`
									Description *string                                                                         `json:"description,omitempty"`
									Id          *int32                                                                          `json:"id,omitempty"`
									Key         string                                                                          `json:"key"`
									Links       *map[string]interface{}                                                         `json:"links,omitempty"`
									Name        *string                                                                         `json:"name,omitempty"`
									Public      *bool                                                                           `json:"public,omitempty"`
									Scope       *string                                                                         `json:"scope,omitempty"`
									Type        *RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType `json:"type,omitempty"`
								} `json:"project,omitempty"`
								Public        *bool                                                                     `json:"public,omitempty"`
								RelatedLinks  *map[string]interface{}                                                   `json:"relatedLinks,omitempty"`
								ScmId         *string                                                                   `json:"scmId,omitempty"`
								Scope         *string                                                                   `json:"scope,omitempty"`
								Slug          *string                                                                   `json:"slug,omitempty"`
								State         *RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState `json:"state,omitempty"`
								StatusMessage *string                                                                   `json:"statusMessage,omitempty"`
							} `json:"origin,omitempty"`
							Partition *int32 `json:"partition,omitempty"`
							Project   *struct {
								Avatar      *string                                                                   `json:"avatar,omitempty"`
								AvatarUrl   *string                                                                   `json:"avatarUrl,omitempty"`
								Description *string                                                                   `json:"description,omitempty"`
								Id          *int32                                                                    `json:"id,omitempty"`
								Key         string                                                                    `json:"key"`
								Links       *map[string]interface{}                                                   `json:"links,omitempty"`
								Name        *string                                                                   `json:"name,omitempty"`
								Public      *bool                                                                     `json:"public,omitempty"`
								Scope       *string                                                                   `json:"scope,omitempty"`
								Type        *RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType `json:"type,omitempty"`
							} `json:"project,omitempty"`
							Public        *bool                                                               `json:"public,omitempty"`
							RelatedLinks  *map[string]interface{}                                             `json:"relatedLinks,omitempty"`
							ScmId         *string                                                             `json:"scmId,omitempty"`
							Scope         *string                                                             `json:"scope,omitempty"`
							Slug          *string                                                             `json:"slug,omitempty"`
							State         *RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState `json:"state,omitempty"`
							StatusMessage *string                                                             `json:"statusMessage,omitempty"`
						} `json:"repository,omitempty"`
						Type *RestUserReactionCommentParentAnchorPullRequestToRefType `json:"type,omitempty"`
					} `json:"toRef,omitempty"`
					UpdatedDate *int64 `json:"updatedDate,omitempty"`
					Version     *int32 `json:"version,omitempty"`
				} `json:"pullRequest,omitempty"`
				SrcPath *struct {
					Components *[]string `json:"components,omitempty"`
					Extension  *string   `json:"extension,omitempty"`
					Name       *string   `json:"name,omitempty"`
					Parent     *string   `json:"parent,omitempty"`
				} `json:"srcPath,omitempty"`
				ToHash *string `json:"toHash,omitempty"`
			} `json:"anchor,omitempty"`
			Anchored *bool `json:"anchored,omitempty"`
			Author   *struct {
				Active       *bool                                    `json:"active,omitempty"`
				AvatarUrl    *string                                  `json:"avatarUrl,omitempty"`
				DisplayName  *string                                  `json:"displayName,omitempty"`
				EmailAddress *string                                  `json:"emailAddress,omitempty"`
				Id           *int32                                   `json:"id,omitempty"`
				Links        *map[string]interface{}                  `json:"links,omitempty"`
				Name         *string                                  `json:"name,omitempty"`
				Slug         *string                                  `json:"slug,omitempty"`
				Type         *RestUserReactionCommentParentAuthorType `json:"type,omitempty"`
			} `json:"author,omitempty"`
			CreatedDate  *int64                  `json:"createdDate,omitempty"`
			Html         *string                 `json:"html,omitempty"`
			Id           *int64                  `json:"id,omitempty"`
			Pending      *bool                   `json:"pending,omitempty"`
			Properties   *map[string]interface{} `json:"properties,omitempty"`
			Reply        *bool                   `json:"reply,omitempty"`
			ResolvedDate *int64                  `json:"resolvedDate,omitempty"`
			Resolver     *struct {
				Active       *bool                                      `json:"active,omitempty"`
				AvatarUrl    *string                                    `json:"avatarUrl,omitempty"`
				DisplayName  *string                                    `json:"displayName,omitempty"`
				EmailAddress *string                                    `json:"emailAddress,omitempty"`
				Id           *int32                                     `json:"id,omitempty"`
				Links        *map[string]interface{}                    `json:"links,omitempty"`
				Name         *string                                    `json:"name,omitempty"`
				Slug         *string                                    `json:"slug,omitempty"`
				Type         *RestUserReactionCommentParentResolverType `json:"type,omitempty"`
			} `json:"resolver,omitempty"`
			Severity *string `json:"severity,omitempty"`
			State    *string `json:"state,omitempty"`
			Text     *string `json:"text,omitempty"`

			// ThreadResolved Indicates if this comment thread has been marked as resolved or not
			ThreadResolved     *bool  `json:"threadResolved,omitempty"`
			ThreadResolvedDate *int64 `json:"threadResolvedDate,omitempty"`
			ThreadResolver     *struct {
				Active       *bool                                            `json:"active,omitempty"`
				AvatarUrl    *string                                          `json:"avatarUrl,omitempty"`
				DisplayName  *string                                          `json:"displayName,omitempty"`
				EmailAddress *string                                          `json:"emailAddress,omitempty"`
				Id           *int32                                           `json:"id,omitempty"`
				Links        *map[string]interface{}                          `json:"links,omitempty"`
				Name         *string                                          `json:"name,omitempty"`
				Slug         *string                                          `json:"slug,omitempty"`
				Type         *RestUserReactionCommentParentThreadResolverType `json:"type,omitempty"`
			} `json:"threadResolver,omitempty"`
			UpdatedDate *int64 `json:"updatedDate,omitempty"`
			Version     *int32 `json:"version,omitempty"`
		} `json:"parent,omitempty"`
		Pending      *bool                   `json:"pending,omitempty"`
		Properties   *map[string]interface{} `json:"properties,omitempty"`
		Reply        *bool                   `json:"reply,omitempty"`
		ResolvedDate *int64                  `json:"resolvedDate,omitempty"`
		Resolver     *struct {
			Active       *bool                                `json:"active,omitempty"`
			AvatarUrl    *string                              `json:"avatarUrl,omitempty"`
			DisplayName  *string                              `json:"displayName,omitempty"`
			EmailAddress *string                              `json:"emailAddress,omitempty"`
			Id           *int32                               `json:"id,omitempty"`
			Links        *map[string]interface{}              `json:"links,omitempty"`
			Name         *string                              `json:"name,omitempty"`
			Slug         *string                              `json:"slug,omitempty"`
			Type         *RestUserReactionCommentResolverType `json:"type,omitempty"`
		} `json:"resolver,omitempty"`
		Severity *string `json:"severity,omitempty"`
		State    *string `json:"state,omitempty"`
		Text     *string `json:"text,omitempty"`

		// ThreadResolved Indicates if this comment thread has been marked as resolved or not
		ThreadResolved     *bool  `json:"threadResolved,omitempty"`
		ThreadResolvedDate *int64 `json:"threadResolvedDate,omitempty"`
		ThreadResolver     *struct {
			Active       *bool                                      `json:"active,omitempty"`
			AvatarUrl    *string                                    `json:"avatarUrl,omitempty"`
			DisplayName  *string                                    `json:"displayName,omitempty"`
			EmailAddress *string                                    `json:"emailAddress,omitempty"`
			Id           *int32                                     `json:"id,omitempty"`
			Links        *map[string]interface{}                    `json:"links,omitempty"`
			Name         *string                                    `json:"name,omitempty"`
			Slug         *string                                    `json:"slug,omitempty"`
			Type         *RestUserReactionCommentThreadResolverType `json:"type,omitempty"`
		} `json:"threadResolver,omitempty"`
		UpdatedDate *int64 `json:"updatedDate,omitempty"`
		Version     *int32 `json:"version,omitempty"`
	} `json:"comment,omitempty"`
	Emoticon *struct {
		Shortcut *string `json:"shortcut,omitempty"`
		Url      *string `json:"url,omitempty"`
		Value    *string `json:"value,omitempty"`
	} `json:"emoticon,omitempty"`
	User *struct {
		Active       *bool                     `json:"active,omitempty"`
		AvatarUrl    *string                   `json:"avatarUrl,omitempty"`
		DisplayName  *string                   `json:"displayName,omitempty"`
		EmailAddress *string                   `json:"emailAddress,omitempty"`
		Id           *int32                    `json:"id,omitempty"`
		Links        *map[string]interface{}   `json:"links,omitempty"`
		Name         *string                   `json:"name,omitempty"`
		Slug         *string                   `json:"slug,omitempty"`
		Type         *RestUserReactionUserType `json:"type,omitempty"`
	} `json:"user,omitempty"`
}

// RestUserReactionCommentAnchorDiffType defines model for RestUserReaction.Comment.Anchor.DiffType.
type RestUserReactionCommentAnchorDiffType string

// RestUserReactionCommentAnchorFileType defines model for RestUserReaction.Comment.Anchor.FileType.
type RestUserReactionCommentAnchorFileType string

// RestUserReactionCommentAnchorLineType defines model for RestUserReaction.Comment.Anchor.LineType.
type RestUserReactionCommentAnchorLineType string

// RestUserReactionCommentAnchorMultilineMarkerStartLineType The segment type of the start line of the multiline comment
type RestUserReactionCommentAnchorMultilineMarkerStartLineType string

// RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType defines model for RestUserReaction.Comment.Anchor.PullRequest.FromRef.Repository.Origin.Project.Type.
type RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginProjectType string

// RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState defines model for RestUserReaction.Comment.Anchor.PullRequest.FromRef.Repository.Origin.State.
type RestUserReactionCommentAnchorPullRequestFromRefRepositoryOriginState string

// RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType defines model for RestUserReaction.Comment.Anchor.PullRequest.FromRef.Repository.Project.Type.
type RestUserReactionCommentAnchorPullRequestFromRefRepositoryProjectType string

// RestUserReactionCommentAnchorPullRequestFromRefRepositoryState defines model for RestUserReaction.Comment.Anchor.PullRequest.FromRef.Repository.State.
type RestUserReactionCommentAnchorPullRequestFromRefRepositoryState string

// RestUserReactionCommentAnchorPullRequestFromRefType defines model for RestUserReaction.Comment.Anchor.PullRequest.FromRef.Type.
type RestUserReactionCommentAnchorPullRequestFromRefType string

// RestUserReactionCommentAnchorPullRequestState defines model for RestUserReaction.Comment.Anchor.PullRequest.State.
type RestUserReactionCommentAnchorPullRequestState string

// RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType defines model for RestUserReaction.Comment.Anchor.PullRequest.ToRef.Repository.Origin.Project.Type.
type RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginProjectType string

// RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState defines model for RestUserReaction.Comment.Anchor.PullRequest.ToRef.Repository.Origin.State.
type RestUserReactionCommentAnchorPullRequestToRefRepositoryOriginState string

// RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType defines model for RestUserReaction.Comment.Anchor.PullRequest.ToRef.Repository.Project.Type.
type RestUserReactionCommentAnchorPullRequestToRefRepositoryProjectType string

// RestUserReactionCommentAnchorPullRequestToRefRepositoryState defines model for RestUserReaction.Comment.Anchor.PullRequest.ToRef.Repository.State.
type RestUserReactionCommentAnchorPullRequestToRefRepositoryState string

// RestUserReactionCommentAnchorPullRequestToRefType defines model for RestUserReaction.Comment.Anchor.PullRequest.ToRef.Type.
type RestUserReactionCommentAnchorPullRequestToRefType string

// RestUserReactionCommentAuthorType defines model for RestUserReaction.Comment.Author.Type.
type RestUserReactionCommentAuthorType string

// RestUserReactionCommentParentAnchorDiffType defines model for RestUserReaction.Comment.Parent.Anchor.DiffType.
type RestUserReactionCommentParentAnchorDiffType string

// RestUserReactionCommentParentAnchorFileType defines model for RestUserReaction.Comment.Parent.Anchor.FileType.
type RestUserReactionCommentParentAnchorFileType string

// RestUserReactionCommentParentAnchorLineType defines model for RestUserReaction.Comment.Parent.Anchor.LineType.
type RestUserReactionCommentParentAnchorLineType string

// RestUserReactionCommentParentAnchorMultilineMarkerStartLineType The segment type of the start line of the multiline comment
type RestUserReactionCommentParentAnchorMultilineMarkerStartLineType string

// RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.FromRef.Repository.Origin.Project.Type.
type RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginProjectType string

// RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.FromRef.Repository.Origin.State.
type RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryOriginState string

// RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.FromRef.Repository.Project.Type.
type RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryProjectType string

// RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.FromRef.Repository.State.
type RestUserReactionCommentParentAnchorPullRequestFromRefRepositoryState string

// RestUserReactionCommentParentAnchorPullRequestFromRefType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.FromRef.Type.
type RestUserReactionCommentParentAnchorPullRequestFromRefType string

// RestUserReactionCommentParentAnchorPullRequestState defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.State.
type RestUserReactionCommentParentAnchorPullRequestState string

// RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.ToRef.Repository.Origin.Project.Type.
type RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginProjectType string

// RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.ToRef.Repository.Origin.State.
type RestUserReactionCommentParentAnchorPullRequestToRefRepositoryOriginState string

// RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.ToRef.Repository.Project.Type.
type RestUserReactionCommentParentAnchorPullRequestToRefRepositoryProjectType string

// RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.ToRef.Repository.State.
type RestUserReactionCommentParentAnchorPullRequestToRefRepositoryState string

// RestUserReactionCommentParentAnchorPullRequestToRefType defines model for RestUserReaction.Comment.Parent.Anchor.PullRequest.ToRef.Type.
type RestUserReactionCommentParentAnchorPullRequestToRefType string

// RestUserReactionCommentParentAuthorType defines model for RestUserReaction.Comment.Parent.Author.Type.
type RestUserReactionCommentParentAuthorType string

// RestUserReactionCommentParentResolverType defines model for RestUserReaction.Comment.Parent.Resolver.Type.
type RestUserReactionCommentParentResolverType string

// RestUserReactionCommentParentThreadResolverType defines model for RestUserReaction.Comment.Parent.ThreadResolver.Type.
type RestUserReactionCommentParentThreadResolverType string

// RestUserReactionCommentResolverType defines model for RestUserReaction.Comment.Resolver.Type.
type RestUserReactionCommentResolverType string

// RestUserReactionCommentThreadResolverType defines model for RestUserReaction.Comment.ThreadResolver.Type.
type RestUserReactionCommentThreadResolverType string

// RestUserReactionUserType defines model for RestUserReaction.User.Type.
type RestUserReactionUserType string

// RestUsernamePasswordCredentials defines model for RestUsernamePasswordCredentials.
type RestUsernamePasswordCredentials struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RestWebhook defines model for RestWebhook.
type RestWebhook struct {
	Active                  *bool                   `json:"active,omitempty"`
	Configuration           *map[string]interface{} `json:"configuration,omitempty"`
	Credentials             *RestWebhookCredentials `json:"credentials,omitempty"`
	Events                  *[]string               `json:"events,omitempty"`
	Name                    *string                 `json:"name,omitempty"`
	ScopeType               *string                 `json:"scopeType,omitempty"`
	SslVerificationRequired *bool                   `json:"sslVerificationRequired,omitempty"`
	Statistics              *map[string]interface{} `json:"statistics,omitempty"`
	Url                     *string                 `json:"url,omitempty"`
}

// RestWebhookCredentials defines model for RestWebhookCredentials.
type RestWebhookCredentials struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// RestWebhookRequestResponse defines model for RestWebhookRequestResponse.
type RestWebhookRequestResponse = interface{}

// RestX509Certificate defines model for RestX509Certificate.
type RestX509Certificate struct {
	// Fingerprint The SHA-256 fingerprint of the X.509 certificate
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id The ID of the X.509 certificate
	Id *int64 `json:"id,omitempty"`
}

// SimpleSshKeyFingerprint defines model for SimpleSshKeyFingerprint.
type SimpleSshKeyFingerprint struct {
	Algorithm *string `json:"algorithm,omitempty"`
	Value     *string `json:"value,omitempty"`
}

// UserAndGroups defines model for UserAndGroups.
type UserAndGroups struct {
	Groups []string `json:"groups"`
	User   *string  `json:"user,omitempty"`
}

// UserPasswordUpdate defines model for UserPasswordUpdate.
type UserPasswordUpdate struct {
	OldPassword     *string `json:"oldPassword,omitempty"`
	Password        *string `json:"password,omitempty"`
	PasswordConfirm *string `json:"passwordConfirm,omitempty"`
}

// UserPickerContext defines model for UserPickerContext.
type UserPickerContext struct {
	Context  *string `json:"context,omitempty"`
	ItemName *string `json:"itemName,omitempty"`
}

// UserRename defines model for UserRename.
type UserRename struct {
	Name    *string `json:"name,omitempty"`
	NewName *string `json:"newName,omitempty"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	DisplayName *string `json:"displayName,omitempty"`
	Email       *string `json:"email,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// GetAllAccessTokensParams defines parameters for GetAllAccessTokens.
type GetAllAccessTokensParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllAccessTokens1Params defines parameters for GetAllAccessTokens1.
type GetAllAccessTokens1Params struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllAccessTokens2Params defines parameters for GetAllAccessTokens2.
type GetAllAccessTokens2Params struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetBannerJSONBody defines parameters for SetBanner.
type SetBannerJSONBody struct {
	Audience SetBannerJSONBodyAudience `json:"audience"`
	Enabled  *bool                     `json:"enabled,omitempty"`
	Message  *string                   `json:"message,omitempty"`
}

// SetBannerJSONBodyAudience defines parameters for SetBanner.
type SetBannerJSONBodyAudience string

// SetDefaultBranchJSONBody defines parameters for SetDefaultBranch.
type SetDefaultBranchJSONBody struct {
	Id *string `json:"id,omitempty"`
}

// Delete2Params defines parameters for Delete2.
type Delete2Params struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// DeleteGroupParams defines parameters for DeleteGroup.
type DeleteGroupParams struct {
	// Name The name identifying the group to delete.
	Name string `form:"name" json:"name"`
}

// GetGroups1Params defines parameters for GetGroups1.
type GetGroups1Params struct {
	// Filter If specified only group names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateGroupParams defines parameters for CreateGroup.
type CreateGroupParams struct {
	// Name Name of the group.
	Name string `form:"name" json:"name"`
}

// FindUsersInGroupParams defines parameters for FindUsersInGroup.
type FindUsersInGroupParams struct {
	// Filter If specified only users with usernames, display names or email addresses containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Context The group which should be used to locate members.
	Context string `form:"context" json:"context"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindUsersNotInGroupParams defines parameters for FindUsersNotInGroup.
type FindUsersNotInGroupParams struct {
	// Filter If specified only users with usernames, display names or email addresses containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Context The group which should be used to locate members.
	Context string `form:"context" json:"context"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetMailConfigJSONBody defines parameters for SetMailConfig.
type SetMailConfigJSONBody struct {
	Hostname        *string                        `json:"hostname,omitempty"`
	Password        *string                        `json:"password,omitempty"`
	Port            *int32                         `json:"port,omitempty"`
	Protocol        *SetMailConfigJSONBodyProtocol `json:"protocol,omitempty"`
	RequireStartTls *bool                          `json:"requireStartTls,omitempty"`
	SenderAddress   *string                        `json:"senderAddress,omitempty"`
	UseStartTls     *bool                          `json:"useStartTls,omitempty"`
	Username        *string                        `json:"username,omitempty"`
}

// SetMailConfigJSONBodyProtocol defines parameters for SetMailConfig.
type SetMailConfigJSONBodyProtocol string

// SetSenderAddressJSONBody defines parameters for SetSenderAddress.
type SetSenderAddressJSONBody = string

// RevokePermissionsForGroupParams defines parameters for RevokePermissionsForGroup.
type RevokePermissionsForGroupParams struct {
	// Name The name of the group
	Name string `form:"name" json:"name"`
}

// GetGroupsWithAnyPermissionParams defines parameters for GetGroupsWithAnyPermission.
type GetGroupsWithAnyPermissionParams struct {
	// Filter If specified only group names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForGroupsParams defines parameters for SetPermissionForGroups.
type SetPermissionForGroupsParams struct {
	// Name The names of the groups
	Name []string `form:"name" json:"name"`

	// Permission The permission to grant
	Permission SetPermissionForGroupsParamsPermission `form:"permission" json:"permission"`
}

// SetPermissionForGroupsParamsPermission defines parameters for SetPermissionForGroups.
type SetPermissionForGroupsParamsPermission string

// GetGroupsWithoutAnyPermissionParams defines parameters for GetGroupsWithoutAnyPermission.
type GetGroupsWithoutAnyPermissionParams struct {
	// Filter If specified only user names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// RevokePermissionsForUserParams defines parameters for RevokePermissionsForUser.
type RevokePermissionsForUserParams struct {
	// Name The name of the user
	Name string `form:"name" json:"name"`
}

// GetUsersWithAnyPermissionParams defines parameters for GetUsersWithAnyPermission.
type GetUsersWithAnyPermissionParams struct {
	// Filter If specified only user names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForUsersParams defines parameters for SetPermissionForUsers.
type SetPermissionForUsersParams struct {
	// Name The names of the users
	Name []string `form:"name" json:"name"`

	// Permission The permission to grant
	Permission SetPermissionForUsersParamsPermission `form:"permission" json:"permission"`
}

// SetPermissionForUsersParamsPermission defines parameters for SetPermissionForUsers.
type SetPermissionForUsersParamsPermission string

// GetUsersWithoutAnyPermissionParams defines parameters for GetUsersWithoutAnyPermission.
type GetUsersWithoutAnyPermissionParams struct {
	// Filter If specified only user names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetHistoryParams defines parameters for GetHistory.
type GetHistoryParams struct {
	// Order An optional sort category to arrange the results in descending order
	Order *GetHistoryParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetHistoryParamsOrder defines parameters for GetHistory.
type GetHistoryParamsOrder string

// GetAllRateLimitSettingsParams defines parameters for GetAllRateLimitSettings.
type GetAllRateLimitSettingsParams struct {
	// Filter Optional filter
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUserDirectoriesParams defines parameters for GetUserDirectories.
type GetUserDirectoriesParams struct {
	// IncludeInactive Set <code>true</code> to include inactive directories; otherwise, <code>false</code> to only return active directories.
	IncludeInactive *string `form:"includeInactive,omitempty" json:"includeInactive,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Name The username identifying the user to delete.
	Name string `form:"name" json:"name"`
}

// GetUsers1Params defines parameters for GetUsers1.
type GetUsers1Params struct {
	// Filter If specified only users with usernames, display name or email addresses containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// EmailAddress The e-mail address for the new user.
	EmailAddress string `form:"emailAddress" json:"emailAddress"`

	// Password The password for the new user. Required if the <code>notify</code> parameter is not present or is set to <code>false</false>
	Password *string `form:"password,omitempty" json:"password,omitempty"`

	// AddToDefaultGroup Set <code>true</code> to add the user to the default group, which can be used to grant them a set of initial permissions; otherwise, <code>false</code> to not add them to a group.
	AddToDefaultGroup *bool `form:"addToDefaultGroup,omitempty" json:"addToDefaultGroup,omitempty"`

	// DisplayName The display name for the new user.
	DisplayName string `form:"displayName" json:"displayName"`

	// Name The username for the new user.
	Name string `form:"name" json:"name"`

	// Notify If present and not <code>false</code> instead of requiring a password, the create user will be notified via email their account has been created and requires a password to be reset. This option can only be used if a mail server has been configured.
	Notify *bool `form:"notify,omitempty" json:"notify,omitempty"`
}

// ClearUserCaptchaChallengeParams defines parameters for ClearUserCaptchaChallenge.
type ClearUserCaptchaChallengeParams struct {
	// Name The username
	Name string `form:"name" json:"name"`
}

// ValidateErasableParams defines parameters for ValidateErasable.
type ValidateErasableParams struct {
	// Name The username of the user to validate erasability for.
	Name string `form:"name" json:"name"`
}

// EraseUserParams defines parameters for EraseUser.
type EraseUserParams struct {
	// Name The username identifying the user to erase.
	Name string `form:"name" json:"name"`
}

// FindGroupsForUserParams defines parameters for FindGroupsForUser.
type FindGroupsForUserParams struct {
	// Filter If specified only users with usernames, display names or email addresses containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Context The group which should be used to locate members.
	Context string `form:"context" json:"context"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindOtherGroupsForUserParams defines parameters for FindOtherGroupsForUser.
type FindOtherGroupsForUserParams struct {
	// Filter If specified only groups with names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Context The user which should be used to locate groups.
	Context string `form:"context" json:"context"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPullRequestSuggestionsParams defines parameters for GetPullRequestSuggestions.
type GetPullRequestSuggestionsParams struct {
	// ChangesSince restrict pull request suggestions to be based on events that occurred since some timein the past. This is expressed in seconds since "now". So to return suggestionsbased only on activity within the past 48 hours, pass a value of 172800.
	ChangesSince *string `form:"changesSince,omitempty" json:"changesSince,omitempty"`

	// Limit restricts the result set to return at most this many suggestions.
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPullRequests1Params defines parameters for GetPullRequests1.
type GetPullRequests1Params struct {
	// ClosedSince (optional, defaults to returning pull requests regardless of closed since date). Permits returning only pull requests with a closed timestamp set more recently that (now - closedSince). Units are in seconds. So for example if closed since 86400 is set only pull requests closed in the previous 24 hours will be returned.
	ClosedSince *string `form:"closedSince,omitempty" json:"closedSince,omitempty"`

	// Role (optional, defaults to returning pull requests for any role). If a role is supplied only pull requests where the authenticated user is a participant in the given role will be returned. Either <strong>REVIEWER</strong>, <strong>AUTHOR</strong> or <strong>PARTICIPANT</strong>.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// ParticipantStatus (optional, defaults to returning pull requests with any participant status). A comma separated list of participant status. That is, one or more of <strong>UNAPPROVED</strong>, <strong>NEEDS_WORK</strong>, or <strong>APPROVED</strong>.
	ParticipantStatus *string `form:"participantStatus,omitempty" json:"participantStatus,omitempty"`

	// State (optional, defaults to returning pull requests in any state). If a state is supplied only pull requests in the specified state will be returned. Either <strong>OPEN</strong>, <strong>DECLINED</strong> or <strong>MERGED</strong>. Omit this parameter to return pull request in any state.
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// User The name of the involved user, defaults to the current user.
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Order (optional, defaults to <strong>NEWEST</strong>) the order/(s) to return pull requests in; can choose from <strong>OLDEST</strong> (as in: "oldest first"), <strong>NEWEST</strong>, <strong>DRAFT_STATUS</strong>, <strong>PARTICIPANT_STATUS</strong>, and/or <strong>CLOSED_DATE</strong>. Where <strong>CLOSED_DATE</strong> is specified and the result set includes pull requests that are not in the closed state, these pull requests will appear first in the result set, followed by most recently closed pull requests.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAvatarParams defines parameters for GetAvatar.
type GetAvatarParams struct {
	// Version (optional) Version used for HTTP caching only - any non-blank version will result in a large max-age Cache-Control header. Note that this does not affect the Last-Modified header.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// GetPullRequests2Params defines parameters for GetPullRequests2.
type GetPullRequests2Params struct {
	Role  *string `form:"role,omitempty" json:"role,omitempty"`
	Limit *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Start *int32  `form:"start,omitempty" json:"start,omitempty"`
}

// GetLabelsParams defines parameters for GetLabels.
type GetLabelsParams struct {
	// Prefix (optional) prefix to filter the labels on.
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLabelablesParams defines parameters for GetLabelables.
type GetLabelablesParams struct {
	// Type  the type of labelables to be returned. Supported values: REPOSITORY
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// PreviewParams defines parameters for Preview.
type PreviewParams struct {
	// HtmlEscape (Optional) true if HTML should be escaped in the input markup, false otherwise.
	HtmlEscape *string `form:"htmlEscape,omitempty" json:"htmlEscape,omitempty"`

	// UrlMode (Optional) The mode to use when building URLs. One of: ABSOLUTE, RELATIVE or, CONFIGURED. By default this is RELATIVE.
	UrlMode *string `form:"urlMode,omitempty" json:"urlMode,omitempty"`

	// IncludeHeadingId (Optional) true if headers should contain an ID based on the heading content.
	IncludeHeadingId *string `form:"includeHeadingId,omitempty" json:"includeHeadingId,omitempty"`

	// Hardwrap (Optional) Whether the markup implementation should convert newlines to breaks. By default this is false which reflects the standard markdown specification.
	Hardwrap *string `form:"hardwrap,omitempty" json:"hardwrap,omitempty"`
}

// GetExportJobMessagesParams defines parameters for GetExportJobMessages.
type GetExportJobMessagesParams struct {
	// Severity The severity to include in the results
	Severity *string `form:"severity,omitempty" json:"severity,omitempty"`

	// Subject The subject
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetImportJobMessagesParams defines parameters for GetImportJobMessages.
type GetImportJobMessagesParams struct {
	// Severity The severity to include in the results
	Severity *string `form:"severity,omitempty" json:"severity,omitempty"`

	// Subject The subject
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StartMeshMigrationJSONBody defines parameters for StartMeshMigration.
type StartMeshMigrationJSONBody struct {
	All               *bool `json:"all,omitempty"`
	MaxBytesPerSecond *struct {
		AsLong  *int64 `json:"asLong,omitempty"`
		Present *bool  `json:"present,omitempty"`
	} `json:"maxBytesPerSecond,omitempty"`
	ProjectIds    *[]int32 `json:"projectIds,omitempty"`
	RepositoryIds *[]int32 `json:"repositoryIds,omitempty"`
}

// SearchMeshMigrationReposParams defines parameters for SearchMeshMigrationRepos.
type SearchMeshMigrationReposParams struct {
	// MigrationId (optional) The currently active migration job. If not passed, this is looked up internally.
	MigrationId *string `form:"migrationId,omitempty" json:"migrationId,omitempty"`

	// ProjectKey (optional) The project key. Can be specified more than once to filter by more than one project.
	ProjectKey *string `form:"projectKey,omitempty" json:"projectKey,omitempty"`

	// Name (optional) The repository name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// State (optional) If a migration is active, the MeshMigrationQueueState state to filter results by. Can be specified more than once to filter by more than one state.
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Remote (optional) Whether the repository has been fully migrated to Mesh. If not present, all repositories are considered regardless of where they're located.
	Remote *string `form:"remote,omitempty" json:"remote,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllMeshMigrationSummariesParams defines parameters for GetAllMeshMigrationSummaries.
type GetAllMeshMigrationSummariesParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeshMigrationJobMessagesParams defines parameters for GetMeshMigrationJobMessages.
type GetMeshMigrationJobMessagesParams struct {
	// Severity The severity to include in the results
	Severity *string `form:"severity,omitempty" json:"severity,omitempty"`

	// Subject The subject
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRepositoriesRecentlyAccessedParams defines parameters for GetRepositoriesRecentlyAccessed.
type GetRepositoriesRecentlyAccessedParams struct {
	// Permission (optional) If specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default <code>REPO_READ</code> permission level will be assumed.
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {
	// Name Name to filter by.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Permission Permission to filter by
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetProjectAvatarParams defines parameters for GetProjectAvatar.
type GetProjectAvatarParams struct {
	// S The desired size of the image. The server will return an image as close as possible to the specified size.
	S *string `form:"s,omitempty" json:"s,omitempty"`
}

// GetConfigurationsParams defines parameters for GetConfigurations.
type GetConfigurationsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// RevokePermissionsParams defines parameters for RevokePermissions.
type RevokePermissionsParams struct {
	// User The names of the users
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Group The names of the groups
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// RevokePermissionsForGroup1Params defines parameters for RevokePermissionsForGroup1.
type RevokePermissionsForGroup1Params struct {
	// Name The name of the group
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetGroupsWithAnyPermission1Params defines parameters for GetGroupsWithAnyPermission1.
type GetGroupsWithAnyPermission1Params struct {
	// Filter If specified only group names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForGroups1Params defines parameters for SetPermissionForGroups1.
type SetPermissionForGroups1Params struct {
	// Name The names of the groups
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Permission The permission to grant.See the [permissions documentation](https://confluence.atlassian.com/display/BitbucketServer/Using+project+permissions)for a detailed explanation of what each permission entails. Available project permissions are:
	//
	// - PROJECT_READ
	// - PROJECT_WRITE
	// - PROJECT_ADMIN
	//
	//
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`
}

// GetGroupsWithoutAnyPermission1Params defines parameters for GetGroupsWithoutAnyPermission1.
type GetGroupsWithoutAnyPermission1Params struct {
	// Filter If specified only group names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SearchPermissionsParams defines parameters for SearchPermissions.
type SearchPermissionsParams struct {
	// Permission Permissions to filter by. See the [permissions documentation](https://confluence.atlassian.com/display/BitbucketServer/Using+project+permissions)for a detailed explanation of what each permission entails. This parameter can be specified multiple times to filter by more than one permission, and can contain global and project permissions.
	//
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// FilterText Name of the user or group to filter the name of
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// Type Type of entity (user or group)Valid entity types are:
	//
	// - USER- GROUP
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// RevokePermissionsForUser1Params defines parameters for RevokePermissionsForUser1.
type RevokePermissionsForUser1Params struct {
	// Name The name of the user
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetUsersWithAnyPermission1Params defines parameters for GetUsersWithAnyPermission1.
type GetUsersWithAnyPermission1Params struct {
	// Filter If specified only user names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForUsers1Params defines parameters for SetPermissionForUsers1.
type SetPermissionForUsers1Params struct {
	// Name The names of the users
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Permission The permission to grant.See the [permissions documentation](https://confluence.atlassian.com/display/BitbucketServer/Using+project+permissions)for a detailed explanation of what each permission entails. Available project permissions are:
	//
	// - PROJECT_READ
	// - PROJECT_WRITE
	// - PROJECT_ADMIN
	//
	//
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`
}

// GetUsersWithoutPermissionParams defines parameters for GetUsersWithoutPermission.
type GetUsersWithoutPermissionParams struct {
	// Filter If specified only user names containing the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// ModifyAllUserPermissionParams defines parameters for ModifyAllUserPermission.
type ModifyAllUserPermissionParams struct {
	// Allow <em>true</em> to grant the specified permission to all users, or <em>false</em> to revoke it
	Allow *string `form:"allow,omitempty" json:"allow,omitempty"`
}

// GetRepositoriesParams defines parameters for GetRepositories.
type GetRepositoriesParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetArchiveParams defines parameters for GetArchive.
type GetArchiveParams struct {
	// Path Paths to include in the streamed archive; may be repeated to include multiple paths
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// Filename A filename to include the "Content-Disposition" header
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// At The commit to stream an archive of; if not supplied, an archive of the default branch is streamed
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Prefix A prefix to apply to all entries in the streamed archive; if the supplied prefix does not end with a trailing /, one will be added automatically
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Format The format to stream the archive in; must be one of: zip, tar, tar.gz or tgz
	Format *string `form:"format,omitempty" json:"format,omitempty"`
}

// GetAttachmentParams defines parameters for GetAttachment.
type GetAttachmentParams struct {
	UserAgent *string `json:"User-Agent,omitempty"`
	Range     *string `json:"Range,omitempty"`
}

// SaveAttachmentMetadataJSONBody defines parameters for SaveAttachmentMetadata.
type SaveAttachmentMetadataJSONBody = string

// GetBranchesParams defines parameters for GetBranches.
type GetBranchesParams struct {
	// BoostMatches Controls whether exact and prefix matches will be boosted to the top
	BoostMatches *bool   `form:"boostMatches,omitempty" json:"boostMatches,omitempty"`
	Context      *string `form:"context,omitempty" json:"context,omitempty"`

	// OrderBy Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
	OrderBy *GetBranchesParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Details Whether to retrieve plugin-provided metadata about each branch
	Details *bool `form:"details,omitempty" json:"details,omitempty"`

	// FilterText The text to match on
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// Base Base branch or tag to compare each branch to (for the metadata providers that uses that information
	Base *string `form:"base,omitempty" json:"base,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetBranchesParamsOrderBy defines parameters for GetBranches.
type GetBranchesParamsOrderBy string

// GetContentParams defines parameters for GetContent.
type GetContentParams struct {
	// NoContent If blame&amp;noContent only the blame is retrieved instead of the contents
	NoContent *string `form:"noContent,omitempty" json:"noContent,omitempty"`

	// At The commit ID or ref to retrieve the content for
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Size If true only the size will be returned for the file path instead of the contents
	Size *string `form:"size,omitempty" json:"size,omitempty"`

	// Blame If present and not equal to 'false', the blame will be returned for the file as well
	Blame *string `form:"blame,omitempty" json:"blame,omitempty"`

	// Type If true only the type will be returned for the file path instead of the contents
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GetContent1Params defines parameters for GetContent1.
type GetContent1Params struct {
	// NoContent If blame&amp;noContent only the blame is retrieved instead of the contents
	NoContent *string `form:"noContent,omitempty" json:"noContent,omitempty"`

	// At The commit ID or ref to retrieve the content for
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Size If true only the size will be returned for the file path instead of the contents
	Size *string `form:"size,omitempty" json:"size,omitempty"`

	// Blame If present and not equal to 'false', the blame will be returned for the file as well
	Blame *string `form:"blame,omitempty" json:"blame,omitempty"`

	// Type If true only the type will be returned for the file path instead of the contents
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// GetChanges1Params defines parameters for GetChanges1.
type GetChanges1Params struct {
	// Until The commit to retrieve changes for
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// Since The commit to which <code>until</code> should be compared to produce a page of changes. If not specified the commit's first parent is assumed (if one exists)
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCommitsParams defines parameters for GetCommits.
type GetCommitsParams struct {
	// AvatarScheme The desired scheme for the avatar URL. If the parameter is not present URLs will use the same scheme as this request
	AvatarScheme *string `form:"avatarScheme,omitempty" json:"avatarScheme,omitempty"`

	// Path An optional path to filter commits by
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// WithCounts Optionally include the total number of commits and total number of unique authors
	WithCounts *string `form:"withCounts,omitempty" json:"withCounts,omitempty"`

	// FollowRenames If <code>true</code>, the commit history of the specified file will be followed past renames. Only valid for a path to a single file.
	FollowRenames *string `form:"followRenames,omitempty" json:"followRenames,omitempty"`

	// Until The commit ID (SHA1) or ref (inclusively) to retrieve commits before
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// AvatarSize If present the service adds avatar URLs for commit authors. Should be an integer specifying the desired size in pixels. If the parameter is not present, avatar URLs will not be set
	AvatarSize *string `form:"avatarSize,omitempty" json:"avatarSize,omitempty"`

	// Since The commit ID or ref (exclusively) to retrieve commits after
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Merges If present, controls how merge commits should be filtered. Can be either <code>exclude</code>, to exclude merge commits, <code>include</code>, to include both merge commits and non-merge commits or <code>only</code>, to only return merge commits.
	Merges *string `form:"merges,omitempty" json:"merges,omitempty"`

	// IgnoreMissing <code>true</code> to ignore missing commits, <code>false</code> otherwise
	IgnoreMissing *string `form:"ignoreMissing,omitempty" json:"ignoreMissing,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCommitParams defines parameters for GetCommit.
type GetCommitParams struct {
	// Path An optional path to filter the commit by. If supplied the details returned <i>may not</i> be for the specified commit. Instead, starting from the specified commit, they will be the details for the first commit affecting the specified path.
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// DeleteParams defines parameters for Delete.
type DeleteParams struct {
	// Key the key of the build status
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// GetParams defines parameters for Get.
type GetParams struct {
	// Key the key of the build status
	Key string `form:"key" json:"key"`
}

// GetChangesParams defines parameters for GetChanges.
type GetChangesParams struct {
	// WithComments <code>true</code> to apply comment counts in the changes (the default); otherwise, <code>false</code> to stream changes without comment counts
	WithComments *string `form:"withComments,omitempty" json:"withComments,omitempty"`

	// Since The commit to which <code>until</code> should be compared to produce a page of changes. If not specified the commit's first parent is assumed (if one exists)
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCommentsParams defines parameters for GetComments.
type GetCommentsParams struct {
	// Path The path to the file on which comments were made
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// Since For a merge commit, a parent can be provided to specify which diff the comments are on. For a commit range, a sinceId can be provided to specify where the comments are anchored from.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateCommentParams defines parameters for CreateComment.
type CreateCommentParams struct {
	// Since For a merge commit, a parent can be provided to specify which diff the comments should be on. For a commit range, a sinceId can be provided to specify where the comments should be anchored from.
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// DeleteCommentParams defines parameters for DeleteComment.
type DeleteCommentParams struct {
	// Version The expected version of the comment. This must match the server's version of the comment or the delete will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the delete. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// Delete1Params defines parameters for Delete1.
type Delete1Params struct {
	// DeploymentSequenceNumber the sequence number of the deployment, as detailed by the query parameter
	DeploymentSequenceNumber *string `form:"deploymentSequenceNumber,omitempty" json:"deploymentSequenceNumber,omitempty"`

	// Key the key of the deployment, as detailed by the query parameter
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// EnvironmentKey the key of the environment, as detailed by the query parameter
	EnvironmentKey *string `form:"environmentKey,omitempty" json:"environmentKey,omitempty"`
}

// Get1Params defines parameters for Get1.
type Get1Params struct {
	// DeploymentSequenceNumber the sequence number of the deployment, as detailed by the query param
	DeploymentSequenceNumber *string `form:"deploymentSequenceNumber,omitempty" json:"deploymentSequenceNumber,omitempty"`

	// Key the key of the deployment, as detailed by the query parameter
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// EnvironmentKey the key of the environment, as detailed by the query parameter
	EnvironmentKey *string `form:"environmentKey,omitempty" json:"environmentKey,omitempty"`
}

// GetDiffStatsSummaryParams defines parameters for GetDiffStatsSummary.
type GetDiffStatsSummaryParams struct {
	// SrcPath The source path for the file, if it was copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// AutoSrcPath <code>true</code> to automatically try to find the source path when it's not provided, <code>false</code> otherwise. Requires the path to be provided.
	AutoSrcPath *string `form:"autoSrcPath,omitempty" json:"autoSrcPath,omitempty"`

	// Whitespace Optional whitespace flag which can be set to ignore-all
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`

	// Since The base revision to diff from. If omitted the parent revision of the commit ID is used
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// StreamDiffParams defines parameters for StreamDiff.
type StreamDiffParams struct {
	// SrcPath The source path for the file, if it was copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// AvatarSize If present the service adds avatar URLs for comment authors where the provided value specifies the desired avatar size in pixels. Not applicable if streaming raw diff
	AvatarSize *string `form:"avatarSize,omitempty" json:"avatarSize,omitempty"`

	// Filter Text used to filter files and lines (optional). Not applicable if streaming raw diff
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// AvatarScheme The security scheme for avatar URLs. If the scheme is not present then it is inherited from the request. It can be set to "https" to force the use of secure URLs. Not applicable if streaming raw diff
	AvatarScheme *string `form:"avatarScheme,omitempty" json:"avatarScheme,omitempty"`

	// ContextLines The number of context lines to include around added/removed lines in the diff.Not applicable if streaming raw diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// AutoSrcPath <code>true</code> to automatically try to find the source path when it's not provided, <code>false</code> otherwise. Requires the path to be provided.
	AutoSrcPath *string `form:"autoSrcPath,omitempty" json:"autoSrcPath,omitempty"`

	// Whitespace Optional whitespace flag which can be set to ignore-all
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`

	// WithComments <code>true</code> to embed comments in the diff (the default); otherwise <code>false</code> to stream the diff without comments. Not applicable if streaming raw diff
	WithComments *string `form:"withComments,omitempty" json:"withComments,omitempty"`

	// Since The base revision to diff from. If omitted the parent revision of the until revision is used
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// GetMergeBaseParams defines parameters for GetMergeBase.
type GetMergeBaseParams struct {
	// OtherCommitId The other commit id to calculate the merge-base on
	OtherCommitId *string `form:"otherCommitId,omitempty" json:"otherCommitId,omitempty"`
}

// GetPullRequestsParams defines parameters for GetPullRequests.
type GetPullRequestsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamChangesParams defines parameters for StreamChanges.
type StreamChangesParams struct {
	// FromRepo an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID <em>fromRepo=42</em> or by its project key plus its repo slug separated by a slash: <em>fromRepo=projectKey/repoSlug</em>
	FromRepo *string `form:"fromRepo,omitempty" json:"fromRepo,omitempty"`

	// From the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamCommitsParams defines parameters for StreamCommits.
type StreamCommitsParams struct {
	// FromRepo an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID <em>fromRepo=42</em> or by its project key plus its repo slug separated by a slash: <em>fromRepo=projectKey/repoSlug</em>
	FromRepo *string `form:"fromRepo,omitempty" json:"fromRepo,omitempty"`

	// From the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetDiffStatsSummary1Params defines parameters for GetDiffStatsSummary1.
type GetDiffStatsSummary1Params struct {
	// FromRepo an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID <em>fromRepo=42</em> or by its project key plus its repo slug separated by a slash: <em>fromRepo=projectKey/repoSlug</em>
	FromRepo *string `form:"fromRepo,omitempty" json:"fromRepo,omitempty"`

	// SrcPath source path
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// From the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Whitespace an optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`
}

// StreamDiff1Params defines parameters for StreamDiff1.
type StreamDiff1Params struct {
	// ContextLines an optional number of context lines to include around each added or removed lines in the diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// FromRepo an optional parameter specifying the source repository containing the source commit if that commit is not present in the current repository; the repository can be specified by either its ID <em>fromRepo=42</em> or by its project key plus its repo slug separated by a slash: <em>fromRepo=projectKey/repoSlug</em>
	FromRepo *string `form:"fromRepo,omitempty" json:"fromRepo,omitempty"`

	// SrcPath source path
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// From the source commit (can be a partial/full commit ID or qualified/unqualified ref name)
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// To the target commit (can be a partial/full commit ID or qualified/unqualified ref name)
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// Whitespace an optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`
}

// StreamContributingParams defines parameters for StreamContributing.
type StreamContributingParams struct {
	// At A specific commit or ref to retrieve the guidelines at, or the default branch if not specified
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Markup If present or <code>"true"</code>, triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than <code>"true"</code>, the content is streamed without markup
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// HtmlEscape (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the <code>markup.render.html.escape</code> property, which is <code>true</code> by default, will be used
	HtmlEscape *string `form:"htmlEscape,omitempty" json:"htmlEscape,omitempty"`

	// IncludeHeadingId (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the <code>markup.render.headerids</code> property, which is false by default, will be used
	IncludeHeadingId *string `form:"includeHeadingId,omitempty" json:"includeHeadingId,omitempty"`

	// Hardwrap (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the <code>markup.render.hardwrap</code> property, which is <code>true</code> by default, will be used
	Hardwrap *string `form:"hardwrap,omitempty" json:"hardwrap,omitempty"`
}

// StreamRawDiffParams defines parameters for StreamRawDiff.
type StreamRawDiffParams struct {
	// ContextLines The number of context lines to include around added/removed lines in the diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// SrcPath The source path for the file, if it was copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// Until The target revision to diff to (required)
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// Whitespace Optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`

	// Since The base revision to diff from. If omitted the parent revision of the until revision is used
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// StreamRawDiff1Params defines parameters for StreamRawDiff1.
type StreamRawDiff1Params struct {
	// ContextLines The number of context lines to include around added/removed lines in the diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// SrcPath The source path for the file, if it was copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// Until The target revision to diff to (required)
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// Whitespace Optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`

	// Since The base revision to diff from. If omitted the parent revision of the until revision is used
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// StreamFilesParams defines parameters for StreamFiles.
type StreamFilesParams struct {
	// At The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamFiles1Params defines parameters for StreamFiles1.
type StreamFiles1Params struct {
	// At The commit ID or ref (e.g. a branch or tag) to list the files at. If not specified the default branch will be used instead.
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetForkedRepositoriesParams defines parameters for GetForkedRepositories.
type GetForkedRepositoriesParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConfigurations1Params defines parameters for GetConfigurations1.
type GetConfigurations1Params struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamParams defines parameters for Stream.
type StreamParams struct {
	// At The commit to use as the starting point when listing files and calculating modifications
	At *string `form:"at,omitempty" json:"at,omitempty"`
}

// Stream1Params defines parameters for Stream1.
type Stream1Params struct {
	// At The commit to use as the starting point when listing files and calculating modifications
	At *string `form:"at,omitempty" json:"at,omitempty"`
}

// StreamLicenseParams defines parameters for StreamLicense.
type StreamLicenseParams struct {
	// At A specific commit or ref to retrieve the guidelines at, or the default branch if not specified
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Markup If present or <code>"true"</code>, triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than <code>"true"</code>, the content is streamed without markup
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// HtmlEscape (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the <code>markup.render.html.escape</code> property, which is <code>true</code> by default, will be used
	HtmlEscape *string `form:"htmlEscape,omitempty" json:"htmlEscape,omitempty"`

	// IncludeHeadingId (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the <code>markup.render.headerids</code> property, which is false by default, will be used
	IncludeHeadingId *string `form:"includeHeadingId,omitempty" json:"includeHeadingId,omitempty"`

	// Hardwrap (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the <code>markup.render.hardwrap</code> property, which is <code>true</code> by default, will be used
	Hardwrap *string `form:"hardwrap,omitempty" json:"hardwrap,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Filter (optional) Return only users, whose username, name or email address <i>contain</i> the filter value
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Role (optional) The role associated with the pull request participant. This must be one of AUTHOR, REVIEWER, or PARTICIPANT
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// Direction (optional), Defaults to <strong>INCOMING</strong>) the direction relative to the specified repository. Either <strong>INCOMING</strong> or <strong>OUTGOING</strong>.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamPatchParams defines parameters for StreamPatch.
type StreamPatchParams struct {
	// Until The target revision from which to generate the patch (required)
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// AllAncestors indicates whether or not to generate a patch which includes all the ancestors of the 'until' revision. If true, the value provided by 'since' is ignored.
	AllAncestors *string `form:"allAncestors,omitempty" json:"allAncestors,omitempty"`

	// Since The base revision from which to generate the patch. This is only applicable when 'allAncestors' is false. If omitted the patch will represent one single commit, the 'until'.
	Since *string `form:"since,omitempty" json:"since,omitempty"`
}

// RevokePermissions1Params defines parameters for RevokePermissions1.
type RevokePermissions1Params struct {
	// User The names of the users
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Group The names of the groups
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// RevokePermissionsForGroup2Params defines parameters for RevokePermissionsForGroup2.
type RevokePermissionsForGroup2Params struct {
	// Name The name of the group.
	Name string `form:"name" json:"name"`
}

// GetGroupsWithAnyPermission2Params defines parameters for GetGroupsWithAnyPermission2.
type GetGroupsWithAnyPermission2Params struct {
	// Filter If specified only group names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForGroupParams defines parameters for SetPermissionForGroup.
type SetPermissionForGroupParams struct {
	// Name The names of the groups.
	Name []string `form:"name" json:"name"`

	// Permission The permission to grant
	Permission SetPermissionForGroupParamsPermission `form:"permission" json:"permission"`
}

// SetPermissionForGroupParamsPermission defines parameters for SetPermissionForGroup.
type SetPermissionForGroupParamsPermission string

// GetGroupsWithoutAnyPermission2Params defines parameters for GetGroupsWithoutAnyPermission2.
type GetGroupsWithoutAnyPermission2Params struct {
	// Filter If specified only group names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SearchPermissions1Params defines parameters for SearchPermissions1.
type SearchPermissions1Params struct {
	// Permission Permissions to filter by. See the [permissions documentation](https://confluence.atlassian.com/display/BitbucketServer/Using+repository+permissions)for a detailed explanation of what each permission entails. This parameter can be specified multiple times to filter by more than one permission, and can contain repository, project, and global permissions.
	//
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// FilterText Name of the user or group to filter the name of
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// Type Type of entity (user or group)Valid entity types are:
	//
	// - USER- GROUP
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// RevokePermissionsForUser2Params defines parameters for RevokePermissionsForUser2.
type RevokePermissionsForUser2Params struct {
	// Name The name of the user.
	Name string `form:"name" json:"name"`
}

// GetUsersWithAnyPermission2Params defines parameters for GetUsersWithAnyPermission2.
type GetUsersWithAnyPermission2Params struct {
	// Filter If specified only user names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPermissionForUserParams defines parameters for SetPermissionForUser.
type SetPermissionForUserParams struct {
	// Name The names of the users.
	Name []string `form:"name" json:"name"`

	// Permission The permission to grant
	Permission SetPermissionForUserParamsPermission `form:"permission" json:"permission"`
}

// SetPermissionForUserParamsPermission defines parameters for SetPermissionForUser.
type SetPermissionForUserParamsPermission string

// GetUsersWithoutPermission1Params defines parameters for GetUsersWithoutPermission1.
type GetUsersWithoutPermission1Params struct {
	// Filter If specified only user names containing the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPageParams defines parameters for GetPage.
type GetPageParams struct {
	// WithAttributes (optional) defaults to true, whether to return additional pull request attributes
	WithAttributes *string `form:"withAttributes,omitempty" json:"withAttributes,omitempty"`

	// At (optional) a <i>fully-qualified</i> branch ID to find pull requests to or from, such as refs/heads/master
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// WithProperties (optional) defaults to true, whether to return additional pull request properties
	WithProperties *string `form:"withProperties,omitempty" json:"withProperties,omitempty"`

	// Draft (optional) If specified, only pull requests matching the supplied draft status will be returned.
	Draft *string `form:"draft,omitempty" json:"draft,omitempty"`

	// FilterText (optional) If specified, only pull requests where the title or description contains the supplied string will be returned.
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// State (optional, defaults to <strong>OPEN</strong>). Supply <strong>ALL</strong> to return pull request in any state. If a state is supplied only pull requests in the specified state will be returned. Either <strong>OPEN</strong>, <strong>DECLINED</strong> or <strong>MERGED</strong>.
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Order (optional, defaults to <strong>NEWEST</strong>) the order to return pull requests in, either <strong>OLDEST</strong> (as in: "oldest first") or <strong>NEWEST</strong>.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Direction (optional, defaults to <strong>INCOMING</strong>) the direction relative to the specified repository. Either <strong>INCOMING</strong> or <strong>OUTGOING</strong>.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StreamRawDiff2Params defines parameters for StreamRawDiff2.
type StreamRawDiff2Params struct {
	// ContextLines The number of context lines to include around added/removed lines in the diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// Whitespace optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`
}

// GetActivitiesParams defines parameters for GetActivities.
type GetActivitiesParams struct {
	// FromType (required if <strong>fromId</strong> is present) the type of the activity item specified by <strong>fromId</strong> (either <strong>COMMENT</strong> or <strong>ACTIVITY</strong>)
	FromType *string `form:"fromType,omitempty" json:"fromType,omitempty"`

	// FromId (optional) the ID of the activity item to use as the first item in the returned page
	FromId *string `form:"fromId,omitempty" json:"fromId,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetComments1Params defines parameters for GetComments1.
type GetComments1Params struct {
	// Count If true only the count of the comments by state will be returned (and not the body of the comments).
	Count *string   `form:"count,omitempty" json:"count,omitempty"`
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// States (optional). If supplied, only comments with a state in the given list will be returned. The state can be OPEN or RESOLVED.
	States *string `form:"states,omitempty" json:"states,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteComment1Params defines parameters for DeleteComment1.
type DeleteComment1Params struct {
	// Version The expected version of the comment. This must match the server's version of the comment or the delete will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the delete. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// StreamChanges1Params defines parameters for StreamChanges1.
type StreamChanges1Params struct {
	// SinceId The since commit hash to stream changes for a RANGE arbitrary change scope
	SinceId *string `form:"sinceId,omitempty" json:"sinceId,omitempty"`

	// ChangeScope UNREVIEWED to stream the unreviewed changes for the current user (if they exist); RANGE to stream changes between two arbitrary commits (requires 'sinceId' and 'untilId'); otherwise ALL to stream all changes (the default)
	ChangeScope *string `form:"changeScope,omitempty" json:"changeScope,omitempty"`

	// UntilId The until commit hash to stream changes for a RANGE arbitrary change scope
	UntilId *string `form:"untilId,omitempty" json:"untilId,omitempty"`

	// WithComments true to apply comment counts in the changes (the default); otherwise, false to stream changes without comment counts
	WithComments *string `form:"withComments,omitempty" json:"withComments,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetComments2Params defines parameters for GetComments2.
type GetComments2Params struct {
	// Path The path to stream comments for a given path
	Path string `form:"path" json:"path"`

	// FromHash The from commit hash to stream comments for a RANGE or COMMIT arbitrary change scope
	FromHash *string `form:"fromHash,omitempty" json:"fromHash,omitempty"`

	// AnchorState ACTIVE to stream the active comments; ORPHANED to stream the orphaned comments; ALL to stream both the active and the orphaned comments;
	AnchorState *string   `form:"anchorState,omitempty" json:"anchorState,omitempty"`
	DiffType    *[]string `form:"diffType,omitempty" json:"diffType,omitempty"`

	// ToHash The to commit hash to stream comments for a RANGE or COMMIT arbitrary change scope
	ToHash *string   `form:"toHash,omitempty" json:"toHash,omitempty"`
	State  *[]string `form:"state,omitempty" json:"state,omitempty"`

	// DiffTypes EFFECTIVE to stream the comments related to the effective diff of the pull request; RANGE to stream comments related to a commit range between two arbitrary commits (requires 'fromHash' and 'toHash'); COMMIT to stream comments related to a commit between two arbitrary commits (requires 'fromHash' and 'toHash')
	DiffTypes *string `form:"diffTypes,omitempty" json:"diffTypes,omitempty"`

	// States (optional). If supplied, only comments with a state in the given list will be returned. The state can be OPEN or RESOLVED.
	States *string `form:"states,omitempty" json:"states,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteComment2Params defines parameters for DeleteComment2.
type DeleteComment2Params struct {
	// Version The expected version of the comment. This must match the server's version of the comment or the delete will fail. To determine the current version of the comment, the comment should be fetched from the server prior to the delete. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// GetCommits1Params defines parameters for GetCommits1.
type GetCommits1Params struct {
	// AvatarScheme The desired scheme for the avatar URL. If the parameter is not present URLs will use the same scheme as this request
	AvatarScheme *string `form:"avatarScheme,omitempty" json:"avatarScheme,omitempty"`

	// WithCounts If set to true, the service will add "authorCount" and "totalCount" at the end of the page. "authorCount" is the number of different authors and "totalCount" is the total number of commits.
	WithCounts *string `form:"withCounts,omitempty" json:"withCounts,omitempty"`

	// AvatarSize If present the service adds avatar URLs for commit authors. Should be an integer specifying the desired size in pixels. If the parameter is not present, avatar URLs will not be setCOMMIT to stream comments related to a commit between two arbitrary commits (requires 'fromHash' and 'toHash')
	AvatarSize *string `form:"avatarSize,omitempty" json:"avatarSize,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeclineParams defines parameters for Decline.
type DeclineParams struct {
	// Version The current version of the pull request. If the server's version isn't the same as the specified version the operation will fail. To determine the current version of the pull request it should be fetched from the server prior to this operation. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// GetDiffStatsSummary2Params defines parameters for GetDiffStatsSummary2.
type GetDiffStatsSummary2Params struct {
	// SinceId The since commit hash to stream a diff between two arbitrary hashes
	SinceId *string `form:"sinceId,omitempty" json:"sinceId,omitempty"`

	// SrcPath The previous path to the file, if the file has been copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// UntilId The until commit hash to stream a diff between two arbitrary hashes
	UntilId *string `form:"untilId,omitempty" json:"untilId,omitempty"`

	// Whitespace Optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`
}

// StreamDiff2Params defines parameters for StreamDiff2.
type StreamDiff2Params struct {
	// AvatarScheme The security scheme for avatar URLs. If the scheme is not present then it is inherited from the request. It can be set to "https" to force the use of secure URLs. Not applicable if streaming raw diff
	AvatarScheme *string `form:"avatarScheme,omitempty" json:"avatarScheme,omitempty"`

	// ContextLines The number of context lines to include around added/removed lines in the diff
	ContextLines *string `form:"contextLines,omitempty" json:"contextLines,omitempty"`

	// SinceId The since commit hash to stream a diff between two arbitrary hashes
	SinceId *string `form:"sinceId,omitempty" json:"sinceId,omitempty"`

	// SrcPath The previous path to the file, if the file has been copied, moved or renamed
	SrcPath *string `form:"srcPath,omitempty" json:"srcPath,omitempty"`

	// DiffType The type of diff being requested. When withComments is true this works as a hint to the system to attach the correct set of comments to the diff. Not applicable if streaming raw diff
	DiffType *string `form:"diffType,omitempty" json:"diffType,omitempty"`

	// UntilId The until commit hash to stream a diff between two arbitrary hashes
	UntilId *string `form:"untilId,omitempty" json:"untilId,omitempty"`

	// Whitespace Optional whitespace flag which can be set to <code>ignore-all</code>
	Whitespace *string `form:"whitespace,omitempty" json:"whitespace,omitempty"`

	// WithComments <code>true</code> to embed comments in the diff (the default); otherwise, <code>false</code> to stream the diff without comments. Not applicable if streaming raw diff
	WithComments *string `form:"withComments,omitempty" json:"withComments,omitempty"`

	// AvatarSize If present the service adds avatar URLs for comment authors where the provided value specifies the desired avatar size in pixels. Not applicable if streaming raw diff
	AvatarSize *string `form:"avatarSize,omitempty" json:"avatarSize,omitempty"`
}

// MergeParams defines parameters for Merge.
type MergeParams struct {
	// Version The current version of the pull request. If the server's version isn't the same as the specified version the operation will fail. To determine the current version of the pull request it should be fetched from the server prior to this operation. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// UnassignParticipantRole1Params defines parameters for UnassignParticipantRole1.
type UnassignParticipantRole1Params struct {
	Username *string `form:"username,omitempty" json:"username,omitempty"`
}

// ListParticipantsParams defines parameters for ListParticipants.
type ListParticipantsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateStatusParams defines parameters for UpdateStatus.
type UpdateStatusParams struct {
	// Version The current version of the pull request. If the server's version isn't the same as the specified version the operation will fail. To determine the current version of the pull request it should be fetched from the server prior to this operation. Look for the 'version' attribute in the returned JSON structure. Note: This parameter is deprecated. Use last reviewed commit in request body instead
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// ReopenParams defines parameters for Reopen.
type ReopenParams struct {
	// Version The current version of the pull request. If the server's version isn't the same as the specified version the operation will fail. To determine the current version of the pull request it should be fetched from the server prior to this operation. Look for the 'version' attribute in the returned JSON structure.
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// GetReviewParams defines parameters for GetReview.
type GetReviewParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FinishReviewParams defines parameters for FinishReview.
type FinishReviewParams struct {
	// Version The current version of the pull request. If the server's version isn't the same as the specified version the operation will fail. To determine the current version of the pull request it should be fetched from the server prior to this operation. Look for the 'version' attribute in the returned JSON structure. Note: This parameter is deprecated. Use last reviewed commit in request body instead
	Version *string `form:"version,omitempty" json:"version,omitempty"`
}

// StreamRawParams defines parameters for StreamRaw.
type StreamRawParams struct {
	// At A specific commit or ref to retrieve the raw content at, or the default branch if not specified
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Markup If present or "true", triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than "true", the content is streamed without markup
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// HtmlEscape (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the markup.render.html.escape property, which is true by default, will be used
	HtmlEscape *string `form:"htmlEscape,omitempty" json:"htmlEscape,omitempty"`

	// IncludeHeadingId (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the markup.render.headerids property, which is false by default, will be used
	IncludeHeadingId *string `form:"includeHeadingId,omitempty" json:"includeHeadingId,omitempty"`

	// Hardwrap (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the markup.render.hardwrap property, which is true by default, will be used
	Hardwrap *string `form:"hardwrap,omitempty" json:"hardwrap,omitempty"`
}

// StreamReadmeParams defines parameters for StreamReadme.
type StreamReadmeParams struct {
	// At A specific commit or ref to retrieve the guidelines at, or the default branch if not specified
	At *string `form:"at,omitempty" json:"at,omitempty"`

	// Markup If present or <code>"true"</code>, triggers the raw content to be markup-rendered and returned as HTML; otherwise, if not specified, or any value other than <code>"true"</code>, the content is streamed without markup
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// HtmlEscape (Optional) true if HTML should be escaped in the input markup, false otherwise. If not specified, the value of the <code>markup.render.html.escape</code> property, which is <code>true</code> by default, will be used
	HtmlEscape *string `form:"htmlEscape,omitempty" json:"htmlEscape,omitempty"`

	// IncludeHeadingId (Optional) true if headings should contain an ID based on the heading content. If not specified, the value of the <code>markup.render.headerids</code> property, which is false by default, will be used
	IncludeHeadingId *string `form:"includeHeadingId,omitempty" json:"includeHeadingId,omitempty"`

	// Hardwrap (Optional) Whether the markup implementation should convert newlines to breaks. If not specified, the value of the <code>markup.render.hardwrap</code> property, which is <code>true</code> by default, will be used
	Hardwrap *string `form:"hardwrap,omitempty" json:"hardwrap,omitempty"`
}

// GetRefChangeActivityParams defines parameters for GetRefChangeActivity.
type GetRefChangeActivityParams struct {
	// Ref (optional) exact match for a ref ID to filter ref change activity for
	Ref *string `form:"ref,omitempty" json:"ref,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindBranchesParams defines parameters for FindBranches.
type FindBranchesParams struct {
	// FilterText (optional) Partial match for a ref ID to filter minimal refs for
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRelatedRepositoriesParams defines parameters for GetRelatedRepositories.
type GetRelatedRepositoriesParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// Search2Params defines parameters for Search2.
type Search2Params struct {
	// Filter Filter names by the provided text
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Order Order by
	Order *Search2ParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// Search2ParamsOrder defines parameters for Search2.
type Search2ParamsOrder string

// Search3Params defines parameters for Search3.
type Search3Params struct {
	// Filter Filter names by the provided text
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Order Order by
	Order *Search3ParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// Search3ParamsOrder defines parameters for Search3.
type Search3ParamsOrder string

// GetRepositoryHooks1Params defines parameters for GetRepositoryHooks1.
type GetRepositoryHooks1Params struct {
	// Type The optional type to filter by.
	Type *GetRepositoryHooks1ParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRepositoryHooks1ParamsType defines parameters for GetRepositoryHooks1.
type GetRepositoryHooks1ParamsType string

// EnableHook1Params defines parameters for EnableHook1.
type EnableHook1Params struct {
	// ContentLength The content length.
	ContentLength *string `json:"Content-Length,omitempty"`
}

// GetReviewerGroups1Params defines parameters for GetReviewerGroups1.
type GetReviewerGroups1Params struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// OrderBy Ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// FilterText The text to match on.
	FilterText *string `form:"filterText,omitempty" json:"filterText,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindWebhooks1Params defines parameters for FindWebhooks1.
type FindWebhooks1Params struct {
	// Event List of <code>com.atlassian.webhooks.WebhookEvent</code> IDs to filter for
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// Statistics <code>true</code> if statistics should be provided for all found webhooks
	Statistics *bool `form:"statistics,omitempty" json:"statistics,omitempty"`
}

// SearchWebhooksParams defines parameters for SearchWebhooks.
type SearchWebhooksParams struct {
	// ScopeType Scopes to filter by. This parameter can be specified once e.g. "scopeType=repository", or twice e.g. "scopeType=repository&scopeType=project", to filter by more than one scope level.
	ScopeType *string `form:"scopeType,omitempty" json:"scopeType,omitempty"`

	// Event List of <code>com.atlassian.webhooks.WebhookEvent</code> ids to filter for
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// Statistics <code>true</code> if statistics should be provided for all found webhooks
	Statistics *bool `form:"statistics,omitempty" json:"statistics,omitempty"`
}

// TestWebhook1Params defines parameters for TestWebhook1.
type TestWebhook1Params struct {
	WebhookId *int32 `form:"webhookId,omitempty" json:"webhookId,omitempty"`

	// SslVerificationRequired Whether SSL verification is required for the specified webhook URL. Default value is  <code>true</code>.
	SslVerificationRequired *string `form:"sslVerificationRequired,omitempty" json:"sslVerificationRequired,omitempty"`

	// Url The url in which to connect to
	Url *string `form:"url,omitempty" json:"url,omitempty"`
}

// GetWebhook1Params defines parameters for GetWebhook1.
type GetWebhook1Params struct {
	// Statistics <code>true</code> if statistics should be provided for the webhook
	Statistics *string `form:"statistics,omitempty" json:"statistics,omitempty"`
}

// GetLatestInvocation1Params defines parameters for GetLatestInvocation1.
type GetLatestInvocation1Params struct {
	// Event The string ID of a specific event to retrieve the last invocation for.
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// Outcome The outcome to filter for. Can be SUCCESS, FAILURE, ERROR. None specified means that the all will be considered
	Outcome *string `form:"outcome,omitempty" json:"outcome,omitempty"`
}

// GetStatistics1Params defines parameters for GetStatistics1.
type GetStatistics1Params struct {
	// Event The string ID of a specific event to retrieve the last invocation for. May be empty, in which case all events are considered
	Event *string `form:"event,omitempty" json:"event,omitempty"`
}

// SearchAllowlistRuleParams defines parameters for SearchAllowlistRule.
type SearchAllowlistRuleParams struct {
	// Filter Filter names by the provided text
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Order Order by
	Order *SearchAllowlistRuleParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SearchAllowlistRuleParamsOrder defines parameters for SearchAllowlistRule.
type SearchAllowlistRuleParamsOrder string

// Search1Params defines parameters for Search1.
type Search1Params struct {
	// Filter Filter names by the provided text
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Order Order by
	Order *Search1ParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// Search1ParamsOrder defines parameters for Search1.
type Search1ParamsOrder string

// Delete9Params defines parameters for Delete9.
type Delete9Params struct {
	// Namespace A namespace used to identify the provider of the feature
	Namespace string `form:"namespace" json:"namespace"`

	// ComponentKey A key to uniquely identify individually restrictable subcomponents of a feature within the provided feature key and namespace
	ComponentKey *string `form:"componentKey,omitempty" json:"componentKey,omitempty"`

	// FeatureKey A key to uniquely identify the feature within the provided namespace
	FeatureKey string `form:"featureKey" json:"featureKey"`
}

// Get7Params defines parameters for Get7.
type Get7Params struct {
	// Namespace The namespace used to identify the provider of the feature
	Namespace string `form:"namespace" json:"namespace"`

	// ComponentKey The component key to uniquely identify individually restrictable subcomponents of a feature within the provided feature key and namespace
	ComponentKey *string `form:"componentKey,omitempty" json:"componentKey,omitempty"`

	// FeatureKey The feature key to uniquely identify the feature within the provided namespace
	FeatureKey string `form:"featureKey" json:"featureKey"`
}

// GetAllParams defines parameters for GetAll.
type GetAllParams struct {
	// Namespace A namespace used to identify the provider of the feature
	Namespace string `form:"namespace" json:"namespace"`

	// FeatureKey A key to uniquely identify the feature within the provided namespace
	FeatureKey string `form:"featureKey" json:"featureKey"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRepositoryHooksParams defines parameters for GetRepositoryHooks.
type GetRepositoryHooksParams struct {
	// Type The optional type to filter by.
	Type *GetRepositoryHooksParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRepositoryHooksParamsType defines parameters for GetRepositoryHooks.
type GetRepositoryHooksParamsType string

// EnableHookParams defines parameters for EnableHook.
type EnableHookParams struct {
	// ContentLength The content length.
	ContentLength *int64 `json:"Content-Length,omitempty"`
}

// GetReviewerGroupsParams defines parameters for GetReviewerGroups.
type GetReviewerGroupsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindWebhooksParams defines parameters for FindWebhooks.
type FindWebhooksParams struct {
	// Event List of <code>com.atlassian.webhooks.WebhookEvent</code> IDs to filter for
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// Statistics <code>true</code> if statistics should be provided for all found webhooks
	Statistics *bool `form:"statistics,omitempty" json:"statistics,omitempty"`
}

// TestWebhookParams defines parameters for TestWebhook.
type TestWebhookParams struct {
	WebhookId               *int32 `form:"webhookId,omitempty" json:"webhookId,omitempty"`
	SslVerificationRequired *bool  `form:"sslVerificationRequired,omitempty" json:"sslVerificationRequired,omitempty"`

	// Url The url in which to connect to
	Url *string `form:"url,omitempty" json:"url,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// Statistics <code>true</code> if statistics should be provided for the webhook
	Statistics *string `form:"statistics,omitempty" json:"statistics,omitempty"`
}

// GetLatestInvocationParams defines parameters for GetLatestInvocation.
type GetLatestInvocationParams struct {
	// Event The string ID of a specific event to retrieve the last invocation for.
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// Outcome The outcome to filter for. Can be SUCCESS, FAILURE, ERROR. None specified means that the all will be considered
	Outcome *string `form:"outcome,omitempty" json:"outcome,omitempty"`
}

// GetStatisticsParams defines parameters for GetStatistics.
type GetStatisticsParams struct {
	// Event The string ID of a specific event to retrieve the last invocation for. May be empty, in which case all events are considered
	Event *string `form:"event,omitempty" json:"event,omitempty"`
}

// GetRepositories1Params defines parameters for GetRepositories1.
type GetRepositories1Params struct {
	// Archived (optional) if specified, this will limit the resulting repository list to ones whose are <tt>ACTIVE</tt>, <tt>ARCHIVED</tt> or <tt>ALL</tt> for both. The match performed is case-insensitive. This filter defaults to <tt>ACTIVE</tt> when not set. <em>Available since 8.0</em>
	Archived *string `form:"archived,omitempty" json:"archived,omitempty"`

	// Projectname (optional) if specified, this will limit the resulting repository list to ones whose project's name matches this parameter's value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the <code>projectname</code> parameter will be stripped.
	Projectname *string `form:"projectname,omitempty" json:"projectname,omitempty"`

	// Projectkey (optional) if specified, this will limit the resulting repository list to ones whose project's key matches this parameter's value. The match performed is case-insensitive and any leading  and/or trailing whitespace characters on the <code>projectKey</code> parameter will be stripped. <em>Available since 8.0</em>
	Projectkey *string `form:"projectkey,omitempty" json:"projectkey,omitempty"`

	// Visibility (optional) if specified, this will limit the resulting repository list based on the repositories visibility. Valid values are <em>public</em> or <em>private</em>.
	Visibility *GetRepositories1ParamsVisibility `form:"visibility,omitempty" json:"visibility,omitempty"`

	// Name (optional) if specified, this will limit the resulting repository list to ones whose name matches this parameter's value. The match performed is case-insensitive and any leading and/or trailing whitespace characters on the <code>name</code> parameter will be stripped.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Permission (optional) if specified, it must be a valid repository permission level name and will limit the resulting repository list to ones that the requesting user has the specified permission level to. If not specified, the default implicit 'read' permission level will be assumed. The currently supported explicit permission values are <tt>REPO_READ</tt>, <tt>REPO_WRITE</tt> and <tt>REPO_ADMIN</tt>.
	Permission *GetRepositories1ParamsPermission `form:"permission,omitempty" json:"permission,omitempty"`

	// State (optional) if specified, it must be a valid repository state name and will limit the resulting repository list to ones that are in the specified state. The currently supported explicit state values are <tt>AVAILABLE</tt>, <tt>INITIALISING</tt>, <tt>INITIALISATION_FAILED</tt> and <tt>OFFLINE</tt>.<br> <em>Available since 5.13</em>
	State *GetRepositories1ParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRepositories1ParamsVisibility defines parameters for GetRepositories1.
type GetRepositories1ParamsVisibility string

// GetRepositories1ParamsPermission defines parameters for GetRepositories1.
type GetRepositories1ParamsPermission string

// GetRepositories1ParamsState defines parameters for GetRepositories1.
type GetRepositories1ParamsState string

// FindExemptReposByScopeParams defines parameters for FindExemptReposByScope.
type FindExemptReposByScopeParams struct {
	// Order Order by project name followed by repository name either ascending or descending, defaults to ascending.
	Order *FindExemptReposByScopeParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindExemptReposByScopeParamsOrder defines parameters for FindExemptReposByScope.
type FindExemptReposByScopeParamsOrder string

// Search4Params defines parameters for Search4.
type Search4Params struct {
	// Filter Filter by rule name
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Order Order by
	Order *Search4ParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// Search4ParamsOrder defines parameters for Search4.
type Search4ParamsOrder string

// UpdateSystemSigningConfigurationJSONBody defines parameters for UpdateSystemSigningConfiguration.
type UpdateSystemSigningConfigurationJSONBody struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// GetUsers2Params defines parameters for GetUsers2.
type GetUsers2Params struct {
	// Filter Return only users, whose username, name or email address <i>contain</i> the <code> filter</code> value
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// PermissionN The "root" of a single permission filter, similar to the <code>permission</code> parameter, where "N" is a natural number starting from 1. This allows clients to specify multiple permission filters, by providing consecutive filters as <code>permission.1</code>, <code>permission.2</code> etc. Note that the filters numbering has to start with 1 and be continuous for all filters to be processed. The total allowed number of permission filters is 50 and all filters exceeding that limit will be dropped. See the section "Permission Filters" above for more details on how the permission filters are processed.
	PermissionN *string `form:"permission.N,omitempty" json:"permission.N,omitempty"`

	// Permission The "root" of a permission filter, whose value must be a valid global, project, or repository permission. Additional filter parameters referring to this filter that specify the resource (project or repository) to apply the filter to must be prefixed with <code>permission.</code>. See the section "Permission Filters" above for more details.
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// Group return only users who are members of the given group
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// UploadAvatar1Params defines parameters for UploadAvatar1.
type UploadAvatar1Params struct {
	// XAtlassianToken This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.
	XAtlassianToken *string `json:"X-Atlassian-Token,omitempty"`
}

// GetRestrictions1Params defines parameters for GetRestrictions1.
type GetRestrictions1Params struct {
	// MatcherType Matcher type to filter on
	MatcherType *GetRestrictions1ParamsMatcherType `form:"matcherType,omitempty" json:"matcherType,omitempty"`

	// MatcherId Matcher id to filter on. Requires the matcherType parameter to be specified also.
	MatcherId *string `form:"matcherId,omitempty" json:"matcherId,omitempty"`

	// Type Types of restrictions to filter on.
	Type *GetRestrictions1ParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRestrictions1ParamsMatcherType defines parameters for GetRestrictions1.
type GetRestrictions1ParamsMatcherType string

// GetRestrictions1ParamsType defines parameters for GetRestrictions1.
type GetRestrictions1ParamsType string

// CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONBody defines parameters for CreateRestrictions1.
type CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONBody = []RestRestrictionRequest

// GetRestrictionsParams defines parameters for GetRestrictions.
type GetRestrictionsParams struct {
	// MatcherType Matcher type to filter on
	MatcherType *GetRestrictionsParamsMatcherType `form:"matcherType,omitempty" json:"matcherType,omitempty"`

	// MatcherId Matcher id to filter on. Requires the matcherType parameter to be specified also.
	MatcherId *string `form:"matcherId,omitempty" json:"matcherId,omitempty"`

	// Type Types of restrictions to filter on.
	Type *GetRestrictionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRestrictionsParamsMatcherType defines parameters for GetRestrictions.
type GetRestrictionsParamsMatcherType string

// GetRestrictionsParamsType defines parameters for GetRestrictions.
type GetRestrictionsParamsType string

// CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONBody defines parameters for CreateRestrictions.
type CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONBody = []RestRestrictionRequest

// FindByCommitParams defines parameters for FindByCommit.
type FindByCommitParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMultipleBuildStatusStatsJSONBody defines parameters for GetMultipleBuildStatusStats.
type GetMultipleBuildStatusStatsJSONBody = []string

// GetBuildStatusStatsParams defines parameters for GetBuildStatusStats.
type GetBuildStatusStatsParams struct {
	// IncludeUnique include a unique build result if there is either only one failed build, only one in-progress build or only one successful build
	IncludeUnique *bool `form:"includeUnique,omitempty" json:"includeUnique,omitempty"`
}

// GetBuildStatusParams defines parameters for GetBuildStatus.
type GetBuildStatusParams struct {
	// OrderBy How the results should be ordered. Options are NEWEST, OLDEST, STATUS
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdatePullRequestCondition1JSONBody defines parameters for UpdatePullRequestCondition1.
type UpdatePullRequestCondition1JSONBody struct {
	RequiredApprovals *int32                 `json:"requiredApprovals,omitempty"`
	Reviewers         *[]RestApplicationUser `json:"reviewers,omitempty"`
	SourceMatcher     *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *UpdatePullRequestCondition1JSONBodySourceMatcherTypeId `json:"id,omitempty"`
			Name *string                                                 `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"sourceMatcher,omitempty"`
	TargetMatcher *struct {
		DisplayId *string `json:"displayId,omitempty"`
		Id        *string `json:"id,omitempty"`
		Type      *struct {
			Id   *UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId `json:"id,omitempty"`
			Name *string                                                 `json:"name,omitempty"`
		} `json:"type,omitempty"`
	} `json:"targetMatcher,omitempty"`
}

// UpdatePullRequestCondition1JSONBodySourceMatcherTypeId defines parameters for UpdatePullRequestCondition1.
type UpdatePullRequestCondition1JSONBodySourceMatcherTypeId string

// UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId defines parameters for UpdatePullRequestCondition1.
type UpdatePullRequestCondition1JSONBodyTargetMatcherTypeId string

// GetReviewersParams defines parameters for GetReviewers.
type GetReviewersParams struct {
	// TargetRepoId The ID of the repository in which the target ref exists
	TargetRepoId *string `form:"targetRepoId,omitempty" json:"targetRepoId,omitempty"`

	// SourceRepoId The ID of the repository in which the source ref exists
	SourceRepoId *string `form:"sourceRepoId,omitempty" json:"sourceRepoId,omitempty"`

	// SourceRefId The ID of the source ref
	SourceRefId *string `form:"sourceRefId,omitempty" json:"sourceRefId,omitempty"`

	// TargetRefId The ID of the target ref
	TargetRefId *string `form:"targetRefId,omitempty" json:"targetRefId,omitempty"`
}

// GetDefaultTasks1Params defines parameters for GetDefaultTasks1.
type GetDefaultTasks1Params struct {
	// Markup If present or `"true"`, includes a markup-rendered description
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetDefaultTasksParams defines parameters for GetDefaultTasks.
type GetDefaultTasksParams struct {
	// Markup If present or "true", includes a markup-rendered description
	Markup *string `form:"markup,omitempty" json:"markup,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteForUserParams defines parameters for DeleteForUser.
type DeleteForUserParams struct {
	// User The username of the user to delete the keys for. If no username is specified, the GPG keys will be deleted for the currently authenticated user.
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// GetKeysForUserParams defines parameters for GetKeysForUser.
type GetKeysForUserParams struct {
	// User The name of the user to get keys for (optional; requires ADMIN permission or higher).
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddKeyParams defines parameters for AddKey.
type AddKeyParams struct {
	// User The name of the user to add a key for (optional; requires ADMIN permission or higher).
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// GetAnnotations1Params defines parameters for GetAnnotations1.
type GetAnnotations1Params struct {
	// Severity Return only annotations that have one of the given severities. Can be specified more than once to filter by more than one severity. Valid severities are <code>LOW</code>, <code>MEDIUM</code> and <code>HIGH</code>.
	Severity *string `form:"severity,omitempty" json:"severity,omitempty"`

	// Path Return only annotations that appear on one of the provided paths. Can be specified more than once to filter by more than one path.
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// ExternalId Return only annotations that have one of the provided external IDs. Can be specified more than once to filter by more than one external ID.
	ExternalId *string `form:"externalId,omitempty" json:"externalId,omitempty"`

	// Type Return only annotations that have one of the given types. Can be specified more than once to filter by multiple types. Valid types are <code>BUG</code>, <code>CODE_SMELL</code>, and <code>VULNERABILITY</code>.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Key Return only annotations that belong to one of the provided report keys. Can be specified more than once to filter by more than one report
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// GetReportsParams defines parameters for GetReports.
type GetReportsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteAnnotationsParams defines parameters for DeleteAnnotations.
type DeleteAnnotationsParams struct {
	// ExternalId The external IDs for the annotations that are to be deleted. Can be specified more than once to delete by more than one external ID, or can be unspecified to delete all annotations.
	ExternalId *string `form:"externalId,omitempty" json:"externalId,omitempty"`
}

// CreateIssueJSONBody defines parameters for CreateIssue.
type CreateIssueJSONBody = string

// CreateIssueParams defines parameters for CreateIssue.
type CreateIssueParams struct {
	// ApplicationId id of the Jira server
	ApplicationId *string `form:"applicationId,omitempty" json:"applicationId,omitempty"`
}

// GetCommitsByIssueKeyParams defines parameters for GetCommitsByIssueKey.
type GetCommitsByIssueKeyParams struct {
	// MaxChanges The maximum number of changes to retrieve for each changeset
	MaxChanges *string `form:"maxChanges,omitempty" json:"maxChanges,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetForRepository1Params defines parameters for GetForRepository1.
type GetForRepository1Params struct {
	// Filter If specified only SSH access keys with a label prefixed with the supplied string will be returned
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Effective Controls whether SSH access keys configured at the project level should be included in the results or not. When set to <code>true</code> all keys that have <em>access</em> to the repository (including project level keys) are included in the results. When set to <code>false</code>, only access keys configured for the specified <code>repository</code> are considered. Default is <code>false</code>.
	Effective *string `form:"effective,omitempty" json:"effective,omitempty"`

	// MinimumPermission If specified only SSH access keys with at least the supplied permission will be returned. Default is <code>Permission.REPO_READ</code>.
	MinimumPermission *string `form:"minimumPermission,omitempty" json:"minimumPermission,omitempty"`
	Permission        *string `form:"permission,omitempty" json:"permission,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSshKeysForProjectParams defines parameters for GetSshKeysForProject.
type GetSshKeysForProjectParams struct {
	// Filter If specified only SSH access keys with a label prefixed with the supplied string will be returned.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Permission If specified only SSH access keys with at least the supplied permission will be returned Default is PROJECT_READ.
	Permission *string `form:"permission,omitempty" json:"permission,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// RevokeManyJSONBody defines parameters for RevokeMany.
type RevokeManyJSONBody struct {
	Projects     *RestProject    `json:"projects,omitempty"`
	Repositories *RestRepository `json:"repositories,omitempty"`
}

// GetForRepositoriesParams defines parameters for GetForRepositories.
type GetForRepositoriesParams struct {
	// WithRestrictions Include the readOnly field. The `readOnly` field is contextual for the user making the request. `readOnly` returns true if there is a restriction and the user does not have`PROJECT_ADMIN` access for the repository the key is associated with.
	WithRestrictions *string `form:"withRestrictions,omitempty" json:"withRestrictions,omitempty"`
}

// SetPreferredMirrorIdJSONBody defines parameters for SetPreferredMirrorId.
type SetPreferredMirrorIdJSONBody = string

// ListMirrorsParams defines parameters for ListMirrors.
type ListMirrorsParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllReposForProjectParams defines parameters for GetAllReposForProject.
type GetAllReposForProjectParams struct {
	// IncludeDefaultBranch includes defaultBranchId in the response, if <code>true</code>. Default value is <code>false</code>
	IncludeDefaultBranch *GetAllReposForProjectParamsIncludeDefaultBranch `form:"includeDefaultBranch,omitempty" json:"includeDefaultBranch,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllReposForProjectParamsIncludeDefaultBranch defines parameters for GetAllReposForProject.
type GetAllReposForProjectParamsIncludeDefaultBranch string

// GetAllContentHashesParams defines parameters for GetAllContentHashes.
type GetAllContentHashesParams struct {
	// IncludeDefaultBranch includes defaultBranchId for each repository in the response, if <code>true</code>. Default value is <code>false</code>.
	IncludeDefaultBranch *GetAllContentHashesParamsIncludeDefaultBranch `form:"includeDefaultBranch,omitempty" json:"includeDefaultBranch,omitempty"`
}

// GetAllContentHashesParamsIncludeDefaultBranch defines parameters for GetAllContentHashes.
type GetAllContentHashesParamsIncludeDefaultBranch string

// GetContentHashByIdParams defines parameters for GetContentHashById.
type GetContentHashByIdParams struct {
	IncludeDefaultBranch *bool `form:"includeDefaultBranch,omitempty" json:"includeDefaultBranch,omitempty"`
}

// GetRepositoryMirrorsParams defines parameters for GetRepositoryMirrors.
type GetRepositoryMirrorsParams struct {
	PreAuthorized *bool `form:"preAuthorized,omitempty" json:"preAuthorized,omitempty"`
}

// ListRequestsParams defines parameters for ListRequests.
type ListRequestsParams struct {
	// State (optional) the request state to filter on
	State *ListRequestsParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListRequestsParamsState defines parameters for ListRequests.
type ListRequestsParamsState string

// GetRepoSyncStatusParams defines parameters for GetRepoSyncStatus.
type GetRepoSyncStatusParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetMirrorModeJSONBody defines parameters for SetMirrorMode.
type SetMirrorModeJSONBody = string

// StartMirroringProjectsJSONBody defines parameters for StartMirroringProjects.
type StartMirroringProjectsJSONBody = []string

// GetPageOfRequiredBuildsMergeChecksParams defines parameters for GetPageOfRequiredBuildsMergeChecks.
type GetPageOfRequiredBuildsMergeChecksParams struct {
	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// DeleteSshKeysParams defines parameters for DeleteSshKeys.
type DeleteSshKeysParams struct {
	// UserName the username of the user to delete the keys for. If no username is specified, the SSH keys will be deleted for the current authenticated user.
	UserName *string `form:"userName,omitempty" json:"userName,omitempty"`
	User     *string `form:"user,omitempty" json:"user,omitempty"`
}

// GetSshKeysParams defines parameters for GetSshKeys.
type GetSshKeysParams struct {
	// UserName the username of the user to retrieve the keys for. If no username is specified, the SSH keys will be retrieved for the current authenticated user.
	UserName *string `form:"userName,omitempty" json:"userName,omitempty"`
	User     *string `form:"user,omitempty" json:"user,omitempty"`

	// Start Start number for the page (inclusive). If not passed, first page is assumed.
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Number of items to return. If not passed, a page size of 25 is used.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddSshKeyJSONBody defines parameters for AddSshKey.
type AddSshKeyJSONBody struct {
	AlgorithmType     *string    `json:"algorithmType,omitempty"`
	BitLength         *int32     `json:"bitLength,omitempty"`
	CreatedDate       *time.Time `json:"createdDate,omitempty"`
	ExpiryDays        *int32     `json:"expiryDays,omitempty"`
	Fingerprint       *string    `json:"fingerprint,omitempty"`
	Id                *int32     `json:"id,omitempty"`
	Label             *string    `json:"label,omitempty"`
	LastAuthenticated *string    `json:"lastAuthenticated,omitempty"`
	Text              *string    `json:"text,omitempty"`

	// Warning Contains a warning about the key, for example that it's deprecated
	Warning *string `json:"warning,omitempty"`
}

// AddSshKeyParams defines parameters for AddSshKey.
type AddSshKeyParams struct {
	// User the username of the user to add the SSH key for. If no username is specified, the SSH key will be added for the current authenticated user.
	User *RestSshKey `form:"user,omitempty" json:"user,omitempty"`
}

// GetStatusParams defines parameters for GetStatus.
type GetStatusParams struct {
	// At Retrieves the synchronization status for the specified ref within the repository, rather than for the entire repository
	At *string `form:"at,omitempty" json:"at,omitempty"`
}

// CreateAccessTokenJSONRequestBody defines body for CreateAccessToken for application/json ContentType.
type CreateAccessTokenJSONRequestBody = RestAccessTokenRequest

// CreateAccessToken1JSONRequestBody defines body for CreateAccessToken1 for application/json ContentType.
type CreateAccessToken1JSONRequestBody = RestAccessTokenRequest

// UpdateAccessToken1JSONRequestBody defines body for UpdateAccessToken1 for application/json ContentType.
type UpdateAccessToken1JSONRequestBody = RestAccessTokenRequest

// UpdateAccessTokenJSONRequestBody defines body for UpdateAccessToken for application/json ContentType.
type UpdateAccessTokenJSONRequestBody = RestAccessTokenRequest

// CreateAccessToken2JSONRequestBody defines body for CreateAccessToken2 for application/json ContentType.
type CreateAccessToken2JSONRequestBody = RestAccessTokenRequest

// UpdateAccessToken2JSONRequestBody defines body for UpdateAccessToken2 for application/json ContentType.
type UpdateAccessToken2JSONRequestBody = RestAccessTokenRequest

// UpdateGlobalSettingsJSONRequestBody defines body for UpdateGlobalSettings for application/json ContentType.
type UpdateGlobalSettingsJSONRequestBody = RestSshKeySettings

// SetBannerJSONRequestBody defines body for SetBanner for application/json ContentType.
type SetBannerJSONRequestBody SetBannerJSONBody

// SetDefaultBranchJSONRequestBody defines body for SetDefaultBranch for application/json ContentType.
type SetDefaultBranchJSONRequestBody SetDefaultBranchJSONBody

// RegisterNewMeshNodeJSONRequestBody defines body for RegisterNewMeshNode for application/json ContentType.
type RegisterNewMeshNodeJSONRequestBody = RestMeshNode

// UpdateMeshNodeJSONRequestBody defines body for UpdateMeshNode for application/json ContentType.
type UpdateMeshNodeJSONRequestBody = RestMeshNode

// AddUserToGroupJSONRequestBody defines body for AddUserToGroup for application/json ContentType.
type AddUserToGroupJSONRequestBody = UserPickerContext

// AddUsersToGroupJSONRequestBody defines body for AddUsersToGroup for application/json ContentType.
type AddUsersToGroupJSONRequestBody = GroupAndUsers

// RemoveUserFromGroupJSONRequestBody defines body for RemoveUserFromGroup for application/json ContentType.
type RemoveUserFromGroupJSONRequestBody = UserPickerContext

// UpdateLicenseJSONRequestBody defines body for UpdateLicense for application/json ContentType.
type UpdateLicenseJSONRequestBody = RestBitbucketLicense

// SetMailConfigJSONRequestBody defines body for SetMailConfig for application/json ContentType.
type SetMailConfigJSONRequestBody SetMailConfigJSONBody

// SetSenderAddressJSONRequestBody defines body for SetSenderAddress for application/json ContentType.
type SetSenderAddressJSONRequestBody = SetSenderAddressJSONBody

// SetMergeConfigJSONRequestBody defines body for SetMergeConfig for application/json ContentType.
type SetMergeConfigJSONRequestBody = RestPullRequestSettings

// SetSettings2JSONRequestBody defines body for SetSettings2 for application/json ContentType.
type SetSettings2JSONRequestBody = RestRateLimitSettings

// Set2JSONRequestBody defines body for Set2 for application/json ContentType.
type Set2JSONRequestBody = RestBulkUserRateLimitSettingsUpdateRequest

// Set3JSONRequestBody defines body for Set3 for application/json ContentType.
type Set3JSONRequestBody = RestUserRateLimitSettingsUpdateRequest

// UpdateUserDetailsJSONRequestBody defines body for UpdateUserDetails for application/json ContentType.
type UpdateUserDetailsJSONRequestBody = UserUpdate

// AddGroupToUserJSONRequestBody defines body for AddGroupToUser for application/json ContentType.
type AddGroupToUserJSONRequestBody = GroupPickerContext

// AddUserToGroupsJSONRequestBody defines body for AddUserToGroups for application/json ContentType.
type AddUserToGroupsJSONRequestBody = UserAndGroups

// UpdateUserPasswordJSONRequestBody defines body for UpdateUserPassword for application/json ContentType.
type UpdateUserPasswordJSONRequestBody = AdminPasswordUpdate

// RemoveGroupFromUserJSONRequestBody defines body for RemoveGroupFromUser for application/json ContentType.
type RemoveGroupFromUserJSONRequestBody = GroupPickerContext

// RenameUserJSONRequestBody defines body for RenameUser for application/json ContentType.
type RenameUserJSONRequestBody = UserRename

// CreateHookScriptMultipartRequestBody defines body for CreateHookScript for multipart/form-data ContentType.
type CreateHookScriptMultipartRequestBody = ExamplePostMultipartFormData

// StartExportJSONRequestBody defines body for StartExport for application/json ContentType.
type StartExportJSONRequestBody = RestExportRequest

// PreviewExportJSONRequestBody defines body for PreviewExport for application/json ContentType.
type PreviewExportJSONRequestBody = RestExportRequest

// StartImportJSONRequestBody defines body for StartImport for application/json ContentType.
type StartImportJSONRequestBody = RestImportRequest

// StartMeshMigrationJSONRequestBody defines body for StartMeshMigration for application/json ContentType.
type StartMeshMigrationJSONRequestBody StartMeshMigrationJSONBody

// PreviewMeshMigrationJSONRequestBody defines body for PreviewMeshMigration for application/json ContentType.
type PreviewMeshMigrationJSONRequestBody = RestMeshMigrationRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = RestProject

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = RestProject

// UploadAvatarMultipartRequestBody defines body for UploadAvatar for multipart/form-data ContentType.
type UploadAvatarMultipartRequestBody = ExampleAvatarMultipartFormData

// SetConfigurationJSONRequestBody defines body for SetConfiguration for application/json ContentType.
type SetConfigurationJSONRequestBody = RestHookScriptTriggers

// CreateRepositoryJSONRequestBody defines body for CreateRepository for application/json ContentType.
type CreateRepositoryJSONRequestBody = RestRepository

// ForkRepositoryJSONRequestBody defines body for ForkRepository for application/json ContentType.
type ForkRepositoryJSONRequestBody = RestRepository

// UpdateRepositoryJSONRequestBody defines body for UpdateRepository for application/json ContentType.
type UpdateRepositoryJSONRequestBody = RestRepository

// SaveAttachmentMetadataJSONRequestBody defines body for SaveAttachmentMetadata for application/json ContentType.
type SaveAttachmentMetadataJSONRequestBody = SaveAttachmentMetadataJSONBody

// CreateBranchForRepositoryJSONRequestBody defines body for CreateBranchForRepository for application/json ContentType.
type CreateBranchForRepositoryJSONRequestBody = RestCreateBranchRequest

// SetDefaultBranch1JSONRequestBody defines body for SetDefaultBranch1 for application/json ContentType.
type SetDefaultBranch1JSONRequestBody = RestBranch

// EditFileMultipartRequestBody defines body for EditFile for multipart/form-data ContentType.
type EditFileMultipartRequestBody = ExampleMultipartFormData

// CreateCommentJSONRequestBody defines body for CreateComment for application/json ContentType.
type CreateCommentJSONRequestBody = RestComment

// UpdateCommentJSONRequestBody defines body for UpdateComment for application/json ContentType.
type UpdateCommentJSONRequestBody = RestComment

// SetDefaultBranch2JSONRequestBody defines body for SetDefaultBranch2 for application/json ContentType.
type SetDefaultBranch2JSONRequestBody = RestBranch

// SetConfiguration1JSONRequestBody defines body for SetConfiguration1 for application/json ContentType.
type SetConfiguration1JSONRequestBody = RestHookScriptTriggers

// AddLabelJSONRequestBody defines body for AddLabel for application/json ContentType.
type AddLabelJSONRequestBody = RestLabel

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = RestPullRequest

// Delete3JSONRequestBody defines body for Delete3 for application/json ContentType.
type Delete3JSONRequestBody = RestPullRequestDeleteRequest

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody = RestPullRequest

// CreateComment1JSONRequestBody defines body for CreateComment1 for application/json ContentType.
type CreateComment1JSONRequestBody = RestComment

// UpdateComment1JSONRequestBody defines body for UpdateComment1 for application/json ContentType.
type UpdateComment1JSONRequestBody = RestComment

// CreateComment2JSONRequestBody defines body for CreateComment2 for application/json ContentType.
type CreateComment2JSONRequestBody = RestComment

// UpdateComment2JSONRequestBody defines body for UpdateComment2 for application/json ContentType.
type UpdateComment2JSONRequestBody = RestComment

// ApplySuggestionJSONRequestBody defines body for ApplySuggestion for application/json ContentType.
type ApplySuggestionJSONRequestBody = RestApplySuggestionRequest

// DeclineJSONRequestBody defines body for Decline for application/json ContentType.
type DeclineJSONRequestBody = RestPullRequestDeclineRequest

// MergeJSONRequestBody defines body for Merge for application/json ContentType.
type MergeJSONRequestBody = RestPullRequestMergeRequest

// AssignParticipantRoleJSONRequestBody defines body for AssignParticipantRole for application/json ContentType.
type AssignParticipantRoleJSONRequestBody = RestPullRequestAssignParticipantRoleRequest

// UpdateStatusJSONRequestBody defines body for UpdateStatus for application/json ContentType.
type UpdateStatusJSONRequestBody = RestPullRequestAssignStatusRequest

// ReopenJSONRequestBody defines body for Reopen for application/json ContentType.
type ReopenJSONRequestBody = RestPullRequestReopenRequest

// FinishReviewJSONRequestBody defines body for FinishReview for application/json ContentType.
type FinishReviewJSONRequestBody = RestPullRequestFinishReviewRequest

// SetAutoDeclineSettings1JSONRequestBody defines body for SetAutoDeclineSettings1 for application/json ContentType.
type SetAutoDeclineSettings1JSONRequestBody = RestAutoDeclineSettingsRequest

// Set1JSONRequestBody defines body for Set1 for application/json ContentType.
type Set1JSONRequestBody = RestAutoMergeSettingsRequest

// SetSettings1JSONRequestBody defines body for SetSettings1 for application/json ContentType.
type SetSettings1JSONRequestBody = ExampleSettings

// UpdatePullRequestSettings1JSONRequestBody defines body for UpdatePullRequestSettings1 for application/json ContentType.
type UpdatePullRequestSettings1JSONRequestBody = RestRepositoryPullRequestSettings

// Create2JSONRequestBody defines body for Create2 for application/json ContentType.
type Create2JSONRequestBody = RestReviewerGroup

// Update2JSONRequestBody defines body for Update2 for application/json ContentType.
type Update2JSONRequestBody = RestReviewerGroup

// CreateTagForRepositoryJSONRequestBody defines body for CreateTagForRepository for application/json ContentType.
type CreateTagForRepositoryJSONRequestBody = RestCreateTagRequest

// Watch2JSONRequestBody defines body for Watch2 for application/json ContentType.
type Watch2JSONRequestBody = RestRepository

// CreateWebhook1JSONRequestBody defines body for CreateWebhook1 for application/json ContentType.
type CreateWebhook1JSONRequestBody = RestWebhook

// TestWebhook1JSONRequestBody defines body for TestWebhook1 for application/json ContentType.
type TestWebhook1JSONRequestBody = RestWebhookCredentials

// UpdateWebhook1JSONRequestBody defines body for UpdateWebhook1 for application/json ContentType.
type UpdateWebhook1JSONRequestBody = RestWebhook

// Create3JSONRequestBody defines body for Create3 for application/json ContentType.
type Create3JSONRequestBody = RestProjectSettingsRestrictionRequest

// SetAutoDeclineSettingsJSONRequestBody defines body for SetAutoDeclineSettings for application/json ContentType.
type SetAutoDeclineSettingsJSONRequestBody = RestAutoDeclineSettingsRequest

// SetJSONRequestBody defines body for Set for application/json ContentType.
type SetJSONRequestBody = RestAutoMergeProjectSettingsRequest

// SetSettingsJSONRequestBody defines body for SetSettings for application/json ContentType.
type SetSettingsJSONRequestBody = ExampleSettings

// UpdatePullRequestSettingsJSONRequestBody defines body for UpdatePullRequestSettings for application/json ContentType.
type UpdatePullRequestSettingsJSONRequestBody = RestPullRequestSettings

// Create1JSONRequestBody defines body for Create1 for application/json ContentType.
type Create1JSONRequestBody = RestReviewerGroup

// Update1JSONRequestBody defines body for Update1 for application/json ContentType.
type Update1JSONRequestBody = RestReviewerGroup

// CreateWebhookJSONRequestBody defines body for CreateWebhook for application/json ContentType.
type CreateWebhookJSONRequestBody = RestWebhook

// TestWebhookJSONRequestBody defines body for TestWebhook for application/json ContentType.
type TestWebhookJSONRequestBody = RestWebhookCredentials

// UpdateWebhookJSONRequestBody defines body for UpdateWebhook for application/json ContentType.
type UpdateWebhookJSONRequestBody = RestWebhook

// CreateCertificateMultipartRequestBody defines body for CreateCertificate for multipart/form-data ContentType.
type CreateCertificateMultipartRequestBody = ExampleCertificateMultipartFormData

// UpdateSystemSigningConfigurationJSONRequestBody defines body for UpdateSystemSigningConfiguration for application/json ContentType.
type UpdateSystemSigningConfigurationJSONRequestBody UpdateSystemSigningConfigurationJSONBody

// UpdateUserDetails1JSONRequestBody defines body for UpdateUserDetails1 for application/json ContentType.
type UpdateUserDetails1JSONRequestBody = UserUpdate

// UpdateUserPassword1JSONRequestBody defines body for UpdateUserPassword1 for application/json ContentType.
type UpdateUserPassword1JSONRequestBody = UserPasswordUpdate

// UploadAvatar1MultipartRequestBody defines body for UploadAvatar1 for multipart/form-data ContentType.
type UploadAvatar1MultipartRequestBody = ExampleAvatarMultipartFormData

// UpdateSettingsJSONRequestBody defines body for UpdateSettings for application/json ContentType.
type UpdateSettingsJSONRequestBody = ExampleSettingsMap

// CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody defines body for CreateRestrictions1 for application/vnd.atl.bitbucket.bulk+json ContentType.
type CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody = CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONBody

// CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody defines body for CreateRestrictions for application/vnd.atl.bitbucket.bulk+json ContentType.
type CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody = CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONBody

// DeleteBranchJSONRequestBody defines body for DeleteBranch for application/json ContentType.
type DeleteBranchJSONRequestBody = RestBranchDeleteRequest

// CreateBranchJSONRequestBody defines body for CreateBranch for application/json ContentType.
type CreateBranchJSONRequestBody = RestBranchCreateRequest

// GetMultipleBuildStatusStatsJSONRequestBody defines body for GetMultipleBuildStatusStats for application/json ContentType.
type GetMultipleBuildStatusStatsJSONRequestBody = GetMultipleBuildStatusStatsJSONBody

// AddBuildStatusJSONRequestBody defines body for AddBuildStatus for application/json ContentType.
type AddBuildStatusJSONRequestBody = RestBuildStatus

// CreatePullRequestConditionJSONRequestBody defines body for CreatePullRequestCondition for application/json ContentType.
type CreatePullRequestConditionJSONRequestBody = RestDefaultReviewersRequest

// UpdatePullRequestConditionJSONRequestBody defines body for UpdatePullRequestCondition for application/json ContentType.
type UpdatePullRequestConditionJSONRequestBody = RestDefaultReviewersRequest

// CreatePullRequestCondition1JSONRequestBody defines body for CreatePullRequestCondition1 for application/json ContentType.
type CreatePullRequestCondition1JSONRequestBody = RestDefaultReviewersRequest

// UpdatePullRequestCondition1JSONRequestBody defines body for UpdatePullRequestCondition1 for application/json ContentType.
type UpdatePullRequestCondition1JSONRequestBody UpdatePullRequestCondition1JSONBody

// AddDefaultTask1JSONRequestBody defines body for AddDefaultTask1 for application/json ContentType.
type AddDefaultTask1JSONRequestBody = RestDefaultTaskRequest

// UpdateDefaultTask1JSONRequestBody defines body for UpdateDefaultTask1 for application/json ContentType.
type UpdateDefaultTask1JSONRequestBody = RestDefaultTaskRequest

// AddDefaultTaskJSONRequestBody defines body for AddDefaultTask for application/json ContentType.
type AddDefaultTaskJSONRequestBody = RestDefaultTaskRequest

// UpdateDefaultTaskJSONRequestBody defines body for UpdateDefaultTask for application/json ContentType.
type UpdateDefaultTaskJSONRequestBody = RestDefaultTaskRequest

// RebaseJSONRequestBody defines body for Rebase for application/json ContentType.
type RebaseJSONRequestBody = RestPullRequestRebaseRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = RestGitTagCreateRequest

// AddKeyJSONRequestBody defines body for AddKey for application/json ContentType.
type AddKeyJSONRequestBody = RestGpgKey

// SetACodeInsightsReportJSONRequestBody defines body for SetACodeInsightsReport for application/json ContentType.
type SetACodeInsightsReportJSONRequestBody = RestSetInsightReportRequest

// AddAnnotationsJSONRequestBody defines body for AddAnnotations for application/json ContentType.
type AddAnnotationsJSONRequestBody = RestBulkAddInsightAnnotationRequest

// SetAnnotationJSONRequestBody defines body for SetAnnotation for application/json ContentType.
type SetAnnotationJSONRequestBody = RestSingleAddInsightAnnotationRequest

// CreateIssueJSONRequestBody defines body for CreateIssue for application/json ContentType.
type CreateIssueJSONRequestBody = CreateIssueJSONBody

// AddForRepositoryJSONRequestBody defines body for AddForRepository for application/json ContentType.
type AddForRepositoryJSONRequestBody = RestSshAccessKey

// AddForProjectJSONRequestBody defines body for AddForProject for application/json ContentType.
type AddForProjectJSONRequestBody = RestSshAccessKey

// RevokeManyJSONRequestBody defines body for RevokeMany for application/json ContentType.
type RevokeManyJSONRequestBody RevokeManyJSONBody

// SetPreferredMirrorIdJSONRequestBody defines body for SetPreferredMirrorId for application/json ContentType.
type SetPreferredMirrorIdJSONRequestBody = SetPreferredMirrorIdJSONBody

// AuthenticateJSONRequestBody defines body for Authenticate for application/json ContentType.
type AuthenticateJSONRequestBody = RestAuthenticationRequest

// UpgradeJSONRequestBody defines body for Upgrade for application/json ContentType.
type UpgradeJSONRequestBody = RestMirrorUpgradeRequest

// PublishEventJSONRequestBody defines body for PublishEvent for application/json ContentType.
type PublishEventJSONRequestBody = RestRepositoryMirrorEvent

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody = RestMirroringRequest

// SetMirrorSettingsJSONRequestBody defines body for SetMirrorSettings for application/json ContentType.
type SetMirrorSettingsJSONRequestBody = RestUpstreamSettings

// SetMirrorModeJSONRequestBody defines body for SetMirrorMode for application/json ContentType.
type SetMirrorModeJSONRequestBody = SetMirrorModeJSONBody

// StartMirroringProjectsJSONRequestBody defines body for StartMirroringProjects for application/json ContentType.
type StartMirroringProjectsJSONRequestBody = StartMirroringProjectsJSONBody

// SetRepositoryArchivePolicyJSONRequestBody defines body for SetRepositoryArchivePolicy for application/json ContentType.
type SetRepositoryArchivePolicyJSONRequestBody = RestRepositoryPolicy

// SetRepositoryDeletePolicyJSONRequestBody defines body for SetRepositoryDeletePolicy for application/json ContentType.
type SetRepositoryDeletePolicyJSONRequestBody = RestRepositoryPolicy

// AddSshKeyJSONRequestBody defines body for AddSshKey for application/json ContentType.
type AddSshKeyJSONRequestBody AddSshKeyJSONBody

// SetEnabledJSONRequestBody defines body for SetEnabled for application/json ContentType.
type SetEnabledJSONRequestBody = RestRefSyncStatus

// SynchronizeJSONRequestBody defines body for Synchronize for application/json ContentType.
type SynchronizeJSONRequestBody = RestRefSyncRequest

// AsRestUsernamePasswordCredentials returns the union data inside the Credentials as a RestUsernamePasswordCredentials
func (t Credentials) AsRestUsernamePasswordCredentials() (RestUsernamePasswordCredentials, error) {
	var body RestUsernamePasswordCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestUsernamePasswordCredentials overwrites any union data inside the Credentials as the provided RestUsernamePasswordCredentials
func (t *Credentials) FromRestUsernamePasswordCredentials(v RestUsernamePasswordCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestUsernamePasswordCredentials performs a merge with any union data inside the Credentials, using the provided RestUsernamePasswordCredentials
func (t *Credentials) MergeRestUsernamePasswordCredentials(v RestUsernamePasswordCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRestBearerTokenCredentials returns the union data inside the Credentials as a RestBearerTokenCredentials
func (t Credentials) AsRestBearerTokenCredentials() (RestBearerTokenCredentials, error) {
	var body RestBearerTokenCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestBearerTokenCredentials overwrites any union data inside the Credentials as the provided RestBearerTokenCredentials
func (t *Credentials) FromRestBearerTokenCredentials(v RestBearerTokenCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestBearerTokenCredentials performs a merge with any union data inside the Credentials, using the provided RestBearerTokenCredentials
func (t *Credentials) MergeRestBearerTokenCredentials(v RestBearerTokenCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRestSshCredentials returns the union data inside the Credentials as a RestSshCredentials
func (t Credentials) AsRestSshCredentials() (RestSshCredentials, error) {
	var body RestSshCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestSshCredentials overwrites any union data inside the Credentials as the provided RestSshCredentials
func (t *Credentials) FromRestSshCredentials(v RestSshCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestSshCredentials performs a merge with any union data inside the Credentials, using the provided RestSshCredentials
func (t *Credentials) MergeRestSshCredentials(v RestSshCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Credentials) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Credentials) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllAccessTokens request
	GetAllAccessTokens(ctx context.Context, projectKey string, params *GetAllAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessTokenWithBody request with any body
	CreateAccessTokenWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessToken(ctx context.Context, projectKey string, body CreateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccessTokens1 request
	GetAllAccessTokens1(ctx context.Context, projectKey string, repositorySlug string, params *GetAllAccessTokens1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessToken1WithBody request with any body
	CreateAccessToken1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessToken1(ctx context.Context, projectKey string, repositorySlug string, body CreateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById1 request
	DeleteById1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetById1 request
	GetById1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessToken1WithBody request with any body
	UpdateAccessToken1WithBody(ctx context.Context, projectKey string, repositorySlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessToken1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, body UpdateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById request
	DeleteById(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetById request
	GetById(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessTokenWithBody request with any body
	UpdateAccessTokenWithBody(ctx context.Context, projectKey string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessToken(ctx context.Context, projectKey string, tokenId string, body UpdateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAccessTokens2 request
	GetAllAccessTokens2(ctx context.Context, userSlug string, params *GetAllAccessTokens2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessToken2WithBody request with any body
	CreateAccessToken2WithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessToken2(ctx context.Context, userSlug string, body CreateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteById2 request
	DeleteById2(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetById2 request
	GetById2(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessToken2WithBody request with any body
	UpdateAccessToken2WithBody(ctx context.Context, userSlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessToken2(ctx context.Context, userSlug string, tokenId string, body UpdateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalSettings request
	GetGlobalSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGlobalSettingsWithBody request with any body
	UpdateGlobalSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGlobalSettings(ctx context.Context, body UpdateGlobalSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportedKeyTypes request
	GetSupportedKeyTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBanner request
	DeleteBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBanner request
	GetBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBannerWithBody request with any body
	SetBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBanner(ctx context.Context, body SetBannerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInformation request
	GetInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearDefaultBranch request
	ClearDefaultBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultBranch request
	GetDefaultBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultBranchWithBody request with any body
	SetDefaultBranchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultBranch(ctx context.Context, body SetDefaultBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetControlPlanePublicKey request
	GetControlPlanePublicKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Connectivity request
	Connectivity(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRegisteredMeshNodes request
	GetAllRegisteredMeshNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterNewMeshNodeWithBody request with any body
	RegisterNewMeshNodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterNewMeshNode(ctx context.Context, body RegisterNewMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete2 request
	Delete2(ctx context.Context, id int64, params *Delete2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegisteredMeshNodeById request
	GetRegisteredMeshNodeById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMeshNodeWithBody request with any body
	UpdateMeshNodeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMeshNode(ctx context.Context, id string, body UpdateMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportZips request
	GetSupportZips(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportZip request
	GetSupportZip(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups1 request
	GetGroups1(ctx context.Context, params *GetGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request
	CreateGroup(ctx context.Context, params *CreateGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroupWithBody request with any body
	AddUserToGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroup(ctx context.Context, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUsersToGroupWithBody request with any body
	AddUsersToGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUsersToGroup(ctx context.Context, body AddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUsersInGroup request
	FindUsersInGroup(ctx context.Context, params *FindUsersInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUsersNotInGroup request
	FindUsersNotInGroup(ctx context.Context, params *FindUsersNotInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromGroupWithBody request with any body
	RemoveUserFromGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserFromGroup(ctx context.Context, body RemoveUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get2 request
	Get2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLicenseWithBody request with any body
	UpdateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLicense(ctx context.Context, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailConfig request
	DeleteMailConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailConfig request
	GetMailConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMailConfigWithBody request with any body
	SetMailConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMailConfig(ctx context.Context, body SetMailConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearSenderAddress request
	ClearSenderAddress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSenderAddress request
	GetSenderAddress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSenderAddressWithBody request with any body
	SetSenderAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSenderAddress(ctx context.Context, body SetSenderAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForGroup request
	RevokePermissionsForGroup(ctx context.Context, params *RevokePermissionsForGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithAnyPermission request
	GetGroupsWithAnyPermission(ctx context.Context, params *GetGroupsWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForGroups request
	SetPermissionForGroups(ctx context.Context, params *SetPermissionForGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithoutAnyPermission request
	GetGroupsWithoutAnyPermission(ctx context.Context, params *GetGroupsWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForUser request
	RevokePermissionsForUser(ctx context.Context, params *RevokePermissionsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithAnyPermission request
	GetUsersWithAnyPermission(ctx context.Context, params *GetUsersWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForUsers request
	SetPermissionForUsers(ctx context.Context, params *SetPermissionForUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithoutAnyPermission request
	GetUsersWithoutAnyPermission(ctx context.Context, params *GetUsersWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMergeConfig request
	GetMergeConfig(ctx context.Context, scmId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMergeConfigWithBody request with any body
	SetMergeConfigWithBody(ctx context.Context, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMergeConfig(ctx context.Context, scmId string, body SetMergeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHistory request
	GetHistory(ctx context.Context, params *GetHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings2 request
	GetSettings2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSettings2WithBody request with any body
	SetSettings2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSettings2(ctx context.Context, body SetSettings2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRateLimitSettings request
	GetAllRateLimitSettings(ctx context.Context, params *GetAllRateLimitSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Set2WithBody request with any body
	Set2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Set2(ctx context.Context, body Set2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete8 request
	Delete8(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get6 request
	Get6(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Set3WithBody request with any body
	Set3WithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Set3(ctx context.Context, userSlug string, body Set3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDirectories request
	GetUserDirectories(ctx context.Context, params *GetUserDirectoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers1 request
	GetUsers1(ctx context.Context, params *GetUsers1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request
	CreateUser(ctx context.Context, params *CreateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserDetailsWithBody request with any body
	UpdateUserDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserDetails(ctx context.Context, body UpdateUserDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupToUserWithBody request with any body
	AddGroupToUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGroupToUser(ctx context.Context, body AddGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroupsWithBody request with any body
	AddUserToGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroups(ctx context.Context, body AddUserToGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearUserCaptchaChallenge request
	ClearUserCaptchaChallenge(ctx context.Context, params *ClearUserCaptchaChallengeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPasswordWithBody request with any body
	UpdateUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateErasable request
	ValidateErasable(ctx context.Context, params *ValidateErasableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EraseUser request
	EraseUser(ctx context.Context, params *EraseUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGroupsForUser request
	FindGroupsForUser(ctx context.Context, params *FindGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOtherGroupsForUser request
	FindOtherGroupsForUser(ctx context.Context, params *FindOtherGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveGroupFromUserWithBody request with any body
	RemoveGroupFromUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveGroupFromUser(ctx context.Context, body RemoveGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameUserWithBody request with any body
	RenameUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RenameUser(ctx context.Context, body RenameUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationProperties request
	GetApplicationProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCapabilities request
	GetCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestSuggestions request
	GetPullRequestSuggestions(ctx context.Context, params *GetPullRequestSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequests1 request
	GetPullRequests1(ctx context.Context, params *GetPullRequests1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCapabilities1 request
	GetCapabilities1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHookScriptWithBody request with any body
	CreateHookScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHookScript request
	DeleteHookScript(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHookScript request
	GetHookScript(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHookScriptWithBody request with any body
	UpdateHookScriptWithBody(ctx context.Context, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Read request
	Read(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvatar request
	GetAvatar(ctx context.Context, hookKey string, params *GetAvatarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequests2 request
	GetPullRequests2(ctx context.Context, params *GetPullRequests2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestCount request
	GetPullRequestCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabels request
	GetLabels(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabel request
	GetLabel(ctx context.Context, labelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabelables request
	GetLabelables(ctx context.Context, labelName string, params *GetLabelablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLevel request
	GetLevel(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetLevel request
	SetLevel(ctx context.Context, loggerName string, levelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootLevel request
	GetRootLevel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRootLevel request
	SetRootLevel(ctx context.Context, levelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewWithBody request with any body
	PreviewWithBody(ctx context.Context, params *PreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartExportWithBody request with any body
	StartExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartExport(ctx context.Context, body StartExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewExportWithBody request with any body
	PreviewExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewExport(ctx context.Context, body PreviewExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExportJob request
	GetExportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelExportJob request
	CancelExportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExportJobMessages request
	GetExportJobMessages(ctx context.Context, jobId string, params *GetExportJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartImportWithBody request with any body
	StartImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartImport(ctx context.Context, body StartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportJob request
	GetImportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelImportJob request
	CancelImportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportJobMessages request
	GetImportJobMessages(ctx context.Context, jobId string, params *GetImportJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartMeshMigrationWithBody request with any body
	StartMeshMigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartMeshMigration(ctx context.Context, body StartMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewMeshMigrationWithBody request with any body
	PreviewMeshMigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewMeshMigration(ctx context.Context, body PreviewMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMeshMigrationRepos request
	SearchMeshMigrationRepos(ctx context.Context, params *SearchMeshMigrationReposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllMeshMigrationSummaries request
	GetAllMeshMigrationSummaries(ctx context.Context, params *GetAllMeshMigrationSummariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveMeshMigrationSummary request
	GetActiveMeshMigrationSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeshMigrationJob request
	GetMeshMigrationJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelMeshMigrationJob request
	CancelMeshMigrationJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeshMigrationJobMessages request
	GetMeshMigrationJobMessages(ctx context.Context, jobId string, params *GetMeshMigrationJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeshMigrationJobSummary request
	GetMeshMigrationJobSummary(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoriesRecentlyAccessed request
	GetRepositoriesRecentlyAccessed(ctx context.Context, params *GetRepositoriesRecentlyAccessedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjects request
	GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectKey string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectAvatar request
	GetProjectAvatar(ctx context.Context, projectKey string, params *GetProjectAvatarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAvatarWithBody request with any body
	UploadAvatarWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurations request
	GetConfigurations(ctx context.Context, projectKey string, params *GetConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveConfiguration request
	RemoveConfiguration(ctx context.Context, projectKey string, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetConfigurationWithBody request with any body
	SetConfigurationWithBody(ctx context.Context, projectKey string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetConfiguration(ctx context.Context, projectKey string, scriptId string, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissions request
	RevokePermissions(ctx context.Context, projectKey string, params *RevokePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForGroup1 request
	RevokePermissionsForGroup1(ctx context.Context, projectKey string, params *RevokePermissionsForGroup1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithAnyPermission1 request
	GetGroupsWithAnyPermission1(ctx context.Context, projectKey string, params *GetGroupsWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForGroups1 request
	SetPermissionForGroups1(ctx context.Context, projectKey string, params *SetPermissionForGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithoutAnyPermission1 request
	GetGroupsWithoutAnyPermission1(ctx context.Context, projectKey string, params *GetGroupsWithoutAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPermissions request
	SearchPermissions(ctx context.Context, projectKey string, params *SearchPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForUser1 request
	RevokePermissionsForUser1(ctx context.Context, projectKey string, params *RevokePermissionsForUser1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithAnyPermission1 request
	GetUsersWithAnyPermission1(ctx context.Context, projectKey string, params *GetUsersWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForUsers1 request
	SetPermissionForUsers1(ctx context.Context, projectKey string, params *SetPermissionForUsers1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithoutPermission request
	GetUsersWithoutPermission(ctx context.Context, projectKey string, params *GetUsersWithoutPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HasAllUserPermission request
	HasAllUserPermission(ctx context.Context, projectKey string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyAllUserPermission request
	ModifyAllUserPermission(ctx context.Context, projectKey string, permission string, params *ModifyAllUserPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositories request
	GetRepositories(ctx context.Context, projectKey string, params *GetRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepositoryWithBody request with any body
	CreateRepositoryWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, projectKey string, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForkRepositoryWithBody request with any body
	ForkRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForkRepository(ctx context.Context, projectKey string, repositorySlug string, body ForkRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRepositoryWithBody request with any body
	UpdateRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRepository(ctx context.Context, projectKey string, repositorySlug string, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchive request
	GetArchive(ctx context.Context, projectKey string, repositorySlug string, params *GetArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttachment request
	DeleteAttachment(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachment request
	GetAttachment(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttachmentMetadata request
	DeleteAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentMetadata request
	GetAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveAttachmentMetadataWithBody request with any body
	SaveAttachmentMetadataWithBody(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, body SaveAttachmentMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranches request
	GetBranches(ctx context.Context, projectKey string, repositorySlug string, params *GetBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchForRepositoryWithBody request with any body
	CreateBranchForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranchForRepository(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultBranch1 request
	GetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultBranch1WithBody request with any body
	SetDefaultBranch1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContent request
	GetContent(ctx context.Context, projectKey string, repositorySlug string, params *GetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContent1 request
	GetContent1(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetContent1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditFileWithBody request with any body
	EditFileWithBody(ctx context.Context, projectKey string, repositorySlug string, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChanges1 request
	GetChanges1(ctx context.Context, projectKey string, repositorySlug string, params *GetChanges1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommits request
	GetCommits(ctx context.Context, projectKey string, repositorySlug string, params *GetCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommit request
	GetCommit(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	Delete(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	Get(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddWithBody request with any body
	AddWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChanges request
	GetChanges(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComments request
	GetComments(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommentWithBody request with any body
	CreateCommentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComment request
	DeleteComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComment request
	GetComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommentWithBody request with any body
	UpdateCommentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, body UpdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete1 request
	Delete1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Delete1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get1 request
	Get1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Get1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateDeploymentWithBody request with any body
	CreateOrUpdateDeploymentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiffStatsSummary request
	GetDiffStatsSummary(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *GetDiffStatsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamDiff request
	StreamDiff(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *StreamDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMergeBase request
	GetMergeBase(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetMergeBaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequests request
	GetPullRequests(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unwatch request
	Unwatch(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Watch request
	Watch(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamChanges request
	StreamChanges(ctx context.Context, projectKey string, repositorySlug string, params *StreamChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamCommits request
	StreamCommits(ctx context.Context, projectKey string, repositorySlug string, params *StreamCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiffStatsSummary1 request
	GetDiffStatsSummary1(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetDiffStatsSummary1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamDiff1 request
	StreamDiff1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamDiff1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamContributing request
	StreamContributing(ctx context.Context, projectKey string, repositorySlug string, params *StreamContributingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultBranch2 request
	GetDefaultBranch2(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultBranch2WithBody request with any body
	SetDefaultBranch2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultBranch2(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRawDiff request
	StreamRawDiff(ctx context.Context, projectKey string, repositorySlug string, params *StreamRawDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRawDiff1 request
	StreamRawDiff1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawDiff1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFiles request
	StreamFiles(ctx context.Context, projectKey string, repositorySlug string, params *StreamFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFiles1 request
	StreamFiles1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamFiles1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForkedRepositories request
	GetForkedRepositories(ctx context.Context, projectKey string, repositorySlug string, params *GetForkedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurations1 request
	GetConfigurations1(ctx context.Context, projectKey string, repositorySlug string, params *GetConfigurations1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveConfiguration1 request
	RemoveConfiguration1(ctx context.Context, projectKey string, repositorySlug string, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetConfiguration1WithBody request with any body
	SetConfiguration1WithBody(ctx context.Context, projectKey string, repositorySlug string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetConfiguration1(ctx context.Context, projectKey string, repositorySlug string, scriptId string, body SetConfiguration1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLabelsForRepository request
	GetAllLabelsForRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLabelWithBody request with any body
	AddLabelWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLabel(ctx context.Context, projectKey string, repositorySlug string, body AddLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveLabel request
	RemoveLabel(ctx context.Context, projectKey string, repositorySlug string, labelName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stream request
	Stream(ctx context.Context, projectKey string, repositorySlug string, params *StreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stream1 request
	Stream1(ctx context.Context, projectKey string, repositorySlug string, path string, params *Stream1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamLicense request
	StreamLicense(ctx context.Context, projectKey string, repositorySlug string, params *StreamLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, projectKey string, repositorySlug string, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamPatch request
	StreamPatch(ctx context.Context, projectKey string, repositorySlug string, params *StreamPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissions1 request
	RevokePermissions1(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissions1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForGroup2 request
	RevokePermissionsForGroup2(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForGroup2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithAnyPermission2 request
	GetGroupsWithAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForGroup request
	SetPermissionForGroup(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsWithoutAnyPermission2 request
	GetGroupsWithoutAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithoutAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPermissions1 request
	SearchPermissions1(ctx context.Context, projectKey string, repositorySlug string, params *SearchPermissions1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsForUser2 request
	RevokePermissionsForUser2(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForUser2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithAnyPermission2 request
	GetUsersWithAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPermissionForUser request
	SetPermissionForUser(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithoutPermission1 request
	GetUsersWithoutPermission1(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithoutPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPage request
	GetPage(ctx context.Context, projectKey string, repositorySlug string, params *GetPageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWithBody request with any body
	CreateWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, projectKey string, repositorySlug string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete3WithBody request with any body
	Delete3WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Delete3(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body Delete3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get3 request
	Get3(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWithBody request with any body
	UpdateWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRawDiff2 request
	StreamRawDiff2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamRawDiff2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamPatch1 request
	StreamPatch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivities request
	GetActivities(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawApproval request
	WithdrawApproval(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Approve request
	Approve(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelAutoMerge request
	CancelAutoMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoMergeRequest request
	GetAutoMergeRequest(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TryAutoMerge request
	TryAutoMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComments1 request
	GetComments1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComment1WithBody request with any body
	CreateComment1WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComment1 request
	DeleteComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComment1 request
	GetComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComment1WithBody request with any body
	UpdateComment1WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamChanges1 request
	StreamChanges1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamChanges1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComments2 request
	GetComments2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComment2WithBody request with any body
	CreateComment2WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComment2 request
	DeleteComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComment2 request
	GetComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComment2WithBody request with any body
	UpdateComment2WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApplySuggestionWithBody request with any body
	ApplySuggestionWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplySuggestion(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body ApplySuggestionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommitMessageSuggestion request
	GetCommitMessageSuggestion(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommits1 request
	GetCommits1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetCommits1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineWithBody request with any body
	DeclineWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Decline(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, body DeclineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiffStatsSummary2 request
	GetDiffStatsSummary2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *GetDiffStatsSummary2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamDiff2 request
	StreamDiff2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *StreamDiff2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CanMerge request
	CanMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeWithBody request with any body
	MergeWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Merge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, body MergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMergeBase1 request
	GetMergeBase1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignParticipantRole1 request
	UnassignParticipantRole1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *UnassignParticipantRole1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListParticipants request
	ListParticipants(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ListParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignParticipantRoleWithBody request with any body
	AssignParticipantRoleWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignParticipantRole(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body AssignParticipantRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignParticipantRole request
	UnassignParticipantRole(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStatusWithBody request with any body
	UpdateStatusWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStatus(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReopenWithBody request with any body
	ReopenWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Reopen(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, body ReopenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscardReview request
	DiscardReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReview request
	GetReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FinishReviewWithBody request with any body
	FinishReviewWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FinishReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, body FinishReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unwatch1 request
	Unwatch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Watch1 request
	Watch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRaw request
	StreamRaw(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamReadme request
	StreamReadme(ctx context.Context, projectKey string, repositorySlug string, params *StreamReadmeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryCreateRepository request
	RetryCreateRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefChangeActivity request
	GetRefChangeActivity(ctx context.Context, projectKey string, repositorySlug string, params *GetRefChangeActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBranches request
	FindBranches(ctx context.Context, projectKey string, repositorySlug string, params *FindBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRelatedRepositories request
	GetRelatedRepositories(ctx context.Context, projectKey string, repositorySlug string, params *GetRelatedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search2 request
	Search2(ctx context.Context, projectKey string, repositorySlug string, params *Search2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAllowlistRule1WithBody request with any body
	CreateAllowlistRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllowlistRule1 request
	DeleteAllowlistRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllowlistRule1 request
	GetAllowlistRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAllowlistRule1WithBody request with any body
	EditAllowlistRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search3 request
	Search3(ctx context.Context, projectKey string, repositorySlug string, params *Search3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRule1WithBody request with any body
	CreateRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule1 request
	DeleteRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule1 request
	GetRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditRule1WithBody request with any body
	EditRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAutoDeclineSettings1 request
	DeleteAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoDeclineSettings1 request
	GetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoDeclineSettings1WithBody request with any body
	SetAutoDeclineSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, body SetAutoDeclineSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete5 request
	Delete5(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get5 request
	Get5(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Set1WithBody request with any body
	Set1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Set1(ctx context.Context, projectKey string, repositorySlug string, body Set1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryHooks1 request
	GetRepositoryHooks1(ctx context.Context, projectKey string, repositorySlug string, params *GetRepositoryHooks1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepositoryHook request
	DeleteRepositoryHook(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryHook1 request
	GetRepositoryHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableHook1 request
	DisableHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableHook1 request
	EnableHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, params *EnableHook1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings1 request
	GetSettings1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSettings1WithBody request with any body
	SetSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSettings1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, body SetSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestSettings1 request
	GetPullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequestSettings1WithBody request with any body
	UpdatePullRequestSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, body UpdatePullRequestSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewerGroups1 request
	GetReviewerGroups1(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewerGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create2WithBody request with any body
	Create2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create2(ctx context.Context, projectKey string, repositorySlug string, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete7 request
	Delete7(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewerGroup1 request
	GetReviewerGroup1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Update2WithBody request with any body
	Update2WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update2(ctx context.Context, projectKey string, repositorySlug string, id string, body Update2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, projectKey string, repositorySlug string, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagForRepositoryWithBody request with any body
	CreateTagForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTagForRepository(ctx context.Context, projectKey string, repositorySlug string, body CreateTagForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unwatch2 request
	Unwatch2(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Watch2WithBody request with any body
	Watch2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Watch2(ctx context.Context, projectKey string, repositorySlug string, body Watch2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindWebhooks1 request
	FindWebhooks1(ctx context.Context, projectKey string, repositorySlug string, params *FindWebhooks1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhook1WithBody request with any body
	CreateWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook1(ctx context.Context, projectKey string, repositorySlug string, body CreateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWebhooks request
	SearchWebhooks(ctx context.Context, projectKey string, repositorySlug string, params *SearchWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestWebhook1WithBody request with any body
	TestWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestWebhook1(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, body TestWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook1 request
	DeleteWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook1 request
	GetWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetWebhook1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhook1WithBody request with any body
	UpdateWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, body UpdateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestInvocation1 request
	GetLatestInvocation1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetLatestInvocation1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatistics1 request
	GetStatistics1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetStatistics1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsSummary1 request
	GetStatisticsSummary1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAllowlistRule request
	SearchAllowlistRule(ctx context.Context, projectKey string, params *SearchAllowlistRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAllowlistRuleWithBody request with any body
	CreateAllowlistRuleWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllowlistRule request
	DeleteAllowlistRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllowlistRule request
	GetAllowlistRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAllowlistRuleWithBody request with any body
	EditAllowlistRuleWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search1 request
	Search1(ctx context.Context, projectKey string, params *Search1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleWithBody request with any body
	CreateRuleWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule request
	GetRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditRuleWithBody request with any body
	EditRuleWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete9 request
	Delete9(ctx context.Context, projectKey string, params *Delete9Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get7 request
	Get7(ctx context.Context, projectKey string, params *Get7Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create3WithBody request with any body
	Create3WithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create3(ctx context.Context, projectKey string, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAll request
	GetAll(ctx context.Context, projectKey string, params *GetAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAutoDeclineSettings request
	DeleteAutoDeclineSettings(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoDeclineSettings request
	GetAutoDeclineSettings(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoDeclineSettingsWithBody request with any body
	SetAutoDeclineSettingsWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoDeclineSettings(ctx context.Context, projectKey string, body SetAutoDeclineSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete4 request
	Delete4(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get4 request
	Get4(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetWithBody request with any body
	SetWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Set(ctx context.Context, projectKey string, body SetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryHooks request
	GetRepositoryHooks(ctx context.Context, projectKey string, params *GetRepositoryHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryHook request
	GetRepositoryHook(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableHook request
	DisableHook(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableHook request
	EnableHook(ctx context.Context, projectKey string, hookKey string, params *EnableHookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSettingsWithBody request with any body
	SetSettingsWithBody(ctx context.Context, projectKey string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSettings(ctx context.Context, projectKey string, hookKey string, body SetSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestSettings request
	GetPullRequestSettings(ctx context.Context, projectKey string, scmId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequestSettingsWithBody request with any body
	UpdatePullRequestSettingsWithBody(ctx context.Context, projectKey string, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequestSettings(ctx context.Context, projectKey string, scmId string, body UpdatePullRequestSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewerGroups request
	GetReviewerGroups(ctx context.Context, projectKey string, params *GetReviewerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create1WithBody request with any body
	Create1WithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create1(ctx context.Context, projectKey string, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete6 request
	Delete6(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewerGroup request
	GetReviewerGroup(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Update1WithBody request with any body
	Update1WithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update1(ctx context.Context, projectKey string, id string, body Update1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindWebhooks request
	FindWebhooks(ctx context.Context, projectKey string, params *FindWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookWithBody request with any body
	CreateWebhookWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook(ctx context.Context, projectKey string, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestWebhookWithBody request with any body
	TestWebhookWithBody(ctx context.Context, projectKey string, params *TestWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestWebhook(ctx context.Context, projectKey string, params *TestWebhookParams, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, projectKey string, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookWithBody request with any body
	UpdateWebhookWithBody(ctx context.Context, projectKey string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook(ctx context.Context, projectKey string, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestInvocation request
	GetLatestInvocation(ctx context.Context, projectKey string, webhookId string, params *GetLatestInvocationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatistics request
	GetStatistics(ctx context.Context, projectKey string, webhookId string, params *GetStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsSummary request
	GetStatisticsSummary(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositories1 request
	GetRepositories1(ctx context.Context, params *GetRepositories1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindExemptReposByScope request
	FindExemptReposByScope(ctx context.Context, params *FindExemptReposByScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddExemptRepositoriesWithBody request with any body
	BulkAddExemptRepositoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search4 request
	Search4(ctx context.Context, params *Search4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRule2WithBody request with any body
	CreateRule2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule2 request
	DeleteRule2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule2 request
	GetRule2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditRule2WithBody request with any body
	EditRule2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCertificates request
	GetAllCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCertificateWithBody request with any body
	CreateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCertificateRevocationListEntries request
	UpdateCertificateRevocationListEntries(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCertificate request
	DeleteCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSigningConfiguration request
	GetSystemSigningConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSystemSigningConfigurationWithBody request with any body
	UpdateSystemSigningConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSystemSigningConfiguration(ctx context.Context, body UpdateSystemSigningConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers2 request
	GetUsers2(ctx context.Context, params *GetUsers2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserDetails1WithBody request with any body
	UpdateUserDetails1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserDetails1(ctx context.Context, body UpdateUserDetails1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPassword1WithBody request with any body
	UpdateUserPassword1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword1(ctx context.Context, body UpdateUserPassword1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAvatar request
	DeleteAvatar(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAvatar1WithBody request with any body
	UploadAvatar1WithBody(ctx context.Context, userSlug string, params *UploadAvatar1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSettings request
	GetUserSettings(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsWithBody request with any body
	UpdateSettingsWithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettings(ctx context.Context, userSlug string, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DismissRetentionConfigReviewNotification request
	DismissRetentionConfigReviewNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestrictions1 request
	GetRestrictions1(ctx context.Context, projectKey string, repositorySlug string, params *GetRestrictions1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRestrictions1WithBody request with any body
	CreateRestrictions1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRestrictions1WithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx context.Context, projectKey string, repositorySlug string, body CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRestriction1 request
	DeleteRestriction1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestriction1 request
	GetRestriction1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestrictions request
	GetRestrictions(ctx context.Context, projectKey string, params *GetRestrictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRestrictionsWithBody request with any body
	CreateRestrictionsWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRestrictionsWithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx context.Context, projectKey string, body CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRestriction request
	DeleteRestriction(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRestriction request
	GetRestriction(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranchWithBody request with any body
	DeleteBranchWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBranch(ctx context.Context, projectKey string, repositorySlug string, body DeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchWithBody request with any body
	CreateBranchWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranch(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindByCommit request
	FindByCommit(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *FindByCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleBuildStatusStatsWithBody request with any body
	GetMultipleBuildStatusStatsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMultipleBuildStatusStats(ctx context.Context, body GetMultipleBuildStatusStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildStatusStats request
	GetBuildStatusStats(ctx context.Context, commitId string, params *GetBuildStatusStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildStatus request
	GetBuildStatus(ctx context.Context, commitId string, params *GetBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBuildStatusWithBody request with any body
	AddBuildStatusWithBody(ctx context.Context, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBuildStatus(ctx context.Context, commitId string, body AddBuildStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnReact request
	UnReact(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// React request
	React(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnReact1 request
	UnReact1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// React1 request
	React1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePullRequestConditionWithBody request with any body
	CreatePullRequestConditionWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePullRequestCondition(ctx context.Context, projectKey string, body CreatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePullRequestCondition request
	DeletePullRequestCondition(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequestConditionWithBody request with any body
	UpdatePullRequestConditionWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequestCondition(ctx context.Context, projectKey string, id string, body UpdatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestConditions request
	GetPullRequestConditions(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePullRequestCondition1WithBody request with any body
	CreatePullRequestCondition1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, body CreatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePullRequestCondition1 request
	DeletePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePullRequestCondition1WithBody request with any body
	UpdatePullRequestCondition1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, id string, body UpdatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequestConditions1 request
	GetPullRequestConditions1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReviewers request
	GetReviewers(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllDefaultTasks1 request
	DeleteAllDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultTasks1 request
	GetDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string, params *GetDefaultTasks1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDefaultTask1WithBody request with any body
	AddDefaultTask1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, body AddDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDefaultTask1 request
	DeleteDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDefaultTask1WithBody request with any body
	UpdateDefaultTask1WithBody(ctx context.Context, projectKey string, repositorySlug string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string, body UpdateDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllDefaultTasks request
	DeleteAllDefaultTasks(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultTasks request
	GetDefaultTasks(ctx context.Context, projectKey string, params *GetDefaultTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDefaultTaskWithBody request with any body
	AddDefaultTaskWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDefaultTask(ctx context.Context, projectKey string, body AddDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDefaultTask request
	DeleteDefaultTask(ctx context.Context, projectKey string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDefaultTaskWithBody request with any body
	UpdateDefaultTaskWithBody(ctx context.Context, projectKey string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDefaultTask(ctx context.Context, projectKey string, taskId string, body UpdateDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CanRebase request
	CanRebase(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebaseWithBody request with any body
	RebaseWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Rebase(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body RebaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagWithBody request with any body
	CreateTagWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, projectKey string, repositorySlug string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteForUser request
	DeleteForUser(ctx context.Context, params *DeleteForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeysForUser request
	GetKeysForUser(ctx context.Context, params *GetKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKeyWithBody request with any body
	AddKeyWithBody(ctx context.Context, params *AddKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddKey(ctx context.Context, params *AddKeyParams, body AddKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, fingerprintOrId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnnotations1 request
	GetAnnotations1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetAnnotations1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReports request
	GetReports(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACodeInsightsReport request
	DeleteACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACodeInsightsReport request
	GetACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetACodeInsightsReportWithBody request with any body
	SetACodeInsightsReportWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body SetACodeInsightsReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAnnotations request
	DeleteAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, params *DeleteAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnnotations request
	GetAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAnnotationsWithBody request with any body
	AddAnnotationsWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body AddAnnotationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAnnotationWithBody request with any body
	SetAnnotationWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAnnotation(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, body SetAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIssueWithBody request with any body
	CreateIssueWithBody(ctx context.Context, commentId string, params *CreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIssue(ctx context.Context, commentId string, params *CreateIssueParams, body CreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommitsByIssueKey request
	GetCommitsByIssueKey(ctx context.Context, issueKey string, params *GetCommitsByIssueKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnhancedEntityLinkForProject request
	GetEnhancedEntityLinkForProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIssueKeysForPullRequest request
	GetIssueKeysForPullRequest(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForRepository1 request
	GetForRepository1(ctx context.Context, projectKey string, repositorySlug string, params *GetForRepository1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddForRepositoryWithBody request with any body
	AddForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddForRepository(ctx context.Context, projectKey string, repositorySlug string, body AddForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeForRepository request
	RevokeForRepository(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForRepository request
	GetForRepository(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePermission1 request
	UpdatePermission1(ctx context.Context, projectKey string, repositorySlug string, keyId string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshKeysForProject request
	GetSshKeysForProject(ctx context.Context, projectKey string, params *GetSshKeysForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddForProjectWithBody request with any body
	AddForProjectWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddForProject(ctx context.Context, projectKey string, body AddForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeForProject request
	RevokeForProject(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForProject request
	GetForProject(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePermission request
	UpdatePermission(ctx context.Context, projectKey string, keyId string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeManyWithBody request with any body
	RevokeManyWithBody(ctx context.Context, keyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeMany(ctx context.Context, keyId string, body RevokeManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForProjects request
	GetForProjects(ctx context.Context, keyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForRepositories request
	GetForRepositories(ctx context.Context, keyId string, params *GetForRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePreferredMirrorId request
	DeletePreferredMirrorId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreferredMirrorId request
	GetPreferredMirrorId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPreferredMirrorIdWithBody request with any body
	SetPreferredMirrorIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPreferredMirrorId(ctx context.Context, body SetPreferredMirrorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyticsSettings request
	AnalyticsSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateWithBody request with any body
	AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFarmNodes request
	GetFarmNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirroredRepository request
	GetMirroredRepository(ctx context.Context, externalRepositoryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMirrors request
	ListMirrors(ctx context.Context, params *ListMirrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Remove request
	Remove(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirror request
	GetMirror(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeWithBody request with any body
	UpgradeWithBody(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Upgrade(ctx context.Context, mirrorId string, body UpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishEventWithBody request with any body
	PublishEventWithBody(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishEvent(ctx context.Context, mirrorId string, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSynchronizationProgress request
	GetSynchronizationProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectById request
	GetProjectById(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllReposForProject request
	GetAllReposForProject(ctx context.Context, projectId string, params *GetAllReposForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllContentHashes request
	GetAllContentHashes(ctx context.Context, params *GetAllContentHashesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentHashById request
	GetContentHashById(ctx context.Context, repoId string, params *GetContentHashByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryMirrors request
	GetRepositoryMirrors(ctx context.Context, repoId string, params *GetRepositoryMirrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequests request
	ListRequests(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterWithBody request with any body
	RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMirroringRequest request
	DeleteMirroringRequest(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirroringRequest request
	GetMirroringRequest(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Accept request
	Accept(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reject request
	Reject(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutOfSyncRepositories request
	GetOutOfSyncRepositories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryLockOwner request
	GetRepositoryLockOwner(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepoSyncStatus1 request
	GetRepoSyncStatus1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefChangesQueue request
	GetRefChangesQueue(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefChangesQueueCount request
	GetRefChangesQueueCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryLockOwners request
	GetRepositoryLockOwners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepoSyncStatus request
	GetRepoSyncStatus(ctx context.Context, params *GetRepoSyncStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirrorSettings request
	GetMirrorSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMirrorSettingsWithBody request with any body
	SetMirrorSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMirrorSettings(ctx context.Context, body SetMirrorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirrorMode request
	GetMirrorMode(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMirrorModeWithBody request with any body
	SetMirrorModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMirrorMode(ctx context.Context, body SetMirrorModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMirroredProjects request
	GetMirroredProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartMirroringProjectsWithBody request with any body
	StartMirroringProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartMirroringProjects(ctx context.Context, body StartMirroringProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopMirroringProject request
	StopMirroringProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartMirroringProject request
	StartMirroringProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpstreamServer request
	GetUpstreamServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndRollingUpgrade request
	EndRollingUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartRollingUpgrade request
	StartRollingUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryArchivePolicy request
	GetRepositoryArchivePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryArchivePolicyWithBody request with any body
	SetRepositoryArchivePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryArchivePolicy(ctx context.Context, body SetRepositoryArchivePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryDeletePolicy request
	GetRepositoryDeletePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryDeletePolicyWithBody request with any body
	SetRepositoryDeletePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryDeletePolicy(ctx context.Context, body SetRepositoryDeletePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequiredBuildsMergeCheckWithBody request with any body
	CreateRequiredBuildsMergeCheckWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRequiredBuildsMergeCheck request
	DeleteRequiredBuildsMergeCheck(ctx context.Context, projectKey string, repositorySlug string, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRequiredBuildsMergeCheckWithBody request with any body
	UpdateRequiredBuildsMergeCheckWithBody(ctx context.Context, projectKey string, repositorySlug string, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPageOfRequiredBuildsMergeChecks request
	GetPageOfRequiredBuildsMergeChecks(ctx context.Context, projectKey string, repositorySlug string, params *GetPageOfRequiredBuildsMergeChecksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshKeys request
	DeleteSshKeys(ctx context.Context, params *DeleteSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshKeys request
	GetSshKeys(ctx context.Context, params *GetSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSshKeyWithBody request with any body
	AddSshKeyWithBody(ctx context.Context, params *AddSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSshKey(ctx context.Context, params *AddSshKeyParams, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshKey request
	DeleteSshKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshKey request
	GetSshKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SshSettings request
	SshSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, projectKey string, repositorySlug string, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEnabledWithBody request with any body
	SetEnabledWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetEnabled(ctx context.Context, projectKey string, repositorySlug string, body SetEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SynchronizeWithBody request with any body
	SynchronizeWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Synchronize(ctx context.Context, projectKey string, repositorySlug string, body SynchronizeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllAccessTokens(ctx context.Context, projectKey string, params *GetAllAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessTokensRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessTokenWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessTokenRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessToken(ctx context.Context, projectKey string, body CreateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessTokenRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccessTokens1(ctx context.Context, projectKey string, repositorySlug string, params *GetAllAccessTokens1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessTokens1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessToken1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessToken1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessToken1(ctx context.Context, projectKey string, repositorySlug string, body CreateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessToken1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteById1Request(c.Server, projectKey, repositorySlug, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetById1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetById1Request(c.Server, projectKey, repositorySlug, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessToken1WithBody(ctx context.Context, projectKey string, repositorySlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessToken1RequestWithBody(c.Server, projectKey, repositorySlug, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessToken1(ctx context.Context, projectKey string, repositorySlug string, tokenId string, body UpdateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessToken1Request(c.Server, projectKey, repositorySlug, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteByIdRequest(c.Server, projectKey, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetById(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetByIdRequest(c.Server, projectKey, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessTokenWithBody(ctx context.Context, projectKey string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessTokenRequestWithBody(c.Server, projectKey, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessToken(ctx context.Context, projectKey string, tokenId string, body UpdateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessTokenRequest(c.Server, projectKey, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAccessTokens2(ctx context.Context, userSlug string, params *GetAllAccessTokens2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAccessTokens2Request(c.Server, userSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessToken2WithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessToken2RequestWithBody(c.Server, userSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessToken2(ctx context.Context, userSlug string, body CreateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessToken2Request(c.Server, userSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteById2(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteById2Request(c.Server, userSlug, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetById2(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetById2Request(c.Server, userSlug, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessToken2WithBody(ctx context.Context, userSlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessToken2RequestWithBody(c.Server, userSlug, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessToken2(ctx context.Context, userSlug string, tokenId string, body UpdateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessToken2Request(c.Server, userSlug, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalSettings(ctx context.Context, body UpdateGlobalSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportedKeyTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportedKeyTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBannerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBannerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBannerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBanner(ctx context.Context, body SetBannerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBannerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearDefaultBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearDefaultBranchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultBranchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranch(ctx context.Context, body SetDefaultBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetControlPlanePublicKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetControlPlanePublicKeyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Connectivity(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectivityRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRegisteredMeshNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRegisteredMeshNodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterNewMeshNodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterNewMeshNodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterNewMeshNode(ctx context.Context, body RegisterNewMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterNewMeshNodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete2(ctx context.Context, id int64, params *Delete2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete2Request(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegisteredMeshNodeById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegisteredMeshNodeByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMeshNodeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMeshNodeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMeshNode(ctx context.Context, id string, body UpdateMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMeshNodeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportZips(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportZipsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportZip(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportZipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups1(ctx context.Context, params *GetGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroups1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, params *CreateGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroup(ctx context.Context, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUsersToGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUsersToGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUsersToGroup(ctx context.Context, body AddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUsersToGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUsersInGroup(ctx context.Context, params *FindUsersInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUsersInGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUsersNotInGroup(ctx context.Context, params *FindUsersNotInGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUsersNotInGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromGroup(ctx context.Context, body RemoveUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicense(ctx context.Context, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMailConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMailConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMailConfig(ctx context.Context, body SetMailConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMailConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearSenderAddress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearSenderAddressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSenderAddress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSenderAddressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSenderAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSenderAddressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSenderAddress(ctx context.Context, body SetSenderAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSenderAddressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForGroup(ctx context.Context, params *RevokePermissionsForGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithAnyPermission(ctx context.Context, params *GetGroupsWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithAnyPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForGroups(ctx context.Context, params *SetPermissionForGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithoutAnyPermission(ctx context.Context, params *GetGroupsWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithoutAnyPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForUser(ctx context.Context, params *RevokePermissionsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithAnyPermission(ctx context.Context, params *GetUsersWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithAnyPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForUsers(ctx context.Context, params *SetPermissionForUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithoutAnyPermission(ctx context.Context, params *GetUsersWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithoutAnyPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMergeConfig(ctx context.Context, scmId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMergeConfigRequest(c.Server, scmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMergeConfigWithBody(ctx context.Context, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMergeConfigRequestWithBody(c.Server, scmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMergeConfig(ctx context.Context, scmId string, body SetMergeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMergeConfigRequest(c.Server, scmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHistory(ctx context.Context, params *GetHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettings2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettings2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettings2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettings2(ctx context.Context, body SetSettings2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettings2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRateLimitSettings(ctx context.Context, params *GetAllRateLimitSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRateLimitSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set2(ctx context.Context, body Set2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete8(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete8Request(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get6(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet6Request(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set3WithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet3RequestWithBody(c.Server, userSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set3(ctx context.Context, userSlug string, body Set3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet3Request(c.Server, userSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDirectories(ctx context.Context, params *GetUserDirectoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDirectoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers1(ctx context.Context, params *GetUsers1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsers1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDetailsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDetails(ctx context.Context, body UpdateUserDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDetailsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupToUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupToUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupToUser(ctx context.Context, body AddGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupToUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroups(ctx context.Context, body AddUserToGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearUserCaptchaChallenge(ctx context.Context, params *ClearUserCaptchaChallengeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearUserCaptchaChallengeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateErasable(ctx context.Context, params *ValidateErasableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateErasableRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EraseUser(ctx context.Context, params *EraseUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEraseUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGroupsForUser(ctx context.Context, params *FindGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGroupsForUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOtherGroupsForUser(ctx context.Context, params *FindOtherGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOtherGroupsForUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGroupFromUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGroupFromUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGroupFromUser(ctx context.Context, body RemoveGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGroupFromUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameUser(ctx context.Context, body RenameUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationPropertiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestSuggestions(ctx context.Context, params *GetPullRequestSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestSuggestionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequests1(ctx context.Context, params *GetPullRequests1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequests1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapabilities1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCapabilities1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHookScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHookScriptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHookScript(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHookScriptRequest(c.Server, scriptId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHookScript(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHookScriptRequest(c.Server, scriptId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHookScriptWithBody(ctx context.Context, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHookScriptRequestWithBody(c.Server, scriptId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Read(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRequest(c.Server, scriptId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvatar(ctx context.Context, hookKey string, params *GetAvatarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvatarRequest(c.Server, hookKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequests2(ctx context.Context, params *GetPullRequests2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequests2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabels(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabel(ctx context.Context, labelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelRequest(c.Server, labelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabelables(ctx context.Context, labelName string, params *GetLabelablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabelablesRequest(c.Server, labelName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLevel(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLevelRequest(c.Server, loggerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLevel(ctx context.Context, loggerName string, levelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLevelRequest(c.Server, loggerName, levelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootLevel(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootLevelRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRootLevel(ctx context.Context, levelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRootLevelRequest(c.Server, levelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewWithBody(ctx context.Context, params *PreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartExport(ctx context.Context, body StartExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewExport(ctx context.Context, body PreviewExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelExportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelExportJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExportJobMessages(ctx context.Context, jobId string, params *GetExportJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportJobMessagesRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartImport(ctx context.Context, body StartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelImportJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelImportJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportJobMessages(ctx context.Context, jobId string, params *GetImportJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportJobMessagesRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartMeshMigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartMeshMigrationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartMeshMigration(ctx context.Context, body StartMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartMeshMigrationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewMeshMigrationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewMeshMigrationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewMeshMigration(ctx context.Context, body PreviewMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewMeshMigrationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMeshMigrationRepos(ctx context.Context, params *SearchMeshMigrationReposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMeshMigrationReposRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllMeshMigrationSummaries(ctx context.Context, params *GetAllMeshMigrationSummariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllMeshMigrationSummariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveMeshMigrationSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveMeshMigrationSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeshMigrationJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeshMigrationJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelMeshMigrationJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelMeshMigrationJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeshMigrationJobMessages(ctx context.Context, jobId string, params *GetMeshMigrationJobMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeshMigrationJobMessagesRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeshMigrationJobSummary(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeshMigrationJobSummaryRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoriesRecentlyAccessed(ctx context.Context, params *GetRepositoriesRecentlyAccessedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesRecentlyAccessedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjects(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectKey string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectAvatar(ctx context.Context, projectKey string, params *GetProjectAvatarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectAvatarRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAvatarWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAvatarRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurations(ctx context.Context, projectKey string, params *GetConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationsRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveConfiguration(ctx context.Context, projectKey string, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveConfigurationRequest(c.Server, projectKey, scriptId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfigurationWithBody(ctx context.Context, projectKey string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfigurationRequestWithBody(c.Server, projectKey, scriptId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfiguration(ctx context.Context, projectKey string, scriptId string, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfigurationRequest(c.Server, projectKey, scriptId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissions(ctx context.Context, projectKey string, params *RevokePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForGroup1(ctx context.Context, projectKey string, params *RevokePermissionsForGroup1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForGroup1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithAnyPermission1(ctx context.Context, projectKey string, params *GetGroupsWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithAnyPermission1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForGroups1(ctx context.Context, projectKey string, params *SetPermissionForGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForGroups1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithoutAnyPermission1(ctx context.Context, projectKey string, params *GetGroupsWithoutAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithoutAnyPermission1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPermissions(ctx context.Context, projectKey string, params *SearchPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPermissionsRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForUser1(ctx context.Context, projectKey string, params *RevokePermissionsForUser1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForUser1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithAnyPermission1(ctx context.Context, projectKey string, params *GetUsersWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithAnyPermission1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForUsers1(ctx context.Context, projectKey string, params *SetPermissionForUsers1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForUsers1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithoutPermission(ctx context.Context, projectKey string, params *GetUsersWithoutPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithoutPermissionRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HasAllUserPermission(ctx context.Context, projectKey string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHasAllUserPermissionRequest(c.Server, projectKey, permission)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyAllUserPermission(ctx context.Context, projectKey string, permission string, params *ModifyAllUserPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyAllUserPermissionRequest(c.Server, projectKey, permission, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositories(ctx context.Context, projectKey string, params *GetRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, projectKey string, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForkRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForkRepositoryRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForkRepository(ctx context.Context, projectKey string, repositorySlug string, body ForkRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForkRepositoryRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRepositoryRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRepository(ctx context.Context, projectKey string, repositorySlug string, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRepositoryRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchive(ctx context.Context, projectKey string, repositorySlug string, params *GetArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchiveRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttachment(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttachmentRequest(c.Server, projectKey, repositorySlug, attachmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachment(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentRequest(c.Server, projectKey, repositorySlug, attachmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttachmentMetadataRequest(c.Server, projectKey, repositorySlug, attachmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentMetadataRequest(c.Server, projectKey, repositorySlug, attachmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAttachmentMetadataWithBody(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAttachmentMetadataRequestWithBody(c.Server, projectKey, repositorySlug, attachmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAttachmentMetadata(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, body SaveAttachmentMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAttachmentMetadataRequest(c.Server, projectKey, repositorySlug, attachmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranches(ctx context.Context, projectKey string, repositorySlug string, params *GetBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForRepositoryRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchForRepository(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchForRepositoryRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultBranch1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranch1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranch1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranch1(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranch1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContent(ctx context.Context, projectKey string, repositorySlug string, params *GetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContent1(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetContent1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContent1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditFileWithBody(ctx context.Context, projectKey string, repositorySlug string, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditFileRequestWithBody(c.Server, projectKey, repositorySlug, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChanges1(ctx context.Context, projectKey string, repositorySlug string, params *GetChanges1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChanges1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommits(ctx context.Context, projectKey string, repositorySlug string, params *GetCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitsRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommit(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRequestWithBody(c.Server, projectKey, repositorySlug, commitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChanges(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangesRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComments(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentsRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentRequestWithBody(c.Server, projectKey, repositorySlug, commitId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentRequest(c.Server, projectKey, repositorySlug, commitId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentRequest(c.Server, projectKey, repositorySlug, commitId, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentRequest(c.Server, projectKey, repositorySlug, commitId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentRequestWithBody(c.Server, projectKey, repositorySlug, commitId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, body UpdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentRequest(c.Server, projectKey, repositorySlug, commitId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Delete1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete1Request(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Get1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet1Request(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateDeploymentWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateDeploymentRequestWithBody(c.Server, projectKey, repositorySlug, commitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiffStatsSummary(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *GetDiffStatsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiffStatsSummaryRequest(c.Server, projectKey, repositorySlug, commitId, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamDiff(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *StreamDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamDiffRequest(c.Server, projectKey, repositorySlug, commitId, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMergeBase(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetMergeBaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMergeBaseRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequests(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestsRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unwatch(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnwatchRequest(c.Server, projectKey, repositorySlug, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Watch(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchRequest(c.Server, projectKey, repositorySlug, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamChanges(ctx context.Context, projectKey string, repositorySlug string, params *StreamChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamChangesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamCommits(ctx context.Context, projectKey string, repositorySlug string, params *StreamCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamCommitsRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiffStatsSummary1(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetDiffStatsSummary1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiffStatsSummary1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamDiff1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamDiff1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamDiff1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamContributing(ctx context.Context, projectKey string, repositorySlug string, params *StreamContributingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamContributingRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultBranch2(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultBranch2Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranch2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranch2RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultBranch2(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultBranch2Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRawDiff(ctx context.Context, projectKey string, repositorySlug string, params *StreamRawDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRawDiffRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRawDiff1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawDiff1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRawDiff1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFiles(ctx context.Context, projectKey string, repositorySlug string, params *StreamFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFilesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFiles1(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamFiles1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFiles1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForkedRepositories(ctx context.Context, projectKey string, repositorySlug string, params *GetForkedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForkedRepositoriesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurations1(ctx context.Context, projectKey string, repositorySlug string, params *GetConfigurations1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurations1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveConfiguration1(ctx context.Context, projectKey string, repositorySlug string, scriptId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveConfiguration1Request(c.Server, projectKey, repositorySlug, scriptId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfiguration1WithBody(ctx context.Context, projectKey string, repositorySlug string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfiguration1RequestWithBody(c.Server, projectKey, repositorySlug, scriptId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfiguration1(ctx context.Context, projectKey string, repositorySlug string, scriptId string, body SetConfiguration1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfiguration1Request(c.Server, projectKey, repositorySlug, scriptId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLabelsForRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLabelsForRepositoryRequest(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLabelWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLabelRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLabel(ctx context.Context, projectKey string, repositorySlug string, body AddLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLabelRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveLabel(ctx context.Context, projectKey string, repositorySlug string, labelName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveLabelRequest(c.Server, projectKey, repositorySlug, labelName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stream(ctx context.Context, projectKey string, repositorySlug string, params *StreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stream1(ctx context.Context, projectKey string, repositorySlug string, path string, params *Stream1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStream1Request(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamLicense(ctx context.Context, projectKey string, repositorySlug string, params *StreamLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamLicenseRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, projectKey string, repositorySlug string, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamPatch(ctx context.Context, projectKey string, repositorySlug string, params *StreamPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamPatchRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissions1(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissions1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissions1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForGroup2(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForGroup2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForGroup2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithAnyPermission2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForGroup(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForGroupRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsWithoutAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithoutAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsWithoutAnyPermission2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPermissions1(ctx context.Context, projectKey string, repositorySlug string, params *SearchPermissions1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPermissions1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsForUser2(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForUser2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsForUser2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithAnyPermission2(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithAnyPermission2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPermissionForUser(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPermissionForUserRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithoutPermission1(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithoutPermission1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithoutPermission1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPage(ctx context.Context, projectKey string, repositorySlug string, params *GetPageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, projectKey string, repositorySlug string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete3WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete3RequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete3(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body Delete3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete3Request(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get3(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet3Request(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRawDiff2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamRawDiff2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRawDiff2Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamPatch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamPatch1Request(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivities(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitiesRequest(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawApproval(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawApprovalRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Approve(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelAutoMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelAutoMergeRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoMergeRequest(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoMergeRequestRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TryAutoMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTryAutoMergeRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComments1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComments1Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment1WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComment1RequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComment1Request(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComment1Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComment1Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment1WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComment1RequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComment1Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamChanges1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamChanges1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamChanges1Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComments2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComments2Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment2WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComment2RequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComment2Request(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComment2Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComment2Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment2WithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComment2RequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComment2Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplySuggestionWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplySuggestionRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplySuggestion(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body ApplySuggestionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplySuggestionRequest(c.Server, projectKey, repositorySlug, pullRequestId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommitMessageSuggestion(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitMessageSuggestionRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommits1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetCommits1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommits1Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Decline(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, body DeclineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineRequest(c.Server, projectKey, repositorySlug, pullRequestId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiffStatsSummary2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *GetDiffStatsSummary2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiffStatsSummary2Request(c.Server, projectKey, repositorySlug, pullRequestId, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamDiff2(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *StreamDiff2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamDiff2Request(c.Server, projectKey, repositorySlug, pullRequestId, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CanMerge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCanMergeRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Merge(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, body MergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeRequest(c.Server, projectKey, repositorySlug, pullRequestId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMergeBase1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMergeBase1Request(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignParticipantRole1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *UnassignParticipantRole1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignParticipantRole1Request(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListParticipants(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ListParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListParticipantsRequest(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignParticipantRoleWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignParticipantRoleRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignParticipantRole(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body AssignParticipantRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignParticipantRoleRequest(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignParticipantRole(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignParticipantRoleRequest(c.Server, projectKey, repositorySlug, pullRequestId, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStatusWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStatusRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, userSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStatus(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStatusRequest(c.Server, projectKey, repositorySlug, pullRequestId, userSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReopenWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReopenRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reopen(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, body ReopenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReopenRequest(c.Server, projectKey, repositorySlug, pullRequestId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscardReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscardReviewRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewRequest(c.Server, projectKey, repositorySlug, pullRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FinishReviewWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFinishReviewRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FinishReview(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, body FinishReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFinishReviewRequest(c.Server, projectKey, repositorySlug, pullRequestId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unwatch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnwatch1Request(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Watch1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatch1Request(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRaw(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRawRequest(c.Server, projectKey, repositorySlug, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamReadme(ctx context.Context, projectKey string, repositorySlug string, params *StreamReadmeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamReadmeRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryCreateRepository(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryCreateRepositoryRequest(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefChangeActivity(ctx context.Context, projectKey string, repositorySlug string, params *GetRefChangeActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefChangeActivityRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBranches(ctx context.Context, projectKey string, repositorySlug string, params *FindBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBranchesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRelatedRepositories(ctx context.Context, projectKey string, repositorySlug string, params *GetRelatedRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRelatedRepositoriesRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search2(ctx context.Context, projectKey string, repositorySlug string, params *Search2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch2Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllowlistRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllowlistRule1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowlistRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowlistRule1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllowlistRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllowlistRule1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAllowlistRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAllowlistRule1RequestWithBody(c.Server, projectKey, repositorySlug, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search3(ctx context.Context, projectKey string, repositorySlug string, params *Search3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch3Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRule1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRule1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRule1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditRule1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditRule1RequestWithBody(c.Server, projectKey, repositorySlug, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAutoDeclineSettings1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoDeclineSettings1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoDeclineSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoDeclineSettings1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoDeclineSettings1(ctx context.Context, projectKey string, repositorySlug string, body SetAutoDeclineSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoDeclineSettings1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete5(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete5Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get5(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet5Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set1(ctx context.Context, projectKey string, repositorySlug string, body Set1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSet1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryHooks1(ctx context.Context, projectKey string, repositorySlug string, params *GetRepositoryHooks1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryHooks1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryHook(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryHookRequest(c.Server, projectKey, repositorySlug, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryHook1Request(c.Server, projectKey, repositorySlug, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableHook1Request(c.Server, projectKey, repositorySlug, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableHook1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, params *EnableHook1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableHook1Request(c.Server, projectKey, repositorySlug, hookKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettings1Request(c.Server, projectKey, repositorySlug, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettings1RequestWithBody(c.Server, projectKey, repositorySlug, hookKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettings1(ctx context.Context, projectKey string, repositorySlug string, hookKey string, body SetSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettings1Request(c.Server, projectKey, repositorySlug, hookKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestSettings1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestSettings1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestSettings1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestSettings1(ctx context.Context, projectKey string, repositorySlug string, body UpdatePullRequestSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestSettings1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewerGroups1(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewerGroups1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewerGroups1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate2RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create2(ctx context.Context, projectKey string, repositorySlug string, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate2Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete7(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete7Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewerGroup1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewerGroup1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update2WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdate2RequestWithBody(c.Server, projectKey, repositorySlug, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update2(ctx context.Context, projectKey string, repositorySlug string, id string, body Update2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdate2Request(c.Server, projectKey, repositorySlug, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, projectKey string, repositorySlug string, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagForRepositoryRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagForRepository(ctx context.Context, projectKey string, repositorySlug string, body CreateTagForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagForRepositoryRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, projectKey, repositorySlug, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unwatch2(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnwatch2Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Watch2WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatch2RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Watch2(ctx context.Context, projectKey string, repositorySlug string, body Watch2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatch2Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWebhooks1(ctx context.Context, projectKey string, repositorySlug string, params *FindWebhooks1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWebhooks1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhook1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook1(ctx context.Context, projectKey string, repositorySlug string, body CreateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhook1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWebhooks(ctx context.Context, projectKey string, repositorySlug string, params *SearchWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWebhooksRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhook1RequestWithBody(c.Server, projectKey, repositorySlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhook1(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, body TestWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhook1Request(c.Server, projectKey, repositorySlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhook1Request(c.Server, projectKey, repositorySlug, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetWebhook1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhook1Request(c.Server, projectKey, repositorySlug, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook1WithBody(ctx context.Context, projectKey string, repositorySlug string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhook1RequestWithBody(c.Server, projectKey, repositorySlug, webhookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, body UpdateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhook1Request(c.Server, projectKey, repositorySlug, webhookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestInvocation1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetLatestInvocation1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestInvocation1Request(c.Server, projectKey, repositorySlug, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatistics1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetStatistics1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatistics1Request(c.Server, projectKey, repositorySlug, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsSummary1(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsSummary1Request(c.Server, projectKey, repositorySlug, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAllowlistRule(ctx context.Context, projectKey string, params *SearchAllowlistRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAllowlistRuleRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllowlistRuleWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllowlistRuleRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowlistRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowlistRuleRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllowlistRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllowlistRuleRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAllowlistRuleWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAllowlistRuleRequestWithBody(c.Server, projectKey, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search1(ctx context.Context, projectKey string, params *Search1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch1Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditRuleWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditRuleRequestWithBody(c.Server, projectKey, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete9(ctx context.Context, projectKey string, params *Delete9Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete9Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get7(ctx context.Context, projectKey string, params *Get7Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet7Request(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create3WithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate3RequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create3(ctx context.Context, projectKey string, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate3Request(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAll(ctx context.Context, projectKey string, params *GetAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAutoDeclineSettings(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAutoDeclineSettingsRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoDeclineSettings(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoDeclineSettingsRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoDeclineSettingsWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoDeclineSettingsRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoDeclineSettings(ctx context.Context, projectKey string, body SetAutoDeclineSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoDeclineSettingsRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete4(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete4Request(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get4(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGet4Request(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Set(ctx context.Context, projectKey string, body SetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryHooks(ctx context.Context, projectKey string, params *GetRepositoryHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryHooksRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryHook(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryHookRequest(c.Server, projectKey, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableHook(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableHookRequest(c.Server, projectKey, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableHook(ctx context.Context, projectKey string, hookKey string, params *EnableHookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableHookRequest(c.Server, projectKey, hookKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server, projectKey, hookKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettingsWithBody(ctx context.Context, projectKey string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettingsRequestWithBody(c.Server, projectKey, hookKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSettings(ctx context.Context, projectKey string, hookKey string, body SetSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSettingsRequest(c.Server, projectKey, hookKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestSettings(ctx context.Context, projectKey string, scmId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestSettingsRequest(c.Server, projectKey, scmId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestSettingsWithBody(ctx context.Context, projectKey string, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestSettingsRequestWithBody(c.Server, projectKey, scmId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestSettings(ctx context.Context, projectKey string, scmId string, body UpdatePullRequestSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestSettingsRequest(c.Server, projectKey, scmId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewerGroups(ctx context.Context, projectKey string, params *GetReviewerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewerGroupsRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create1WithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate1RequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create1(ctx context.Context, projectKey string, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate1Request(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete6(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelete6Request(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewerGroup(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewerGroupRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update1WithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdate1RequestWithBody(c.Server, projectKey, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update1(ctx context.Context, projectKey string, id string, body Update1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdate1Request(c.Server, projectKey, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWebhooks(ctx context.Context, projectKey string, params *FindWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWebhooksRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook(ctx context.Context, projectKey string, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhookWithBody(ctx context.Context, projectKey string, params *TestWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhookRequestWithBody(c.Server, projectKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestWebhook(ctx context.Context, projectKey string, params *TestWebhookParams, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestWebhookRequest(c.Server, projectKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, projectKey, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, projectKey string, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, projectKey, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithBody(ctx context.Context, projectKey string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithBody(c.Server, projectKey, webhookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook(ctx context.Context, projectKey string, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequest(c.Server, projectKey, webhookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestInvocation(ctx context.Context, projectKey string, webhookId string, params *GetLatestInvocationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestInvocationRequest(c.Server, projectKey, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatistics(ctx context.Context, projectKey string, webhookId string, params *GetStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsRequest(c.Server, projectKey, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsSummary(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsSummaryRequest(c.Server, projectKey, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositories1(ctx context.Context, params *GetRepositories1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositories1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindExemptReposByScope(ctx context.Context, params *FindExemptReposByScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindExemptReposByScopeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddExemptRepositoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddExemptRepositoriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search4(ctx context.Context, params *Search4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearch4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRule2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRule2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRule2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditRule2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditRule2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCertificateRevocationListEntries(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCertificateRevocationListEntriesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCertificateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSigningConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSigningConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemSigningConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemSigningConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSystemSigningConfiguration(ctx context.Context, body UpdateSystemSigningConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSystemSigningConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers2(ctx context.Context, params *GetUsers2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsers2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDetails1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDetails1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDetails1(ctx context.Context, body UpdateUserDetails1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDetails1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPassword1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword1(ctx context.Context, body UpdateUserPassword1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPassword1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAvatar(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAvatarRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAvatar1WithBody(ctx context.Context, userSlug string, params *UploadAvatar1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAvatar1RequestWithBody(c.Server, userSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSettings(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSettingsRequest(c.Server, userSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsWithBody(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsRequestWithBody(c.Server, userSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettings(ctx context.Context, userSlug string, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsRequest(c.Server, userSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DismissRetentionConfigReviewNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDismissRetentionConfigReviewNotificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRestrictions1(ctx context.Context, projectKey string, repositorySlug string, params *GetRestrictions1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestrictions1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestrictions1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestrictions1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestrictions1WithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx context.Context, projectKey string, repositorySlug string, body CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestrictions1RequestWithApplicationVndAtlBitbucketBulkPlusJSONBody(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRestriction1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRestriction1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRestriction1(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestriction1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRestrictions(ctx context.Context, projectKey string, params *GetRestrictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestrictionsRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestrictionsWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestrictionsRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRestrictionsWithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx context.Context, projectKey string, body CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRestrictionsRequestWithApplicationVndAtlBitbucketBulkPlusJSONBody(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRestriction(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRestrictionRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRestriction(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRestrictionRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranchWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranch(ctx context.Context, projectKey string, repositorySlug string, body DeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranch(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindByCommit(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *FindByCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindByCommitRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleBuildStatusStatsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleBuildStatusStatsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleBuildStatusStats(ctx context.Context, body GetMultipleBuildStatusStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleBuildStatusStatsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildStatusStats(ctx context.Context, commitId string, params *GetBuildStatusStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildStatusStatsRequest(c.Server, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildStatus(ctx context.Context, commitId string, params *GetBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildStatusRequest(c.Server, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuildStatusWithBody(ctx context.Context, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuildStatusRequestWithBody(c.Server, commitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuildStatus(ctx context.Context, commitId string, body AddBuildStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuildStatusRequest(c.Server, commitId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnReact(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnReactRequest(c.Server, projectKey, repositorySlug, commitId, commentId, emoticon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) React(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactRequest(c.Server, projectKey, repositorySlug, commitId, commentId, emoticon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnReact1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnReact1Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, emoticon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) React1(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReact1Request(c.Server, projectKey, repositorySlug, pullRequestId, commentId, emoticon)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestConditionWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestConditionRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestCondition(ctx context.Context, projectKey string, body CreatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestConditionRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePullRequestCondition(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePullRequestConditionRequest(c.Server, projectKey, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestConditionWithBody(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestConditionRequestWithBody(c.Server, projectKey, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestCondition(ctx context.Context, projectKey string, id string, body UpdatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestConditionRequest(c.Server, projectKey, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestConditions(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestConditionsRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestCondition1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestCondition1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, body CreatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePullRequestCondition1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePullRequestCondition1Request(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestCondition1WithBody(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestCondition1RequestWithBody(c.Server, projectKey, repositorySlug, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePullRequestCondition1(ctx context.Context, projectKey string, repositorySlug string, id string, body UpdatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePullRequestCondition1Request(c.Server, projectKey, repositorySlug, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequestConditions1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestConditions1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReviewers(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReviewersRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllDefaultTasks1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultTasks1(ctx context.Context, projectKey string, repositorySlug string, params *GetDefaultTasks1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultTasks1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultTask1WithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultTask1RequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, body AddDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultTask1Request(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDefaultTask1Request(c.Server, projectKey, repositorySlug, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDefaultTask1WithBody(ctx context.Context, projectKey string, repositorySlug string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDefaultTask1RequestWithBody(c.Server, projectKey, repositorySlug, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDefaultTask1(ctx context.Context, projectKey string, repositorySlug string, taskId string, body UpdateDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDefaultTask1Request(c.Server, projectKey, repositorySlug, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllDefaultTasks(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllDefaultTasksRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultTasks(ctx context.Context, projectKey string, params *GetDefaultTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultTasksRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultTaskWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultTaskRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultTask(ctx context.Context, projectKey string, body AddDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultTaskRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDefaultTask(ctx context.Context, projectKey string, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDefaultTaskRequest(c.Server, projectKey, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDefaultTaskWithBody(ctx context.Context, projectKey string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDefaultTaskRequestWithBody(c.Server, projectKey, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDefaultTask(ctx context.Context, projectKey string, taskId string, body UpdateDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDefaultTaskRequest(c.Server, projectKey, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CanRebase(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCanRebaseRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebaseWithBody(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebaseRequestWithBody(c.Server, projectKey, repositorySlug, pullRequestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Rebase(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body RebaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebaseRequest(c.Server, projectKey, repositorySlug, pullRequestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, projectKey string, repositorySlug string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, projectKey, repositorySlug, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteForUser(ctx context.Context, params *DeleteForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteForUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeysForUser(ctx context.Context, params *GetKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysForUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKeyWithBody(ctx context.Context, params *AddKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKey(ctx context.Context, params *AddKeyParams, body AddKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKeyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKey(ctx context.Context, fingerprintOrId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyRequest(c.Server, fingerprintOrId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnnotations1(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetAnnotations1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnnotations1Request(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReports(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportsRequest(c.Server, projectKey, repositorySlug, commitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACodeInsightsReportRequest(c.Server, projectKey, repositorySlug, commitId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACodeInsightsReportRequest(c.Server, projectKey, repositorySlug, commitId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetACodeInsightsReportWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetACodeInsightsReportRequestWithBody(c.Server, projectKey, repositorySlug, commitId, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetACodeInsightsReport(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body SetACodeInsightsReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetACodeInsightsReportRequest(c.Server, projectKey, repositorySlug, commitId, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, params *DeleteAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAnnotationsRequest(c.Server, projectKey, repositorySlug, commitId, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnnotationsRequest(c.Server, projectKey, repositorySlug, commitId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAnnotationsWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAnnotationsRequestWithBody(c.Server, projectKey, repositorySlug, commitId, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAnnotations(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body AddAnnotationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAnnotationsRequest(c.Server, projectKey, repositorySlug, commitId, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAnnotationWithBody(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAnnotationRequestWithBody(c.Server, projectKey, repositorySlug, commitId, key, externalId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAnnotation(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, body SetAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAnnotationRequest(c.Server, projectKey, repositorySlug, commitId, key, externalId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIssueWithBody(ctx context.Context, commentId string, params *CreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIssueRequestWithBody(c.Server, commentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIssue(ctx context.Context, commentId string, params *CreateIssueParams, body CreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIssueRequest(c.Server, commentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommitsByIssueKey(ctx context.Context, issueKey string, params *GetCommitsByIssueKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitsByIssueKeyRequest(c.Server, issueKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnhancedEntityLinkForProject(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnhancedEntityLinkForProjectRequest(c.Server, projectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIssueKeysForPullRequest(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIssueKeysForPullRequestRequest(c.Server, projectKey, repositorySlug, pullRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForRepository1(ctx context.Context, projectKey string, repositorySlug string, params *GetForRepository1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForRepository1Request(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddForRepositoryWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddForRepositoryRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddForRepository(ctx context.Context, projectKey string, repositorySlug string, body AddForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddForRepositoryRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeForRepository(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeForRepositoryRequest(c.Server, projectKey, repositorySlug, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForRepository(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForRepositoryRequest(c.Server, projectKey, repositorySlug, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermission1(ctx context.Context, projectKey string, repositorySlug string, keyId string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermission1Request(c.Server, projectKey, repositorySlug, keyId, permission)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshKeysForProject(ctx context.Context, projectKey string, params *GetSshKeysForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshKeysForProjectRequest(c.Server, projectKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddForProjectWithBody(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddForProjectRequestWithBody(c.Server, projectKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddForProject(ctx context.Context, projectKey string, body AddForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddForProjectRequest(c.Server, projectKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeForProject(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeForProjectRequest(c.Server, projectKey, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForProject(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForProjectRequest(c.Server, projectKey, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermission(ctx context.Context, projectKey string, keyId string, permission string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermissionRequest(c.Server, projectKey, keyId, permission)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeManyWithBody(ctx context.Context, keyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeManyRequestWithBody(c.Server, keyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeMany(ctx context.Context, keyId string, body RevokeManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeManyRequest(c.Server, keyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForProjects(ctx context.Context, keyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForProjectsRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForRepositories(ctx context.Context, keyId string, params *GetForRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForRepositoriesRequest(c.Server, keyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePreferredMirrorId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePreferredMirrorIdRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreferredMirrorId(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreferredMirrorIdRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPreferredMirrorIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPreferredMirrorIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPreferredMirrorId(ctx context.Context, body SetPreferredMirrorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPreferredMirrorIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyticsSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyticsSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFarmNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFarmNodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirroredRepository(ctx context.Context, externalRepositoryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirroredRepositoryRequest(c.Server, externalRepositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMirrors(ctx context.Context, params *ListMirrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMirrorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Remove(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRequest(c.Server, mirrorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirror(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirrorRequest(c.Server, mirrorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeWithBody(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeRequestWithBody(c.Server, mirrorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Upgrade(ctx context.Context, mirrorId string, body UpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeRequest(c.Server, mirrorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishEventWithBody(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishEventRequestWithBody(c.Server, mirrorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishEvent(ctx context.Context, mirrorId string, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishEventRequest(c.Server, mirrorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSynchronizationProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSynchronizationProgressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectById(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectByIdRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllReposForProject(ctx context.Context, projectId string, params *GetAllReposForProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllReposForProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllContentHashes(ctx context.Context, params *GetAllContentHashesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllContentHashesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentHashById(ctx context.Context, repoId string, params *GetContentHashByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentHashByIdRequest(c.Server, repoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryMirrors(ctx context.Context, repoId string, params *GetRepositoryMirrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryMirrorsRequest(c.Server, repoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequests(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMirroringRequest(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMirroringRequestRequest(c.Server, mirroringRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirroringRequest(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirroringRequestRequest(c.Server, mirroringRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Accept(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptRequest(c.Server, mirroringRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reject(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectRequest(c.Server, mirroringRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutOfSyncRepositories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutOfSyncRepositoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryLockOwner(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryLockOwnerRequest(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepoSyncStatus1(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepoSyncStatus1Request(c.Server, projectKey, repositorySlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefChangesQueue(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefChangesQueueRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefChangesQueueCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefChangesQueueCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryLockOwners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryLockOwnersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepoSyncStatus(ctx context.Context, params *GetRepoSyncStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepoSyncStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirrorSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirrorSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMirrorSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMirrorSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMirrorSettings(ctx context.Context, body SetMirrorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMirrorSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirrorMode(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirrorModeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMirrorModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMirrorModeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMirrorMode(ctx context.Context, body SetMirrorModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMirrorModeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMirroredProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMirroredProjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartMirroringProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartMirroringProjectsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartMirroringProjects(ctx context.Context, body StartMirroringProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartMirroringProjectsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopMirroringProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopMirroringProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartMirroringProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartMirroringProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpstreamServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpstreamServerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndRollingUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndRollingUpgradeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRollingUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRollingUpgradeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryArchivePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryArchivePolicyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryArchivePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryArchivePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryArchivePolicy(ctx context.Context, body SetRepositoryArchivePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryArchivePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryDeletePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryDeletePolicyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryDeletePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryDeletePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryDeletePolicy(ctx context.Context, body SetRepositoryDeletePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryDeletePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequiredBuildsMergeCheckWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequiredBuildsMergeCheckRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRequiredBuildsMergeCheck(ctx context.Context, projectKey string, repositorySlug string, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequiredBuildsMergeCheckRequest(c.Server, projectKey, repositorySlug, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequiredBuildsMergeCheckWithBody(ctx context.Context, projectKey string, repositorySlug string, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequiredBuildsMergeCheckRequestWithBody(c.Server, projectKey, repositorySlug, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPageOfRequiredBuildsMergeChecks(ctx context.Context, projectKey string, repositorySlug string, params *GetPageOfRequiredBuildsMergeChecksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPageOfRequiredBuildsMergeChecksRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshKeys(ctx context.Context, params *DeleteSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshKeys(ctx context.Context, params *GetSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSshKeyWithBody(ctx context.Context, params *AddSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSshKeyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSshKey(ctx context.Context, params *AddSshKeyParams, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSshKeyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshKeyRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshKey(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshKeyRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SshSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSshSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, projectKey string, repositorySlug string, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server, projectKey, repositorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEnabledWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEnabledRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEnabled(ctx context.Context, projectKey string, repositorySlug string, body SetEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEnabledRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SynchronizeWithBody(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSynchronizeRequestWithBody(c.Server, projectKey, repositorySlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Synchronize(ctx context.Context, projectKey string, repositorySlug string, body SynchronizeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSynchronizeRequest(c.Server, projectKey, repositorySlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllAccessTokensRequest generates requests for GetAllAccessTokens
func NewGetAllAccessTokensRequest(server string, projectKey string, params *GetAllAccessTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessTokenRequest calls the generic CreateAccessToken builder with application/json body
func NewCreateAccessTokenRequest(server string, projectKey string, body CreateAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessTokenRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreateAccessTokenRequestWithBody generates requests for CreateAccessToken with any type of body
func NewCreateAccessTokenRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAccessTokens1Request generates requests for GetAllAccessTokens1
func NewGetAllAccessTokens1Request(server string, projectKey string, repositorySlug string, params *GetAllAccessTokens1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessToken1Request calls the generic CreateAccessToken1 builder with application/json body
func NewCreateAccessToken1Request(server string, projectKey string, repositorySlug string, body CreateAccessToken1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessToken1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateAccessToken1RequestWithBody generates requests for CreateAccessToken1 with any type of body
func NewCreateAccessToken1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteById1Request generates requests for DeleteById1
func NewDeleteById1Request(server string, projectKey string, repositorySlug string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetById1Request generates requests for GetById1
func NewGetById1Request(server string, projectKey string, repositorySlug string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessToken1Request calls the generic UpdateAccessToken1 builder with application/json body
func NewUpdateAccessToken1Request(server string, projectKey string, repositorySlug string, tokenId string, body UpdateAccessToken1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessToken1RequestWithBody(server, projectKey, repositorySlug, tokenId, "application/json", bodyReader)
}

// NewUpdateAccessToken1RequestWithBody generates requests for UpdateAccessToken1 with any type of body
func NewUpdateAccessToken1RequestWithBody(server string, projectKey string, repositorySlug string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteByIdRequest generates requests for DeleteById
func NewDeleteByIdRequest(server string, projectKey string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetByIdRequest generates requests for GetById
func NewGetByIdRequest(server string, projectKey string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessTokenRequest calls the generic UpdateAccessToken builder with application/json body
func NewUpdateAccessTokenRequest(server string, projectKey string, tokenId string, body UpdateAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessTokenRequestWithBody(server, projectKey, tokenId, "application/json", bodyReader)
}

// NewUpdateAccessTokenRequestWithBody generates requests for UpdateAccessToken with any type of body
func NewUpdateAccessTokenRequestWithBody(server string, projectKey string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/projects/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAccessTokens2Request generates requests for GetAllAccessTokens2
func NewGetAllAccessTokens2Request(server string, userSlug string, params *GetAllAccessTokens2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessToken2Request calls the generic CreateAccessToken2 builder with application/json body
func NewCreateAccessToken2Request(server string, userSlug string, body CreateAccessToken2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessToken2RequestWithBody(server, userSlug, "application/json", bodyReader)
}

// NewCreateAccessToken2RequestWithBody generates requests for CreateAccessToken2 with any type of body
func NewCreateAccessToken2RequestWithBody(server string, userSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteById2Request generates requests for DeleteById2
func NewDeleteById2Request(server string, userSlug string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/users/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetById2Request generates requests for GetById2
func NewGetById2Request(server string, userSlug string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/users/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessToken2Request calls the generic UpdateAccessToken2 builder with application/json body
func NewUpdateAccessToken2Request(server string, userSlug string, tokenId string, body UpdateAccessToken2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessToken2RequestWithBody(server, userSlug, tokenId, "application/json", bodyReader)
}

// NewUpdateAccessToken2RequestWithBody generates requests for UpdateAccessToken2 with any type of body
func NewUpdateAccessToken2RequestWithBody(server string, userSlug string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-tokens/latest/users/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGlobalSettingsRequest generates requests for GetGlobalSettings
func NewGetGlobalSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGlobalSettingsRequest calls the generic UpdateGlobalSettings builder with application/json body
func NewUpdateGlobalSettingsRequest(server string, body UpdateGlobalSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGlobalSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateGlobalSettingsRequestWithBody generates requests for UpdateGlobalSettings with any type of body
func NewUpdateGlobalSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSupportedKeyTypesRequest generates requests for GetSupportedKeyTypes
func NewGetSupportedKeyTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/supported-key-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBannerRequest generates requests for DeleteBanner
func NewDeleteBannerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBannerRequest generates requests for GetBanner
func NewGetBannerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBannerRequest calls the generic SetBanner builder with application/json body
func NewSetBannerRequest(server string, body SetBannerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBannerRequestWithBody(server, "application/json", bodyReader)
}

// NewSetBannerRequestWithBody generates requests for SetBanner with any type of body
func NewSetBannerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInformationRequest generates requests for GetInformation
func NewGetInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearDefaultBranchRequest generates requests for ClearDefaultBranch
func NewClearDefaultBranchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/default-branch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultBranchRequest generates requests for GetDefaultBranch
func NewGetDefaultBranchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/default-branch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultBranchRequest calls the generic SetDefaultBranch builder with application/json body
func NewSetDefaultBranchRequest(server string, body SetDefaultBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultBranchRequestWithBody(server, "application/json", bodyReader)
}

// NewSetDefaultBranchRequestWithBody generates requests for SetDefaultBranch with any type of body
func NewSetDefaultBranchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/default-branch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetControlPlanePublicKeyRequest generates requests for GetControlPlanePublicKey
func NewGetControlPlanePublicKeyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/config/control-plane.pem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectivityRequest generates requests for Connectivity
func NewConnectivityRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/diagnostics/connectivity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRegisteredMeshNodesRequest generates requests for GetAllRegisteredMeshNodes
func NewGetAllRegisteredMeshNodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterNewMeshNodeRequest calls the generic RegisterNewMeshNode builder with application/json body
func NewRegisterNewMeshNodeRequest(server string, body RegisterNewMeshNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterNewMeshNodeRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterNewMeshNodeRequestWithBody generates requests for RegisterNewMeshNode with any type of body
func NewRegisterNewMeshNodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete2Request generates requests for Delete2
func NewDelete2Request(server string, id int64, params *Delete2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegisteredMeshNodeByIdRequest generates requests for GetRegisteredMeshNodeById
func NewGetRegisteredMeshNodeByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMeshNodeRequest calls the generic UpdateMeshNode builder with application/json body
func NewUpdateMeshNodeRequest(server string, id string, body UpdateMeshNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMeshNodeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateMeshNodeRequestWithBody generates requests for UpdateMeshNode with any type of body
func NewUpdateMeshNodeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSupportZipsRequest generates requests for GetSupportZips
func NewGetSupportZipsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/support-zips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupportZipRequest generates requests for GetSupportZip
func NewGetSupportZipRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/git/mesh/support-zips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, params *DeleteGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroups1Request generates requests for GetGroups1
func NewGetGroups1Request(server string, params *GetGroups1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest generates requests for CreateGroup
func NewCreateGroupRequest(server string, params *CreateGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToGroupRequest calls the generic AddUserToGroup builder with application/json body
func NewAddUserToGroupRequest(server string, body AddUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserToGroupRequestWithBody generates requests for AddUserToGroup with any type of body
func NewAddUserToGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups/add-user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUsersToGroupRequest calls the generic AddUsersToGroup builder with application/json body
func NewAddUsersToGroupRequest(server string, body AddUsersToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUsersToGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUsersToGroupRequestWithBody generates requests for AddUsersToGroup with any type of body
func NewAddUsersToGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups/add-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindUsersInGroupRequest generates requests for FindUsersInGroup
func NewFindUsersInGroupRequest(server string, params *FindUsersInGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups/more-members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, params.Context); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindUsersNotInGroupRequest generates requests for FindUsersNotInGroup
func NewFindUsersNotInGroupRequest(server string, params *FindUsersNotInGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups/more-non-members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, params.Context); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserFromGroupRequest calls the generic RemoveUserFromGroup builder with application/json body
func NewRemoveUserFromGroupRequest(server string, body RemoveUserFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserFromGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveUserFromGroupRequestWithBody generates requests for RemoveUserFromGroup with any type of body
func NewRemoveUserFromGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/groups/remove-user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGet2Request generates requests for Get2
func NewGet2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLicenseRequest calls the generic UpdateLicense builder with application/json body
func NewUpdateLicenseRequest(server string, body UpdateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateLicenseRequestWithBody generates requests for UpdateLicense with any type of body
func NewUpdateLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailConfigRequest generates requests for DeleteMailConfig
func NewDeleteMailConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailConfigRequest generates requests for GetMailConfig
func NewGetMailConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMailConfigRequest calls the generic SetMailConfig builder with application/json body
func NewSetMailConfigRequest(server string, body SetMailConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMailConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSetMailConfigRequestWithBody generates requests for SetMailConfig with any type of body
func NewSetMailConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearSenderAddressRequest generates requests for ClearSenderAddress
func NewClearSenderAddressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server/sender-address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSenderAddressRequest generates requests for GetSenderAddress
func NewGetSenderAddressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server/sender-address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSenderAddressRequest calls the generic SetSenderAddress builder with application/json body
func NewSetSenderAddressRequest(server string, body SetSenderAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSenderAddressRequestWithBody(server, "application/json", bodyReader)
}

// NewSetSenderAddressRequestWithBody generates requests for SetSenderAddress with any type of body
func NewSetSenderAddressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/mail-server/sender-address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokePermissionsForGroupRequest generates requests for RevokePermissionsForGroup
func NewRevokePermissionsForGroupRequest(server string, params *RevokePermissionsForGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithAnyPermissionRequest generates requests for GetGroupsWithAnyPermission
func NewGetGroupsWithAnyPermissionRequest(server string, params *GetGroupsWithAnyPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForGroupsRequest generates requests for SetPermissionForGroups
func NewSetPermissionForGroupsRequest(server string, params *SetPermissionForGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, params.Permission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithoutAnyPermissionRequest generates requests for GetGroupsWithoutAnyPermission
func NewGetGroupsWithoutAnyPermissionRequest(server string, params *GetGroupsWithoutAnyPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/groups/none")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsForUserRequest generates requests for RevokePermissionsForUser
func NewRevokePermissionsForUserRequest(server string, params *RevokePermissionsForUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithAnyPermissionRequest generates requests for GetUsersWithAnyPermission
func NewGetUsersWithAnyPermissionRequest(server string, params *GetUsersWithAnyPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForUsersRequest generates requests for SetPermissionForUsers
func NewSetPermissionForUsersRequest(server string, params *SetPermissionForUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, params.Permission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithoutAnyPermissionRequest generates requests for GetUsersWithoutAnyPermission
func NewGetUsersWithoutAnyPermissionRequest(server string, params *GetUsersWithoutAnyPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/permissions/users/none")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMergeConfigRequest generates requests for GetMergeConfig
func NewGetMergeConfigRequest(server string, scmId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scmId", runtime.ParamLocationPath, scmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/pull-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMergeConfigRequest calls the generic SetMergeConfig builder with application/json body
func NewSetMergeConfigRequest(server string, scmId string, body SetMergeConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMergeConfigRequestWithBody(server, scmId, "application/json", bodyReader)
}

// NewSetMergeConfigRequestWithBody generates requests for SetMergeConfig with any type of body
func NewSetMergeConfigRequestWithBody(server string, scmId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scmId", runtime.ParamLocationPath, scmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/pull-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHistoryRequest generates requests for GetHistory
func NewGetHistoryRequest(server string, params *GetHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettings2Request generates requests for GetSettings2
func NewGetSettings2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSettings2Request calls the generic SetSettings2 builder with application/json body
func NewSetSettings2Request(server string, body SetSettings2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSettings2RequestWithBody(server, "application/json", bodyReader)
}

// NewSetSettings2RequestWithBody generates requests for SetSettings2 with any type of body
func NewSetSettings2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllRateLimitSettingsRequest generates requests for GetAllRateLimitSettings
func NewGetAllRateLimitSettingsRequest(server string, params *GetAllRateLimitSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSet2Request calls the generic Set2 builder with application/json body
func NewSet2Request(server string, body Set2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSet2RequestWithBody(server, "application/json", bodyReader)
}

// NewSet2RequestWithBody generates requests for Set2 with any type of body
func NewSet2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete8Request generates requests for Delete8
func NewDelete8Request(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGet6Request generates requests for Get6
func NewGet6Request(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSet3Request calls the generic Set3 builder with application/json body
func NewSet3Request(server string, userSlug string, body Set3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSet3RequestWithBody(server, userSlug, "application/json", bodyReader)
}

// NewSet3RequestWithBody generates requests for Set3 with any type of body
func NewSet3RequestWithBody(server string, userSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/rate-limit/settings/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserDirectoriesRequest generates requests for GetUserDirectories
func NewGetUserDirectoriesRequest(server string, params *GetUserDirectoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/user-directories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeInactive", runtime.ParamLocationQuery, *params.IncludeInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, params *DeleteUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsers1Request generates requests for GetUsers1
func NewGetUsers1Request(server string, params *GetUsers1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest generates requests for CreateUser
func NewCreateUserRequest(server string, params *CreateUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emailAddress", runtime.ParamLocationQuery, params.EmailAddress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddToDefaultGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addToDefaultGroup", runtime.ParamLocationQuery, *params.AddToDefaultGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayName", runtime.ParamLocationQuery, params.DisplayName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Notify != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notify", runtime.ParamLocationQuery, *params.Notify); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserDetailsRequest calls the generic UpdateUserDetails builder with application/json body
func NewUpdateUserDetailsRequest(server string, body UpdateUserDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserDetailsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserDetailsRequestWithBody generates requests for UpdateUserDetails with any type of body
func NewUpdateUserDetailsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddGroupToUserRequest calls the generic AddGroupToUser builder with application/json body
func NewAddGroupToUserRequest(server string, body AddGroupToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGroupToUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAddGroupToUserRequestWithBody generates requests for AddGroupToUser with any type of body
func NewAddGroupToUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/add-group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserToGroupsRequest calls the generic AddUserToGroups builder with application/json body
func NewAddUserToGroupsRequest(server string, body AddUserToGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserToGroupsRequestWithBody generates requests for AddUserToGroups with any type of body
func NewAddUserToGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/add-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearUserCaptchaChallengeRequest generates requests for ClearUserCaptchaChallenge
func NewClearUserCaptchaChallengeRequest(server string, params *ClearUserCaptchaChallengeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/captcha")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserPasswordRequest calls the generic UpdateUserPassword builder with application/json body
func NewUpdateUserPasswordRequest(server string, body UpdateUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserPasswordRequestWithBody generates requests for UpdateUserPassword with any type of body
func NewUpdateUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateErasableRequest generates requests for ValidateErasable
func NewValidateErasableRequest(server string, params *ValidateErasableParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/erasure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEraseUserRequest generates requests for EraseUser
func NewEraseUserRequest(server string, params *EraseUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/erasure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGroupsForUserRequest generates requests for FindGroupsForUser
func NewFindGroupsForUserRequest(server string, params *FindGroupsForUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/more-members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, params.Context); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOtherGroupsForUserRequest generates requests for FindOtherGroupsForUser
func NewFindOtherGroupsForUserRequest(server string, params *FindOtherGroupsForUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/more-non-members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, params.Context); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveGroupFromUserRequest calls the generic RemoveGroupFromUser builder with application/json body
func NewRemoveGroupFromUserRequest(server string, body RemoveGroupFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveGroupFromUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveGroupFromUserRequestWithBody generates requests for RemoveGroupFromUser with any type of body
func NewRemoveGroupFromUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/remove-group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameUserRequest calls the generic RenameUser builder with application/json body
func NewRenameUserRequest(server string, body RenameUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRenameUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRenameUserRequestWithBody generates requests for RenameUser with any type of body
func NewRenameUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/admin/users/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApplicationPropertiesRequest generates requests for GetApplicationProperties
func NewGetApplicationPropertiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/application-properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCapabilitiesRequest generates requests for GetCapabilities
func NewGetCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/build/capabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequestSuggestionsRequest generates requests for GetPullRequestSuggestions
func NewGetPullRequestSuggestionsRequest(server string, params *GetPullRequestSuggestionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/dashboard/pull-request-suggestions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChangesSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changesSince", runtime.ParamLocationQuery, *params.ChangesSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequests1Request generates requests for GetPullRequests1
func NewGetPullRequests1Request(server string, params *GetPullRequests1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/dashboard/pull-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClosedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "closedSince", runtime.ParamLocationQuery, *params.ClosedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParticipantStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participantStatus", runtime.ParamLocationQuery, *params.ParticipantStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCapabilities1Request generates requests for GetCapabilities1
func NewGetCapabilities1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/deployment/capabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHookScriptRequestWithBody generates requests for CreateHookScript with any type of body
func NewCreateHookScriptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hook-scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHookScriptRequest generates requests for DeleteHookScript
func NewDeleteHookScriptRequest(server string, scriptId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hook-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHookScriptRequest generates requests for GetHookScript
func NewGetHookScriptRequest(server string, scriptId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hook-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateHookScriptRequestWithBody generates requests for UpdateHookScript with any type of body
func NewUpdateHookScriptRequestWithBody(server string, scriptId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hook-scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadRequest generates requests for Read
func NewReadRequest(server string, scriptId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hook-scripts/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvatarRequest generates requests for GetAvatar
func NewGetAvatarRequest(server string, hookKey string, params *GetAvatarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/hooks/%s/avatar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequests2Request generates requests for GetPullRequests2
func NewGetPullRequests2Request(server string, params *GetPullRequests2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/inbox/pull-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequestCountRequest generates requests for GetPullRequestCount
func NewGetPullRequestCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/inbox/pull-requests/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelsRequest generates requests for GetLabels
func NewGetLabelsRequest(server string, params *GetLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelRequest generates requests for GetLabel
func NewGetLabelRequest(server string, labelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "labelName", runtime.ParamLocationPath, labelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/labels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLabelablesRequest generates requests for GetLabelables
func NewGetLabelablesRequest(server string, labelName string, params *GetLabelablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "labelName", runtime.ParamLocationPath, labelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/labels/%s/labeled", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLevelRequest generates requests for GetLevel
func NewGetLevelRequest(server string, loggerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loggerName", runtime.ParamLocationPath, loggerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/logs/logger/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetLevelRequest generates requests for SetLevel
func NewSetLevelRequest(server string, loggerName string, levelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loggerName", runtime.ParamLocationPath, loggerName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "levelName", runtime.ParamLocationPath, levelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/logs/logger/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRootLevelRequest generates requests for GetRootLevel
func NewGetRootLevelRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/logs/rootLogger")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRootLevelRequest generates requests for SetRootLevel
func NewSetRootLevelRequest(server string, levelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "levelName", runtime.ParamLocationPath, levelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/logs/rootLogger/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewRequestWithBody generates requests for Preview with any type of body
func NewPreviewRequestWithBody(server string, params *PreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/markup/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HtmlEscape != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "htmlEscape", runtime.ParamLocationQuery, *params.HtmlEscape); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UrlMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urlMode", runtime.ParamLocationQuery, *params.UrlMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeadingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHeadingId", runtime.ParamLocationQuery, *params.IncludeHeadingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hardwrap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hardwrap", runtime.ParamLocationQuery, *params.Hardwrap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartExportRequest calls the generic StartExport builder with application/json body
func NewStartExportRequest(server string, body StartExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartExportRequestWithBody(server, "application/json", bodyReader)
}

// NewStartExportRequestWithBody generates requests for StartExport with any type of body
func NewStartExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewExportRequest calls the generic PreviewExport builder with application/json body
func NewPreviewExportRequest(server string, body PreviewExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewExportRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewExportRequestWithBody generates requests for PreviewExport with any type of body
func NewPreviewExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/exports/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExportJobRequest generates requests for GetExportJob
func NewGetExportJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelExportJobRequest generates requests for CancelExportJob
func NewCancelExportJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/exports/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExportJobMessagesRequest generates requests for GetExportJobMessages
func NewGetExportJobMessagesRequest(server string, jobId string, params *GetExportJobMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/exports/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartImportRequest calls the generic StartImport builder with application/json body
func NewStartImportRequest(server string, body StartImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartImportRequestWithBody(server, "application/json", bodyReader)
}

// NewStartImportRequestWithBody generates requests for StartImport with any type of body
func NewStartImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/imports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportJobRequest generates requests for GetImportJob
func NewGetImportJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/imports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelImportJobRequest generates requests for CancelImportJob
func NewCancelImportJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/imports/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImportJobMessagesRequest generates requests for GetImportJobMessages
func NewGetImportJobMessagesRequest(server string, jobId string, params *GetImportJobMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/imports/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartMeshMigrationRequest calls the generic StartMeshMigration builder with application/json body
func NewStartMeshMigrationRequest(server string, body StartMeshMigrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartMeshMigrationRequestWithBody(server, "application/json", bodyReader)
}

// NewStartMeshMigrationRequestWithBody generates requests for StartMeshMigration with any type of body
func NewStartMeshMigrationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewMeshMigrationRequest calls the generic PreviewMeshMigration builder with application/json body
func NewPreviewMeshMigrationRequest(server string, body PreviewMeshMigrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewMeshMigrationRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewMeshMigrationRequestWithBody generates requests for PreviewMeshMigration with any type of body
func NewPreviewMeshMigrationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchMeshMigrationReposRequest generates requests for SearchMeshMigrationRepos
func NewSearchMeshMigrationReposRequest(server string, params *SearchMeshMigrationReposParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MigrationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migrationId", runtime.ParamLocationQuery, *params.MigrationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectKey", runtime.ParamLocationQuery, *params.ProjectKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote", runtime.ParamLocationQuery, *params.Remote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllMeshMigrationSummariesRequest generates requests for GetAllMeshMigrationSummaries
func NewGetAllMeshMigrationSummariesRequest(server string, params *GetAllMeshMigrationSummariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveMeshMigrationSummaryRequest generates requests for GetActiveMeshMigrationSummary
func NewGetActiveMeshMigrationSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeshMigrationJobRequest generates requests for GetMeshMigrationJob
func NewGetMeshMigrationJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelMeshMigrationJobRequest generates requests for CancelMeshMigrationJob
func NewCancelMeshMigrationJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeshMigrationJobMessagesRequest generates requests for GetMeshMigrationJobMessages
func NewGetMeshMigrationJobMessagesRequest(server string, jobId string, params *GetMeshMigrationJobMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subject != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject", runtime.ParamLocationQuery, *params.Subject); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeshMigrationJobSummaryRequest generates requests for GetMeshMigrationJobSummary
func NewGetMeshMigrationJobSummaryRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/migration/mesh/%s/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesRecentlyAccessedRequest generates requests for GetRepositoriesRecentlyAccessed
func NewGetRepositoriesRecentlyAccessedRequest(server string, params *GetRepositoriesRecentlyAccessedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/profile/recent/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsRequest generates requests for GetProjects
func NewGetProjectsRequest(server string, params *GetProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectKey string, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectAvatarRequest generates requests for GetProjectAvatar
func NewGetProjectAvatarRequest(server string, projectKey string, params *GetProjectAvatarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/avatar.png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.S != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s", runtime.ParamLocationQuery, *params.S); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadAvatarRequestWithBody generates requests for UploadAvatar with any type of body
func NewUploadAvatarRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/avatar.png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationsRequest generates requests for GetConfigurations
func NewGetConfigurationsRequest(server string, projectKey string, params *GetConfigurationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/hook-scripts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveConfigurationRequest generates requests for RemoveConfiguration
func NewRemoveConfigurationRequest(server string, projectKey string, scriptId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/hook-scripts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetConfigurationRequest calls the generic SetConfiguration builder with application/json body
func NewSetConfigurationRequest(server string, projectKey string, scriptId string, body SetConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetConfigurationRequestWithBody(server, projectKey, scriptId, "application/json", bodyReader)
}

// NewSetConfigurationRequestWithBody generates requests for SetConfiguration with any type of body
func NewSetConfigurationRequestWithBody(server string, projectKey string, scriptId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/hook-scripts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokePermissionsRequest generates requests for RevokePermissions
func NewRevokePermissionsRequest(server string, projectKey string, params *RevokePermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsForGroup1Request generates requests for RevokePermissionsForGroup1
func NewRevokePermissionsForGroup1Request(server string, projectKey string, params *RevokePermissionsForGroup1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithAnyPermission1Request generates requests for GetGroupsWithAnyPermission1
func NewGetGroupsWithAnyPermission1Request(server string, projectKey string, params *GetGroupsWithAnyPermission1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForGroups1Request generates requests for SetPermissionForGroups1
func NewSetPermissionForGroups1Request(server string, projectKey string, params *SetPermissionForGroups1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithoutAnyPermission1Request generates requests for GetGroupsWithoutAnyPermission1
func NewGetGroupsWithoutAnyPermission1Request(server string, projectKey string, params *GetGroupsWithoutAnyPermission1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/groups/none", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPermissionsRequest generates requests for SearchPermissions
func NewSearchPermissionsRequest(server string, projectKey string, params *SearchPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsForUser1Request generates requests for RevokePermissionsForUser1
func NewRevokePermissionsForUser1Request(server string, projectKey string, params *RevokePermissionsForUser1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithAnyPermission1Request generates requests for GetUsersWithAnyPermission1
func NewGetUsersWithAnyPermission1Request(server string, projectKey string, params *GetUsersWithAnyPermission1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForUsers1Request generates requests for SetPermissionForUsers1
func NewSetPermissionForUsers1Request(server string, projectKey string, params *SetPermissionForUsers1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithoutPermissionRequest generates requests for GetUsersWithoutPermission
func NewGetUsersWithoutPermissionRequest(server string, projectKey string, params *GetUsersWithoutPermissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/users/none", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHasAllUserPermissionRequest generates requests for HasAllUserPermission
func NewHasAllUserPermissionRequest(server string, projectKey string, permission string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permission", runtime.ParamLocationPath, permission)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/%s/all", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyAllUserPermissionRequest generates requests for ModifyAllUserPermission
func NewModifyAllUserPermissionRequest(server string, projectKey string, permission string, params *ModifyAllUserPermissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permission", runtime.ParamLocationPath, permission)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/permissions/%s/all", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Allow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow", runtime.ParamLocationQuery, *params.Allow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesRequest generates requests for GetRepositories
func NewGetRepositoriesRequest(server string, projectKey string, params *GetRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, projectKey string, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewForkRepositoryRequest calls the generic ForkRepository builder with application/json body
func NewForkRepositoryRequest(server string, projectKey string, repositorySlug string, body ForkRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForkRepositoryRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewForkRepositoryRequestWithBody generates requests for ForkRepository with any type of body
func NewForkRepositoryRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRepositoryRequest calls the generic UpdateRepository builder with application/json body
func NewUpdateRepositoryRequest(server string, projectKey string, repositorySlug string, body UpdateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRepositoryRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewUpdateRepositoryRequestWithBody generates requests for UpdateRepository with any type of body
func NewUpdateRepositoryRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArchiveRequest generates requests for GetArchive
func NewGetArchiveRequest(server string, projectKey string, repositorySlug string, params *GetArchiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/archive", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAttachmentRequest generates requests for DeleteAttachment
func NewDeleteAttachmentRequest(server string, projectKey string, repositorySlug string, attachmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/attachments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentRequest generates requests for GetAttachment
func NewGetAttachmentRequest(server string, projectKey string, repositorySlug string, attachmentId string, params *GetAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/attachments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.UserAgent != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "User-Agent", runtime.ParamLocationHeader, *params.UserAgent)
			if err != nil {
				return nil, err
			}

			req.Header.Set("User-Agent", headerParam0)
		}

		if params.Range != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Range", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteAttachmentMetadataRequest generates requests for DeleteAttachmentMetadata
func NewDeleteAttachmentMetadataRequest(server string, projectKey string, repositorySlug string, attachmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/attachments/%s/metadata", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentMetadataRequest generates requests for GetAttachmentMetadata
func NewGetAttachmentMetadataRequest(server string, projectKey string, repositorySlug string, attachmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/attachments/%s/metadata", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveAttachmentMetadataRequest calls the generic SaveAttachmentMetadata builder with application/json body
func NewSaveAttachmentMetadataRequest(server string, projectKey string, repositorySlug string, attachmentId string, body SaveAttachmentMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveAttachmentMetadataRequestWithBody(server, projectKey, repositorySlug, attachmentId, "application/json", bodyReader)
}

// NewSaveAttachmentMetadataRequestWithBody generates requests for SaveAttachmentMetadata with any type of body
func NewSaveAttachmentMetadataRequestWithBody(server string, projectKey string, repositorySlug string, attachmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/attachments/%s/metadata", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBranchesRequest generates requests for GetBranches
func NewGetBranchesRequest(server string, projectKey string, repositorySlug string, params *GetBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BoostMatches != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boostMatches", runtime.ParamLocationQuery, *params.BoostMatches); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Details != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Base != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchForRepositoryRequest calls the generic CreateBranchForRepository builder with application/json body
func NewCreateBranchForRepositoryRequest(server string, projectKey string, repositorySlug string, body CreateBranchForRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchForRepositoryRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateBranchForRepositoryRequestWithBody generates requests for CreateBranchForRepository with any type of body
func NewCreateBranchForRepositoryRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultBranch1Request generates requests for GetDefaultBranch1
func NewGetDefaultBranch1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/branches/default", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultBranch1Request calls the generic SetDefaultBranch1 builder with application/json body
func NewSetDefaultBranch1Request(server string, projectKey string, repositorySlug string, body SetDefaultBranch1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultBranch1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSetDefaultBranch1RequestWithBody generates requests for SetDefaultBranch1 with any type of body
func NewSetDefaultBranch1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/branches/default", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContentRequest generates requests for GetContent
func NewGetContentRequest(server string, projectKey string, repositorySlug string, params *GetContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/browse", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NoContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noContent", runtime.ParamLocationQuery, *params.NoContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blame != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blame", runtime.ParamLocationQuery, *params.Blame); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContent1Request generates requests for GetContent1
func NewGetContent1Request(server string, projectKey string, repositorySlug string, path string, params *GetContent1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/browse/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NoContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noContent", runtime.ParamLocationQuery, *params.NoContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blame != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blame", runtime.ParamLocationQuery, *params.Blame); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditFileRequestWithBody generates requests for EditFile with any type of body
func NewEditFileRequestWithBody(server string, projectKey string, repositorySlug string, path string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/browse/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChanges1Request generates requests for GetChanges1
func NewGetChanges1Request(server string, projectKey string, repositorySlug string, params *GetChanges1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/changes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommitsRequest generates requests for GetCommits
func NewGetCommitsRequest(server string, projectKey string, repositorySlug string, params *GetCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvatarScheme != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarScheme", runtime.ParamLocationQuery, *params.AvatarScheme); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withCounts", runtime.ParamLocationQuery, *params.WithCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FollowRenames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "followRenames", runtime.ParamLocationQuery, *params.FollowRenames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarSize", runtime.ParamLocationQuery, *params.AvatarSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merges", runtime.ParamLocationQuery, *params.Merges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMissing", runtime.ParamLocationQuery, *params.IgnoreMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommitRequest generates requests for GetCommit
func NewGetCommitRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetCommitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(server string, projectKey string, repositorySlug string, commitId string, params *DeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/builds", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/builds", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRequestWithBody generates requests for Add with any type of body
func NewAddRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/builds", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChangesRequest generates requests for GetChanges
func NewGetChangesRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/changes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithComments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withComments", runtime.ParamLocationQuery, *params.WithComments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentsRequest generates requests for GetComments
func NewGetCommentsRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommentRequest calls the generic CreateComment builder with application/json body
func NewCreateCommentRequest(server string, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, body CreateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommentRequestWithBody(server, projectKey, repositorySlug, commitId, params, "application/json", bodyReader)
}

// NewCreateCommentRequestWithBody generates requests for CreateComment with any type of body
func NewCreateCommentRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommentRequest generates requests for DeleteComment
func NewDeleteCommentRequest(server string, projectKey string, repositorySlug string, commitId string, commentId string, params *DeleteCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentRequest generates requests for GetComment
func NewGetCommentRequest(server string, projectKey string, repositorySlug string, commitId string, commentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommentRequest calls the generic UpdateComment builder with application/json body
func NewUpdateCommentRequest(server string, projectKey string, repositorySlug string, commitId string, commentId string, body UpdateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommentRequestWithBody(server, projectKey, repositorySlug, commitId, commentId, "application/json", bodyReader)
}

// NewUpdateCommentRequestWithBody generates requests for UpdateComment with any type of body
func NewUpdateCommentRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete1Request generates requests for Delete1
func NewDelete1Request(server string, projectKey string, repositorySlug string, commitId string, params *Delete1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/deployments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeploymentSequenceNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentSequenceNumber", runtime.ParamLocationQuery, *params.DeploymentSequenceNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environmentKey", runtime.ParamLocationQuery, *params.EnvironmentKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGet1Request generates requests for Get1
func NewGet1Request(server string, projectKey string, repositorySlug string, commitId string, params *Get1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/deployments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeploymentSequenceNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deploymentSequenceNumber", runtime.ParamLocationQuery, *params.DeploymentSequenceNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environmentKey", runtime.ParamLocationQuery, *params.EnvironmentKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateDeploymentRequestWithBody generates requests for CreateOrUpdateDeployment with any type of body
func NewCreateOrUpdateDeploymentRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/deployments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDiffStatsSummaryRequest generates requests for GetDiffStatsSummary
func NewGetDiffStatsSummaryRequest(server string, projectKey string, repositorySlug string, commitId string, path string, params *GetDiffStatsSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/diff-stats-summary/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutoSrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoSrcPath", runtime.ParamLocationQuery, *params.AutoSrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamDiffRequest generates requests for StreamDiff
func NewStreamDiffRequest(server string, projectKey string, repositorySlug string, commitId string, path string, params *StreamDiffParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/diff/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarSize", runtime.ParamLocationQuery, *params.AvatarSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarScheme != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarScheme", runtime.ParamLocationQuery, *params.AvatarScheme); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutoSrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoSrcPath", runtime.ParamLocationQuery, *params.AutoSrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithComments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withComments", runtime.ParamLocationQuery, *params.WithComments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMergeBaseRequest generates requests for GetMergeBase
func NewGetMergeBaseRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetMergeBaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/merge-base", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OtherCommitId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "otherCommitId", runtime.ParamLocationQuery, *params.OtherCommitId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequestsRequest generates requests for GetPullRequests
func NewGetPullRequestsRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetPullRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/pull-requests", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnwatchRequest generates requests for Unwatch
func NewUnwatchRequest(server string, projectKey string, repositorySlug string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/watch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatchRequest generates requests for Watch
func NewWatchRequest(server string, projectKey string, repositorySlug string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/commits/%s/watch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamChangesRequest generates requests for StreamChanges
func NewStreamChangesRequest(server string, projectKey string, repositorySlug string, params *StreamChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/compare/changes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromRepo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromRepo", runtime.ParamLocationQuery, *params.FromRepo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamCommitsRequest generates requests for StreamCommits
func NewStreamCommitsRequest(server string, projectKey string, repositorySlug string, params *StreamCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/compare/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromRepo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromRepo", runtime.ParamLocationQuery, *params.FromRepo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiffStatsSummary1Request generates requests for GetDiffStatsSummary1
func NewGetDiffStatsSummary1Request(server string, projectKey string, repositorySlug string, path string, params *GetDiffStatsSummary1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/compare/diff-stats-summary%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromRepo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromRepo", runtime.ParamLocationQuery, *params.FromRepo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamDiff1Request generates requests for StreamDiff1
func NewStreamDiff1Request(server string, projectKey string, repositorySlug string, path string, params *StreamDiff1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/compare/diff%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromRepo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromRepo", runtime.ParamLocationQuery, *params.FromRepo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamContributingRequest generates requests for StreamContributing
func NewStreamContributingRequest(server string, projectKey string, repositorySlug string, params *StreamContributingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/contributing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HtmlEscape != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "htmlEscape", runtime.ParamLocationQuery, *params.HtmlEscape); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeadingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHeadingId", runtime.ParamLocationQuery, *params.IncludeHeadingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hardwrap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hardwrap", runtime.ParamLocationQuery, *params.Hardwrap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultBranch2Request generates requests for GetDefaultBranch2
func NewGetDefaultBranch2Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/default-branch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultBranch2Request calls the generic SetDefaultBranch2 builder with application/json body
func NewSetDefaultBranch2Request(server string, projectKey string, repositorySlug string, body SetDefaultBranch2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultBranch2RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSetDefaultBranch2RequestWithBody generates requests for SetDefaultBranch2 with any type of body
func NewSetDefaultBranch2RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/default-branch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamRawDiffRequest generates requests for StreamRawDiff
func NewStreamRawDiffRequest(server string, projectKey string, repositorySlug string, params *StreamRawDiffParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRawDiff1Request generates requests for StreamRawDiff1
func NewStreamRawDiff1Request(server string, projectKey string, repositorySlug string, path string, params *StreamRawDiff1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/diff/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamFilesRequest generates requests for StreamFiles
func NewStreamFilesRequest(server string, projectKey string, repositorySlug string, params *StreamFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/files", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamFiles1Request generates requests for StreamFiles1
func NewStreamFiles1Request(server string, projectKey string, repositorySlug string, path string, params *StreamFiles1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/files/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForkedRepositoriesRequest generates requests for GetForkedRepositories
func NewGetForkedRepositoriesRequest(server string, projectKey string, repositorySlug string, params *GetForkedRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/forks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurations1Request generates requests for GetConfigurations1
func NewGetConfigurations1Request(server string, projectKey string, repositorySlug string, params *GetConfigurations1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/hook-scripts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveConfiguration1Request generates requests for RemoveConfiguration1
func NewRemoveConfiguration1Request(server string, projectKey string, repositorySlug string, scriptId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/hook-scripts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetConfiguration1Request calls the generic SetConfiguration1 builder with application/json body
func NewSetConfiguration1Request(server string, projectKey string, repositorySlug string, scriptId string, body SetConfiguration1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetConfiguration1RequestWithBody(server, projectKey, repositorySlug, scriptId, "application/json", bodyReader)
}

// NewSetConfiguration1RequestWithBody generates requests for SetConfiguration1 with any type of body
func NewSetConfiguration1RequestWithBody(server string, projectKey string, repositorySlug string, scriptId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "scriptId", runtime.ParamLocationPath, scriptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/hook-scripts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLabelsForRepositoryRequest generates requests for GetAllLabelsForRepository
func NewGetAllLabelsForRepositoryRequest(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLabelRequest calls the generic AddLabel builder with application/json body
func NewAddLabelRequest(server string, projectKey string, repositorySlug string, body AddLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLabelRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewAddLabelRequestWithBody generates requests for AddLabel with any type of body
func NewAddLabelRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveLabelRequest generates requests for RemoveLabel
func NewRemoveLabelRequest(server string, projectKey string, repositorySlug string, labelName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "labelName", runtime.ParamLocationPath, labelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRequest generates requests for Stream
func NewStreamRequest(server string, projectKey string, repositorySlug string, params *StreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/last-modified", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStream1Request generates requests for Stream1
func NewStream1Request(server string, projectKey string, repositorySlug string, path string, params *Stream1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/last-modified/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamLicenseRequest generates requests for StreamLicense
func NewStreamLicenseRequest(server string, projectKey string, repositorySlug string, params *StreamLicenseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/license", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HtmlEscape != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "htmlEscape", runtime.ParamLocationQuery, *params.HtmlEscape); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeadingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHeadingId", runtime.ParamLocationQuery, *params.IncludeHeadingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hardwrap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hardwrap", runtime.ParamLocationQuery, *params.Hardwrap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, projectKey string, repositorySlug string, params *SearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/participants", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamPatchRequest generates requests for StreamPatch
func NewStreamPatchRequest(server string, projectKey string, repositorySlug string, params *StreamPatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/patch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllAncestors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allAncestors", runtime.ParamLocationQuery, *params.AllAncestors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissions1Request generates requests for RevokePermissions1
func NewRevokePermissions1Request(server string, projectKey string, repositorySlug string, params *RevokePermissions1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsForGroup2Request generates requests for RevokePermissionsForGroup2
func NewRevokePermissionsForGroup2Request(server string, projectKey string, repositorySlug string, params *RevokePermissionsForGroup2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithAnyPermission2Request generates requests for GetGroupsWithAnyPermission2
func NewGetGroupsWithAnyPermission2Request(server string, projectKey string, repositorySlug string, params *GetGroupsWithAnyPermission2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForGroupRequest generates requests for SetPermissionForGroup
func NewSetPermissionForGroupRequest(server string, projectKey string, repositorySlug string, params *SetPermissionForGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, params.Permission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsWithoutAnyPermission2Request generates requests for GetGroupsWithoutAnyPermission2
func NewGetGroupsWithoutAnyPermission2Request(server string, projectKey string, repositorySlug string, params *GetGroupsWithoutAnyPermission2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/groups/none", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPermissions1Request generates requests for SearchPermissions1
func NewSearchPermissions1Request(server string, projectKey string, repositorySlug string, params *SearchPermissions1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsForUser2Request generates requests for RevokePermissionsForUser2
func NewRevokePermissionsForUser2Request(server string, projectKey string, repositorySlug string, params *RevokePermissionsForUser2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/users", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithAnyPermission2Request generates requests for GetUsersWithAnyPermission2
func NewGetUsersWithAnyPermission2Request(server string, projectKey string, repositorySlug string, params *GetUsersWithAnyPermission2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/users", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPermissionForUserRequest generates requests for SetPermissionForUser
func NewSetPermissionForUserRequest(server string, projectKey string, repositorySlug string, params *SetPermissionForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/users", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, params.Permission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersWithoutPermission1Request generates requests for GetUsersWithoutPermission1
func NewGetUsersWithoutPermission1Request(server string, projectKey string, repositorySlug string, params *GetUsersWithoutPermission1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/permissions/users/none", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageRequest generates requests for GetPage
func NewGetPageRequest(server string, projectKey string, repositorySlug string, params *GetPageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAttributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAttributes", runtime.ParamLocationQuery, *params.WithAttributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithProperties != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withProperties", runtime.ParamLocationQuery, *params.WithProperties); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Draft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "draft", runtime.ParamLocationQuery, *params.Draft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, projectKey string, repositorySlug string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete3Request calls the generic Delete3 builder with application/json body
func NewDelete3Request(server string, projectKey string, repositorySlug string, pullRequestId string, body Delete3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDelete3RequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewDelete3RequestWithBody generates requests for Delete3 with any type of body
func NewDelete3RequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGet3Request generates requests for Get3
func NewGet3Request(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(server string, projectKey string, repositorySlug string, pullRequestId string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamRawDiff2Request generates requests for StreamRawDiff2
func NewStreamRawDiff2Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *StreamRawDiff2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s.diff", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamPatch1Request generates requests for StreamPatch1
func NewStreamPatch1Request(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s.patch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivitiesRequest generates requests for GetActivities
func NewGetActivitiesRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *GetActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/activities", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromType", runtime.ParamLocationQuery, *params.FromType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromId", runtime.ParamLocationQuery, *params.FromId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWithdrawApprovalRequest generates requests for WithdrawApproval
func NewWithdrawApprovalRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/approve", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveRequest generates requests for Approve
func NewApproveRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/approve", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelAutoMergeRequest generates requests for CancelAutoMerge
func NewCancelAutoMergeRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/auto-merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoMergeRequestRequest generates requests for GetAutoMergeRequest
func NewGetAutoMergeRequestRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/auto-merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTryAutoMergeRequest generates requests for TryAutoMerge
func NewTryAutoMergeRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/auto-merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComments1Request generates requests for GetComments1
func NewGetComments1Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *GetComments1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/blocker-comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComment1Request calls the generic CreateComment1 builder with application/json body
func NewCreateComment1Request(server string, projectKey string, repositorySlug string, pullRequestId string, body CreateComment1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComment1RequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewCreateComment1RequestWithBody generates requests for CreateComment1 with any type of body
func NewCreateComment1RequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/blocker-comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComment1Request generates requests for DeleteComment1
func NewDeleteComment1Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/blocker-comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComment1Request generates requests for GetComment1
func NewGetComment1Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/blocker-comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComment1Request calls the generic UpdateComment1 builder with application/json body
func NewUpdateComment1Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComment1RequestWithBody(server, projectKey, repositorySlug, pullRequestId, commentId, "application/json", bodyReader)
}

// NewUpdateComment1RequestWithBody generates requests for UpdateComment1 with any type of body
func NewUpdateComment1RequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/blocker-comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamChanges1Request generates requests for StreamChanges1
func NewStreamChanges1Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *StreamChanges1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/changes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinceId", runtime.ParamLocationQuery, *params.SinceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChangeScope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changeScope", runtime.ParamLocationQuery, *params.ChangeScope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UntilId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "untilId", runtime.ParamLocationQuery, *params.UntilId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithComments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withComments", runtime.ParamLocationQuery, *params.WithComments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComments2Request generates requests for GetComments2
func NewGetComments2Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *GetComments2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FromHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromHash", runtime.ParamLocationQuery, *params.FromHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnchorState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anchorState", runtime.ParamLocationQuery, *params.AnchorState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffType", runtime.ParamLocationQuery, *params.DiffType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toHash", runtime.ParamLocationQuery, *params.ToHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffTypes", runtime.ParamLocationQuery, *params.DiffTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComment2Request calls the generic CreateComment2 builder with application/json body
func NewCreateComment2Request(server string, projectKey string, repositorySlug string, pullRequestId string, body CreateComment2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComment2RequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewCreateComment2RequestWithBody generates requests for CreateComment2 with any type of body
func NewCreateComment2RequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComment2Request generates requests for DeleteComment2
func NewDeleteComment2Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComment2Request generates requests for GetComment2
func NewGetComment2Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComment2Request calls the generic UpdateComment2 builder with application/json body
func NewUpdateComment2Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComment2RequestWithBody(server, projectKey, repositorySlug, pullRequestId, commentId, "application/json", bodyReader)
}

// NewUpdateComment2RequestWithBody generates requests for UpdateComment2 with any type of body
func NewUpdateComment2RequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApplySuggestionRequest calls the generic ApplySuggestion builder with application/json body
func NewApplySuggestionRequest(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, body ApplySuggestionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplySuggestionRequestWithBody(server, projectKey, repositorySlug, pullRequestId, commentId, "application/json", bodyReader)
}

// NewApplySuggestionRequestWithBody generates requests for ApplySuggestion with any type of body
func NewApplySuggestionRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s/apply-suggestion", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitMessageSuggestionRequest generates requests for GetCommitMessageSuggestion
func NewGetCommitMessageSuggestionRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/commit-message-suggestion", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommits1Request generates requests for GetCommits1
func NewGetCommits1Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *GetCommits1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/commits", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvatarScheme != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarScheme", runtime.ParamLocationQuery, *params.AvatarScheme); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withCounts", runtime.ParamLocationQuery, *params.WithCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarSize", runtime.ParamLocationQuery, *params.AvatarSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeclineRequest calls the generic Decline builder with application/json body
func NewDeclineRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, body DeclineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeclineRequestWithBody(server, projectKey, repositorySlug, pullRequestId, params, "application/json", bodyReader)
}

// NewDeclineRequestWithBody generates requests for Decline with any type of body
func NewDeclineRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/decline", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDiffStatsSummary2Request generates requests for GetDiffStatsSummary2
func NewGetDiffStatsSummary2Request(server string, projectKey string, repositorySlug string, pullRequestId string, path string, params *GetDiffStatsSummary2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/diff-stats-summary/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinceId", runtime.ParamLocationQuery, *params.SinceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UntilId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "untilId", runtime.ParamLocationQuery, *params.UntilId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamDiff2Request generates requests for StreamDiff2
func NewStreamDiff2Request(server string, projectKey string, repositorySlug string, pullRequestId string, path string, params *StreamDiff2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/diff/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvatarScheme != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarScheme", runtime.ParamLocationQuery, *params.AvatarScheme); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contextLines", runtime.ParamLocationQuery, *params.ContextLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SinceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinceId", runtime.ParamLocationQuery, *params.SinceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SrcPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "srcPath", runtime.ParamLocationQuery, *params.SrcPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffType", runtime.ParamLocationQuery, *params.DiffType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UntilId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "untilId", runtime.ParamLocationQuery, *params.UntilId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Whitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "whitespace", runtime.ParamLocationQuery, *params.Whitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithComments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withComments", runtime.ParamLocationQuery, *params.WithComments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvatarSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avatarSize", runtime.ParamLocationQuery, *params.AvatarSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCanMergeRequest generates requests for CanMerge
func NewCanMergeRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeRequest calls the generic Merge builder with application/json body
func NewMergeRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, body MergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeRequestWithBody(server, projectKey, repositorySlug, pullRequestId, params, "application/json", bodyReader)
}

// NewMergeRequestWithBody generates requests for Merge with any type of body
func NewMergeRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMergeBase1Request generates requests for GetMergeBase1
func NewGetMergeBase1Request(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/merge-base", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnassignParticipantRole1Request generates requests for UnassignParticipantRole1
func NewUnassignParticipantRole1Request(server string, projectKey string, repositorySlug string, pullRequestId string, params *UnassignParticipantRole1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/participants", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListParticipantsRequest generates requests for ListParticipants
func NewListParticipantsRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *ListParticipantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/participants", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignParticipantRoleRequest calls the generic AssignParticipantRole builder with application/json body
func NewAssignParticipantRoleRequest(server string, projectKey string, repositorySlug string, pullRequestId string, body AssignParticipantRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignParticipantRoleRequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewAssignParticipantRoleRequestWithBody generates requests for AssignParticipantRole with any type of body
func NewAssignParticipantRoleRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/participants", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignParticipantRoleRequest generates requests for UnassignParticipantRole
func NewUnassignParticipantRoleRequest(server string, projectKey string, repositorySlug string, pullRequestId string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/participants/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStatusRequest calls the generic UpdateStatus builder with application/json body
func NewUpdateStatusRequest(server string, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStatusRequestWithBody(server, projectKey, repositorySlug, pullRequestId, userSlug, params, "application/json", bodyReader)
}

// NewUpdateStatusRequestWithBody generates requests for UpdateStatus with any type of body
func NewUpdateStatusRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/participants/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReopenRequest calls the generic Reopen builder with application/json body
func NewReopenRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, body ReopenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReopenRequestWithBody(server, projectKey, repositorySlug, pullRequestId, params, "application/json", bodyReader)
}

// NewReopenRequestWithBody generates requests for Reopen with any type of body
func NewReopenRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/reopen", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDiscardReviewRequest generates requests for DiscardReview
func NewDiscardReviewRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/review", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReviewRequest generates requests for GetReview
func NewGetReviewRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *GetReviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/review", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFinishReviewRequest calls the generic FinishReview builder with application/json body
func NewFinishReviewRequest(server string, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, body FinishReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFinishReviewRequestWithBody(server, projectKey, repositorySlug, pullRequestId, params, "application/json", bodyReader)
}

// NewFinishReviewRequestWithBody generates requests for FinishReview with any type of body
func NewFinishReviewRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/review", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnwatch1Request generates requests for Unwatch1
func NewUnwatch1Request(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/watch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatch1Request generates requests for Watch1
func NewWatch1Request(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/pull-requests/%s/watch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRawRequest generates requests for StreamRaw
func NewStreamRawRequest(server string, projectKey string, repositorySlug string, path string, params *StreamRawParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/raw/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HtmlEscape != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "htmlEscape", runtime.ParamLocationQuery, *params.HtmlEscape); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeadingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHeadingId", runtime.ParamLocationQuery, *params.IncludeHeadingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hardwrap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hardwrap", runtime.ParamLocationQuery, *params.Hardwrap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamReadmeRequest generates requests for StreamReadme
func NewStreamReadmeRequest(server string, projectKey string, repositorySlug string, params *StreamReadmeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/readme", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HtmlEscape != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "htmlEscape", runtime.ParamLocationQuery, *params.HtmlEscape); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHeadingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHeadingId", runtime.ParamLocationQuery, *params.IncludeHeadingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hardwrap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hardwrap", runtime.ParamLocationQuery, *params.Hardwrap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryCreateRepositoryRequest generates requests for RetryCreateRepository
func NewRetryCreateRepositoryRequest(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/recreate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRefChangeActivityRequest generates requests for GetRefChangeActivity
func NewGetRefChangeActivityRequest(server string, projectKey string, repositorySlug string, params *GetRefChangeActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/ref-change-activities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindBranchesRequest generates requests for FindBranches
func NewFindBranchesRequest(server string, projectKey string, repositorySlug string, params *FindBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/ref-change-activities/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRelatedRepositoriesRequest generates requests for GetRelatedRepositories
func NewGetRelatedRepositoriesRequest(server string, projectKey string, repositorySlug string, params *GetRelatedRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/related", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearch2Request generates requests for Search2
func NewSearch2Request(server string, projectKey string, repositorySlug string, params *Search2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/allowlist", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAllowlistRule1RequestWithBody generates requests for CreateAllowlistRule1 with any type of body
func NewCreateAllowlistRule1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/allowlist", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllowlistRule1Request generates requests for DeleteAllowlistRule1
func NewDeleteAllowlistRule1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllowlistRule1Request generates requests for GetAllowlistRule1
func NewGetAllowlistRule1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditAllowlistRule1RequestWithBody generates requests for EditAllowlistRule1 with any type of body
func NewEditAllowlistRule1RequestWithBody(server string, projectKey string, repositorySlug string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearch3Request generates requests for Search3
func NewSearch3Request(server string, projectKey string, repositorySlug string, params *Search3Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRule1RequestWithBody generates requests for CreateRule1 with any type of body
func NewCreateRule1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRule1Request generates requests for DeleteRule1
func NewDeleteRule1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/rules/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRule1Request generates requests for GetRule1
func NewGetRule1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/rules/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditRule1RequestWithBody generates requests for EditRule1 with any type of body
func NewEditRule1RequestWithBody(server string, projectKey string, repositorySlug string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/secret-scanning/rules/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAutoDeclineSettings1Request generates requests for DeleteAutoDeclineSettings1
func NewDeleteAutoDeclineSettings1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-decline", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoDeclineSettings1Request generates requests for GetAutoDeclineSettings1
func NewGetAutoDeclineSettings1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-decline", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoDeclineSettings1Request calls the generic SetAutoDeclineSettings1 builder with application/json body
func NewSetAutoDeclineSettings1Request(server string, projectKey string, repositorySlug string, body SetAutoDeclineSettings1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoDeclineSettings1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSetAutoDeclineSettings1RequestWithBody generates requests for SetAutoDeclineSettings1 with any type of body
func NewSetAutoDeclineSettings1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-decline", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete5Request generates requests for Delete5
func NewDelete5Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-merge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGet5Request generates requests for Get5
func NewGet5Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-merge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSet1Request calls the generic Set1 builder with application/json body
func NewSet1Request(server string, projectKey string, repositorySlug string, body Set1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSet1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSet1RequestWithBody generates requests for Set1 with any type of body
func NewSet1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/auto-merge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryHooks1Request generates requests for GetRepositoryHooks1
func NewGetRepositoryHooks1Request(server string, projectKey string, repositorySlug string, params *GetRepositoryHooks1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepositoryHookRequest generates requests for DeleteRepositoryHook
func NewDeleteRepositoryHookRequest(server string, projectKey string, repositorySlug string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryHook1Request generates requests for GetRepositoryHook1
func NewGetRepositoryHook1Request(server string, projectKey string, repositorySlug string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableHook1Request generates requests for DisableHook1
func NewDisableHook1Request(server string, projectKey string, repositorySlug string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s/enabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableHook1Request generates requests for EnableHook1
func NewEnableHook1Request(server string, projectKey string, repositorySlug string, hookKey string, params *EnableHook1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s/enabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentLength != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Length", runtime.ParamLocationHeader, *params.ContentLength)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Length", headerParam0)
		}

	}

	return req, nil
}

// NewGetSettings1Request generates requests for GetSettings1
func NewGetSettings1Request(server string, projectKey string, repositorySlug string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s/settings", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSettings1Request calls the generic SetSettings1 builder with application/json body
func NewSetSettings1Request(server string, projectKey string, repositorySlug string, hookKey string, body SetSettings1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSettings1RequestWithBody(server, projectKey, repositorySlug, hookKey, "application/json", bodyReader)
}

// NewSetSettings1RequestWithBody generates requests for SetSettings1 with any type of body
func NewSetSettings1RequestWithBody(server string, projectKey string, repositorySlug string, hookKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/hooks/%s/settings", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestSettings1Request generates requests for GetPullRequestSettings1
func NewGetPullRequestSettings1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/pull-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestSettings1Request calls the generic UpdatePullRequestSettings1 builder with application/json body
func NewUpdatePullRequestSettings1Request(server string, projectKey string, repositorySlug string, body UpdatePullRequestSettings1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestSettings1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewUpdatePullRequestSettings1RequestWithBody generates requests for UpdatePullRequestSettings1 with any type of body
func NewUpdatePullRequestSettings1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/pull-requests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReviewerGroups1Request generates requests for GetReviewerGroups1
func NewGetReviewerGroups1Request(server string, projectKey string, repositorySlug string, params *GetReviewerGroups1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate2Request calls the generic Create2 builder with application/json body
func NewCreate2Request(server string, projectKey string, repositorySlug string, body Create2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate2RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreate2RequestWithBody generates requests for Create2 with any type of body
func NewCreate2RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete7Request generates requests for Delete7
func NewDelete7Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReviewerGroup1Request generates requests for GetReviewerGroup1
func NewGetReviewerGroup1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdate2Request calls the generic Update2 builder with application/json body
func NewUpdate2Request(server string, projectKey string, repositorySlug string, id string, body Update2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdate2RequestWithBody(server, projectKey, repositorySlug, id, "application/json", bodyReader)
}

// NewUpdate2RequestWithBody generates requests for Update2 with any type of body
func NewUpdate2RequestWithBody(server string, projectKey string, repositorySlug string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/settings/reviewer-groups/%s/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, projectKey string, repositorySlug string, params *GetTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterText", runtime.ParamLocationQuery, *params.FilterText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagForRepositoryRequest calls the generic CreateTagForRepository builder with application/json body
func NewCreateTagForRepositoryRequest(server string, projectKey string, repositorySlug string, body CreateTagForRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagForRepositoryRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateTagForRepositoryRequestWithBody generates requests for CreateTagForRepository with any type of body
func NewCreateTagForRepositoryRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, projectKey string, repositorySlug string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnwatch2Request generates requests for Unwatch2
func NewUnwatch2Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/watch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWatch2Request calls the generic Watch2 builder with application/json body
func NewWatch2Request(server string, projectKey string, repositorySlug string, body Watch2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWatch2RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewWatch2RequestWithBody generates requests for Watch2 with any type of body
func NewWatch2RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/watch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWebhooks1Request generates requests for FindWebhooks1
func NewFindWebhooks1Request(server string, projectKey string, repositorySlug string, params *FindWebhooks1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statistics", runtime.ParamLocationQuery, *params.Statistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhook1Request calls the generic CreateWebhook1 builder with application/json body
func NewCreateWebhook1Request(server string, projectKey string, repositorySlug string, body CreateWebhook1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhook1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateWebhook1RequestWithBody generates requests for CreateWebhook1 with any type of body
func NewCreateWebhook1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchWebhooksRequest generates requests for SearchWebhooks
func NewSearchWebhooksRequest(server string, projectKey string, repositorySlug string, params *SearchWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ScopeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scopeType", runtime.ParamLocationQuery, *params.ScopeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statistics", runtime.ParamLocationQuery, *params.Statistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestWebhook1Request calls the generic TestWebhook1 builder with application/json body
func NewTestWebhook1Request(server string, projectKey string, repositorySlug string, params *TestWebhook1Params, body TestWebhook1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestWebhook1RequestWithBody(server, projectKey, repositorySlug, params, "application/json", bodyReader)
}

// NewTestWebhook1RequestWithBody generates requests for TestWebhook1 with any type of body
func NewTestWebhook1RequestWithBody(server string, projectKey string, repositorySlug string, params *TestWebhook1Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/test", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WebhookId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "webhookId", runtime.ParamLocationQuery, *params.WebhookId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SslVerificationRequired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sslVerificationRequired", runtime.ParamLocationQuery, *params.SslVerificationRequired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Url != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhook1Request generates requests for DeleteWebhook1
func NewDeleteWebhook1Request(server string, projectKey string, repositorySlug string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhook1Request generates requests for GetWebhook1
func NewGetWebhook1Request(server string, projectKey string, repositorySlug string, webhookId string, params *GetWebhook1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Statistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statistics", runtime.ParamLocationQuery, *params.Statistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhook1Request calls the generic UpdateWebhook1 builder with application/json body
func NewUpdateWebhook1Request(server string, projectKey string, repositorySlug string, webhookId string, body UpdateWebhook1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhook1RequestWithBody(server, projectKey, repositorySlug, webhookId, "application/json", bodyReader)
}

// NewUpdateWebhook1RequestWithBody generates requests for UpdateWebhook1 with any type of body
func NewUpdateWebhook1RequestWithBody(server string, projectKey string, repositorySlug string, webhookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestInvocation1Request generates requests for GetLatestInvocation1
func NewGetLatestInvocation1Request(server string, projectKey string, repositorySlug string, webhookId string, params *GetLatestInvocation1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s/latest", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Outcome != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outcome", runtime.ParamLocationQuery, *params.Outcome); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatistics1Request generates requests for GetStatistics1
func NewGetStatistics1Request(server string, projectKey string, repositorySlug string, webhookId string, params *GetStatistics1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s/statistics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsSummary1Request generates requests for GetStatisticsSummary1
func NewGetStatisticsSummary1Request(server string, projectKey string, repositorySlug string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/repos/%s/webhooks/%s/statistics/summary", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchAllowlistRuleRequest generates requests for SearchAllowlistRule
func NewSearchAllowlistRuleRequest(server string, projectKey string, params *SearchAllowlistRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/allowlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAllowlistRuleRequestWithBody generates requests for CreateAllowlistRule with any type of body
func NewCreateAllowlistRuleRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/allowlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllowlistRuleRequest generates requests for DeleteAllowlistRule
func NewDeleteAllowlistRuleRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllowlistRuleRequest generates requests for GetAllowlistRule
func NewGetAllowlistRuleRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditAllowlistRuleRequestWithBody generates requests for EditAllowlistRule with any type of body
func NewEditAllowlistRuleRequestWithBody(server string, projectKey string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/allowlist/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearch1Request generates requests for Search1
func NewSearch1Request(server string, projectKey string, params *Search1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleRequest generates requests for GetRule
func NewGetRuleRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditRuleRequestWithBody generates requests for EditRule with any type of body
func NewEditRuleRequestWithBody(server string, projectKey string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/secret-scanning/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete9Request generates requests for Delete9
func NewDelete9Request(server string, projectKey string, params *Delete9Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings-restriction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ComponentKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "componentKey", runtime.ParamLocationQuery, *params.ComponentKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featureKey", runtime.ParamLocationQuery, params.FeatureKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGet7Request generates requests for Get7
func NewGet7Request(server string, projectKey string, params *Get7Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings-restriction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ComponentKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "componentKey", runtime.ParamLocationQuery, *params.ComponentKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featureKey", runtime.ParamLocationQuery, params.FeatureKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate3Request calls the generic Create3 builder with application/json body
func NewCreate3Request(server string, projectKey string, body Create3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate3RequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreate3RequestWithBody generates requests for Create3 with any type of body
func NewCreate3RequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings-restriction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllRequest generates requests for GetAll
func NewGetAllRequest(server string, projectKey string, params *GetAllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings-restriction/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featureKey", runtime.ParamLocationQuery, params.FeatureKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAutoDeclineSettingsRequest generates requests for DeleteAutoDeclineSettings
func NewDeleteAutoDeclineSettingsRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoDeclineSettingsRequest generates requests for GetAutoDeclineSettings
func NewGetAutoDeclineSettingsRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoDeclineSettingsRequest calls the generic SetAutoDeclineSettings builder with application/json body
func NewSetAutoDeclineSettingsRequest(server string, projectKey string, body SetAutoDeclineSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoDeclineSettingsRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewSetAutoDeclineSettingsRequestWithBody generates requests for SetAutoDeclineSettings with any type of body
func NewSetAutoDeclineSettingsRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-decline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete4Request generates requests for Delete4
func NewDelete4Request(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGet4Request generates requests for Get4
func NewGet4Request(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRequest calls the generic Set builder with application/json body
func NewSetRequest(server string, projectKey string, body SetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewSetRequestWithBody generates requests for Set with any type of body
func NewSetRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/auto-merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryHooksRequest generates requests for GetRepositoryHooks
func NewGetRepositoryHooksRequest(server string, projectKey string, params *GetRepositoryHooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryHookRequest generates requests for GetRepositoryHook
func NewGetRepositoryHookRequest(server string, projectKey string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableHookRequest generates requests for DisableHook
func NewDisableHookRequest(server string, projectKey string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks/%s/enabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableHookRequest generates requests for EnableHook
func NewEnableHookRequest(server string, projectKey string, hookKey string, params *EnableHookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks/%s/enabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.ContentLength != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Length", runtime.ParamLocationHeader, *params.ContentLength)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Length", headerParam0)
		}

	}

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string, projectKey string, hookKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks/%s/settings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSettingsRequest calls the generic SetSettings builder with application/json body
func NewSetSettingsRequest(server string, projectKey string, hookKey string, body SetSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSettingsRequestWithBody(server, projectKey, hookKey, "application/json", bodyReader)
}

// NewSetSettingsRequestWithBody generates requests for SetSettings with any type of body
func NewSetSettingsRequestWithBody(server string, projectKey string, hookKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hookKey", runtime.ParamLocationPath, hookKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/hooks/%s/settings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestSettingsRequest generates requests for GetPullRequestSettings
func NewGetPullRequestSettingsRequest(server string, projectKey string, scmId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scmId", runtime.ParamLocationPath, scmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/pull-requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestSettingsRequest calls the generic UpdatePullRequestSettings builder with application/json body
func NewUpdatePullRequestSettingsRequest(server string, projectKey string, scmId string, body UpdatePullRequestSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestSettingsRequestWithBody(server, projectKey, scmId, "application/json", bodyReader)
}

// NewUpdatePullRequestSettingsRequestWithBody generates requests for UpdatePullRequestSettings with any type of body
func NewUpdatePullRequestSettingsRequestWithBody(server string, projectKey string, scmId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scmId", runtime.ParamLocationPath, scmId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/pull-requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReviewerGroupsRequest generates requests for GetReviewerGroups
func NewGetReviewerGroupsRequest(server string, projectKey string, params *GetReviewerGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/reviewer-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate1Request calls the generic Create1 builder with application/json body
func NewCreate1Request(server string, projectKey string, body Create1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate1RequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreate1RequestWithBody generates requests for Create1 with any type of body
func NewCreate1RequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/reviewer-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelete6Request generates requests for Delete6
func NewDelete6Request(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/reviewer-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReviewerGroupRequest generates requests for GetReviewerGroup
func NewGetReviewerGroupRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/reviewer-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdate1Request calls the generic Update1 builder with application/json body
func NewUpdate1Request(server string, projectKey string, id string, body Update1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdate1RequestWithBody(server, projectKey, id, "application/json", bodyReader)
}

// NewUpdate1RequestWithBody generates requests for Update1 with any type of body
func NewUpdate1RequestWithBody(server string, projectKey string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/settings/reviewer-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWebhooksRequest generates requests for FindWebhooks
func NewFindWebhooksRequest(server string, projectKey string, params *FindWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statistics", runtime.ParamLocationQuery, *params.Statistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookRequest calls the generic CreateWebhook builder with application/json body
func NewCreateWebhookRequest(server string, projectKey string, body CreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func NewCreateWebhookRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestWebhookRequest calls the generic TestWebhook builder with application/json body
func NewTestWebhookRequest(server string, projectKey string, params *TestWebhookParams, body TestWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestWebhookRequestWithBody(server, projectKey, params, "application/json", bodyReader)
}

// NewTestWebhookRequestWithBody generates requests for TestWebhook with any type of body
func NewTestWebhookRequestWithBody(server string, projectKey string, params *TestWebhookParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WebhookId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "webhookId", runtime.ParamLocationQuery, *params.WebhookId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SslVerificationRequired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sslVerificationRequired", runtime.ParamLocationQuery, *params.SslVerificationRequired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Url != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, projectKey string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, projectKey string, webhookId string, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Statistics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statistics", runtime.ParamLocationQuery, *params.Statistics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookRequest calls the generic UpdateWebhook builder with application/json body
func NewUpdateWebhookRequest(server string, projectKey string, webhookId string, body UpdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookRequestWithBody(server, projectKey, webhookId, "application/json", bodyReader)
}

// NewUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func NewUpdateWebhookRequestWithBody(server string, projectKey string, webhookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLatestInvocationRequest generates requests for GetLatestInvocation
func NewGetLatestInvocationRequest(server string, projectKey string, webhookId string, params *GetLatestInvocationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s/latest", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Outcome != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outcome", runtime.ParamLocationQuery, *params.Outcome); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsRequest generates requests for GetStatistics
func NewGetStatisticsRequest(server string, projectKey string, webhookId string, params *GetStatisticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s/statistics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsSummaryRequest generates requests for GetStatisticsSummary
func NewGetStatisticsSummaryRequest(server string, projectKey string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/projects/%s/webhooks/%s/statistics/summary", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositories1Request generates requests for GetRepositories1
func NewGetRepositories1Request(server string, params *GetRepositories1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Archived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Projectname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectname", runtime.ParamLocationQuery, *params.Projectname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Projectkey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectkey", runtime.ParamLocationQuery, *params.Projectkey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Visibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindExemptReposByScopeRequest generates requests for FindExemptReposByScope
func NewFindExemptReposByScopeRequest(server string, params *FindExemptReposByScopeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/exempt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkAddExemptRepositoriesRequestWithBody generates requests for BulkAddExemptRepositories with any type of body
func NewBulkAddExemptRepositoriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/exempt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearch4Request generates requests for Search4
func NewSearch4Request(server string, params *Search4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRule2RequestWithBody generates requests for CreateRule2 with any type of body
func NewCreateRule2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRule2Request generates requests for DeleteRule2
func NewDeleteRule2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRule2Request generates requests for GetRule2
func NewGetRule2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditRule2RequestWithBody generates requests for EditRule2 with any type of body
func NewEditRule2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/secret-scanning/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllCertificatesRequest generates requests for GetAllCertificates
func NewGetAllCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/signing/x509-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCertificateRequestWithBody generates requests for CreateCertificate with any type of body
func NewCreateCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/signing/x509-certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCertificateRevocationListEntriesRequest generates requests for UpdateCertificateRevocationListEntries
func NewUpdateCertificateRevocationListEntriesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/signing/x509-certificates/crl/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCertificateRequest generates requests for DeleteCertificate
func NewDeleteCertificateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/signing/x509-certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSigningConfigurationRequest generates requests for GetSystemSigningConfiguration
func NewGetSystemSigningConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/system-signing/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSystemSigningConfigurationRequest calls the generic UpdateSystemSigningConfiguration builder with application/json body
func NewUpdateSystemSigningConfigurationRequest(server string, body UpdateSystemSigningConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSystemSigningConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateSystemSigningConfigurationRequestWithBody generates requests for UpdateSystemSigningConfiguration with any type of body
func NewUpdateSystemSigningConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/system-signing/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsers2Request generates requests for GetUsers2
func NewGetUsers2Request(server string, params *GetUsers2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PermissionN != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission.N", runtime.ParamLocationQuery, *params.PermissionN); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserDetails1Request calls the generic UpdateUserDetails1 builder with application/json body
func NewUpdateUserDetails1Request(server string, body UpdateUserDetails1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserDetails1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserDetails1RequestWithBody generates requests for UpdateUserDetails1 with any type of body
func NewUpdateUserDetails1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserPassword1Request calls the generic UpdateUserPassword1 builder with application/json body
func NewUpdateUserPassword1Request(server string, body UpdateUserPassword1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPassword1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserPassword1RequestWithBody generates requests for UpdateUserPassword1 with any type of body
func NewUpdateUserPassword1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAvatarRequest generates requests for DeleteAvatar
func NewDeleteAvatarRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/%s/avatar.png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadAvatar1RequestWithBody generates requests for UploadAvatar1 with any type of body
func NewUploadAvatar1RequestWithBody(server string, userSlug string, params *UploadAvatar1Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/%s/avatar.png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XAtlassianToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Atlassian-Token", runtime.ParamLocationHeader, *params.XAtlassianToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Atlassian-Token", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserSettingsRequest generates requests for GetUserSettings
func NewGetUserSettingsRequest(server string, userSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSettingsRequest calls the generic UpdateSettings builder with application/json body
func NewUpdateSettingsRequest(server string, userSlug string, body UpdateSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSettingsRequestWithBody(server, userSlug, "application/json", bodyReader)
}

// NewUpdateSettingsRequestWithBody generates requests for UpdateSettings with any type of body
func NewUpdateSettingsRequestWithBody(server string, userSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userSlug", runtime.ParamLocationPath, userSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/latest/users/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDismissRetentionConfigReviewNotificationRequest generates requests for DismissRetentionConfigReviewNotification
func NewDismissRetentionConfigReviewNotificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit/latest/notification-settings/retention-config-review")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRestrictions1Request generates requests for GetRestrictions1
func NewGetRestrictions1Request(server string, projectKey string, repositorySlug string, params *GetRestrictions1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/repos/%s/restrictions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MatcherType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matcherType", runtime.ParamLocationQuery, *params.MatcherType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matcherId", runtime.ParamLocationQuery, *params.MatcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRestrictions1RequestWithApplicationVndAtlBitbucketBulkPlusJSONBody calls the generic CreateRestrictions1 builder with application/vnd.atl.bitbucket.bulk+json body
func NewCreateRestrictions1RequestWithApplicationVndAtlBitbucketBulkPlusJSONBody(server string, projectKey string, repositorySlug string, body CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRestrictions1RequestWithBody(server, projectKey, repositorySlug, "application/vnd.atl.bitbucket.bulk+json", bodyReader)
}

// NewCreateRestrictions1RequestWithBody generates requests for CreateRestrictions1 with any type of body
func NewCreateRestrictions1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/repos/%s/restrictions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRestriction1Request generates requests for DeleteRestriction1
func NewDeleteRestriction1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/repos/%s/restrictions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRestriction1Request generates requests for GetRestriction1
func NewGetRestriction1Request(server string, projectKey string, repositorySlug string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/repos/%s/restrictions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRestrictionsRequest generates requests for GetRestrictions
func NewGetRestrictionsRequest(server string, projectKey string, params *GetRestrictionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/restrictions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MatcherType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matcherType", runtime.ParamLocationQuery, *params.MatcherType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatcherId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matcherId", runtime.ParamLocationQuery, *params.MatcherId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRestrictionsRequestWithApplicationVndAtlBitbucketBulkPlusJSONBody calls the generic CreateRestrictions builder with application/vnd.atl.bitbucket.bulk+json body
func NewCreateRestrictionsRequestWithApplicationVndAtlBitbucketBulkPlusJSONBody(server string, projectKey string, body CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRestrictionsRequestWithBody(server, projectKey, "application/vnd.atl.bitbucket.bulk+json", bodyReader)
}

// NewCreateRestrictionsRequestWithBody generates requests for CreateRestrictions with any type of body
func NewCreateRestrictionsRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/restrictions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRestrictionRequest generates requests for DeleteRestriction
func NewDeleteRestrictionRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/restrictions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRestrictionRequest generates requests for GetRestriction
func NewGetRestrictionRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-permissions/latest/projects/%s/restrictions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBranchRequest calls the generic DeleteBranch builder with application/json body
func NewDeleteBranchRequest(server string, projectKey string, repositorySlug string, body DeleteBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBranchRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewDeleteBranchRequestWithBody generates requests for DeleteBranch with any type of body
func NewDeleteBranchRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-utils/latest/projects/%s/repos/%s/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBranchRequest calls the generic CreateBranch builder with application/json body
func NewCreateBranchRequest(server string, projectKey string, repositorySlug string, body CreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateBranchRequestWithBody generates requests for CreateBranch with any type of body
func NewCreateBranchRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-utils/latest/projects/%s/repos/%s/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindByCommitRequest generates requests for FindByCommit
func NewFindByCommitRequest(server string, projectKey string, repositorySlug string, commitId string, params *FindByCommitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	var pathParamBuf2 []byte
	pathParamBuf2, err = json.Marshal(commitId)
	if err != nil {
		return nil, err
	}
	pathParam2 = string(pathParamBuf2)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/branch-utils/latest/projects/%s/repos/%s/branches/info/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMultipleBuildStatusStatsRequest calls the generic GetMultipleBuildStatusStats builder with application/json body
func NewGetMultipleBuildStatusStatsRequest(server string, body GetMultipleBuildStatusStatsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMultipleBuildStatusStatsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMultipleBuildStatusStatsRequestWithBody generates requests for GetMultipleBuildStatusStats with any type of body
func NewGetMultipleBuildStatusStatsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build-status/latest/commits/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBuildStatusStatsRequest generates requests for GetBuildStatusStats
func NewGetBuildStatusStatsRequest(server string, commitId string, params *GetBuildStatusStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build-status/latest/commits/stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnique != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeUnique", runtime.ParamLocationQuery, *params.IncludeUnique); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildStatusRequest generates requests for GetBuildStatus
func NewGetBuildStatusRequest(server string, commitId string, params *GetBuildStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build-status/latest/commits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBuildStatusRequest calls the generic AddBuildStatus builder with application/json body
func NewAddBuildStatusRequest(server string, commitId string, body AddBuildStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBuildStatusRequestWithBody(server, commitId, "application/json", bodyReader)
}

// NewAddBuildStatusRequestWithBody generates requests for AddBuildStatus with any type of body
func NewAddBuildStatusRequestWithBody(server string, commitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/build-status/latest/commits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnReactRequest generates requests for UnReact
func NewUnReactRequest(server string, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "emoticon", runtime.ParamLocationPath, emoticon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment-likes/latest/projects/%s/repos/%s/commits/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactRequest generates requests for React
func NewReactRequest(server string, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "emoticon", runtime.ParamLocationPath, emoticon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment-likes/latest/projects/%s/repos/%s/commits/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnReact1Request generates requests for UnReact1
func NewUnReact1Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "emoticon", runtime.ParamLocationPath, emoticon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment-likes/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReact1Request generates requests for React1
func NewReact1Request(server string, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "emoticon", runtime.ParamLocationPath, emoticon)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/comment-likes/latest/projects/%s/repos/%s/pull-requests/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePullRequestConditionRequest calls the generic CreatePullRequestCondition builder with application/json body
func NewCreatePullRequestConditionRequest(server string, projectKey string, body CreatePullRequestConditionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePullRequestConditionRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewCreatePullRequestConditionRequestWithBody generates requests for CreatePullRequestCondition with any type of body
func NewCreatePullRequestConditionRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/condition", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePullRequestConditionRequest generates requests for DeletePullRequestCondition
func NewDeletePullRequestConditionRequest(server string, projectKey string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/condition/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestConditionRequest calls the generic UpdatePullRequestCondition builder with application/json body
func NewUpdatePullRequestConditionRequest(server string, projectKey string, id string, body UpdatePullRequestConditionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestConditionRequestWithBody(server, projectKey, id, "application/json", bodyReader)
}

// NewUpdatePullRequestConditionRequestWithBody generates requests for UpdatePullRequestCondition with any type of body
func NewUpdatePullRequestConditionRequestWithBody(server string, projectKey string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/condition/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestConditionsRequest generates requests for GetPullRequestConditions
func NewGetPullRequestConditionsRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePullRequestCondition1Request calls the generic CreatePullRequestCondition1 builder with application/json body
func NewCreatePullRequestCondition1Request(server string, projectKey string, repositorySlug string, body CreatePullRequestCondition1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePullRequestCondition1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreatePullRequestCondition1RequestWithBody generates requests for CreatePullRequestCondition1 with any type of body
func NewCreatePullRequestCondition1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/repos/%s/condition", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePullRequestCondition1Request generates requests for DeletePullRequestCondition1
func NewDeletePullRequestCondition1Request(server string, projectKey string, repositorySlug string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/repos/%s/condition/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePullRequestCondition1Request calls the generic UpdatePullRequestCondition1 builder with application/json body
func NewUpdatePullRequestCondition1Request(server string, projectKey string, repositorySlug string, id string, body UpdatePullRequestCondition1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePullRequestCondition1RequestWithBody(server, projectKey, repositorySlug, id, "application/json", bodyReader)
}

// NewUpdatePullRequestCondition1RequestWithBody generates requests for UpdatePullRequestCondition1 with any type of body
func NewUpdatePullRequestCondition1RequestWithBody(server string, projectKey string, repositorySlug string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/repos/%s/condition/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPullRequestConditions1Request generates requests for GetPullRequestConditions1
func NewGetPullRequestConditions1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/repos/%s/conditions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReviewersRequest generates requests for GetReviewers
func NewGetReviewersRequest(server string, projectKey string, repositorySlug string, params *GetReviewersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-reviewers/latest/projects/%s/repos/%s/reviewers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TargetRepoId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetRepoId", runtime.ParamLocationQuery, *params.TargetRepoId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceRepoId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceRepoId", runtime.ParamLocationQuery, *params.SourceRepoId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceRefId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceRefId", runtime.ParamLocationQuery, *params.SourceRefId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetRefId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetRefId", runtime.ParamLocationQuery, *params.TargetRefId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAllDefaultTasks1Request generates requests for DeleteAllDefaultTasks1
func NewDeleteAllDefaultTasks1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/repos/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultTasks1Request generates requests for GetDefaultTasks1
func NewGetDefaultTasks1Request(server string, projectKey string, repositorySlug string, params *GetDefaultTasks1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/repos/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDefaultTask1Request calls the generic AddDefaultTask1 builder with application/json body
func NewAddDefaultTask1Request(server string, projectKey string, repositorySlug string, body AddDefaultTask1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDefaultTask1RequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewAddDefaultTask1RequestWithBody generates requests for AddDefaultTask1 with any type of body
func NewAddDefaultTask1RequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/repos/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDefaultTask1Request generates requests for DeleteDefaultTask1
func NewDeleteDefaultTask1Request(server string, projectKey string, repositorySlug string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/repos/%s/tasks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDefaultTask1Request calls the generic UpdateDefaultTask1 builder with application/json body
func NewUpdateDefaultTask1Request(server string, projectKey string, repositorySlug string, taskId string, body UpdateDefaultTask1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDefaultTask1RequestWithBody(server, projectKey, repositorySlug, taskId, "application/json", bodyReader)
}

// NewUpdateDefaultTask1RequestWithBody generates requests for UpdateDefaultTask1 with any type of body
func NewUpdateDefaultTask1RequestWithBody(server string, projectKey string, repositorySlug string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/repos/%s/tasks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllDefaultTasksRequest generates requests for DeleteAllDefaultTasks
func NewDeleteAllDefaultTasksRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultTasksRequest generates requests for GetDefaultTasks
func NewGetDefaultTasksRequest(server string, projectKey string, params *GetDefaultTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Markup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "markup", runtime.ParamLocationQuery, *params.Markup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDefaultTaskRequest calls the generic AddDefaultTask builder with application/json body
func NewAddDefaultTaskRequest(server string, projectKey string, body AddDefaultTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDefaultTaskRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewAddDefaultTaskRequestWithBody generates requests for AddDefaultTask with any type of body
func NewAddDefaultTaskRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDefaultTaskRequest generates requests for DeleteDefaultTask
func NewDeleteDefaultTaskRequest(server string, projectKey string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDefaultTaskRequest calls the generic UpdateDefaultTask builder with application/json body
func NewUpdateDefaultTaskRequest(server string, projectKey string, taskId string, body UpdateDefaultTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDefaultTaskRequestWithBody(server, projectKey, taskId, "application/json", bodyReader)
}

// NewUpdateDefaultTaskRequestWithBody generates requests for UpdateDefaultTask with any type of body
func NewUpdateDefaultTaskRequestWithBody(server string, projectKey string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/default-tasks/latest/projects/%s/tasks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCanRebaseRequest generates requests for CanRebase
func NewCanRebaseRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/git/latest/projects/%s/repos/%s/pull-requests/%s/rebase", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebaseRequest calls the generic Rebase builder with application/json body
func NewRebaseRequest(server string, projectKey string, repositorySlug string, pullRequestId string, body RebaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRebaseRequestWithBody(server, projectKey, repositorySlug, pullRequestId, "application/json", bodyReader)
}

// NewRebaseRequestWithBody generates requests for Rebase with any type of body
func NewRebaseRequestWithBody(server string, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/git/latest/projects/%s/repos/%s/pull-requests/%s/rebase", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, projectKey string, repositorySlug string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/git/latest/projects/%s/repos/%s/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, projectKey string, repositorySlug string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/git/latest/projects/%s/repos/%s/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteForUserRequest generates requests for DeleteForUser
func NewDeleteForUserRequest(server string, params *DeleteForUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gpg/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeysForUserRequest generates requests for GetKeysForUser
func NewGetKeysForUserRequest(server string, params *GetKeysForUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gpg/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddKeyRequest calls the generic AddKey builder with application/json body
func NewAddKeyRequest(server string, params *AddKeyParams, body AddKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddKeyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddKeyRequestWithBody generates requests for AddKey with any type of body
func NewAddKeyRequestWithBody(server string, params *AddKeyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gpg/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeyRequest generates requests for DeleteKey
func NewDeleteKeyRequest(server string, fingerprintOrId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fingerprintOrId", runtime.ParamLocationPath, fingerprintOrId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gpg/latest/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnnotations1Request generates requests for GetAnnotations1
func NewGetAnnotations1Request(server string, projectKey string, repositorySlug string, commitId string, params *GetAnnotations1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/annotations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "externalId", runtime.ParamLocationQuery, *params.ExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportsRequest generates requests for GetReports
func NewGetReportsRequest(server string, projectKey string, repositorySlug string, commitId string, params *GetReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACodeInsightsReportRequest generates requests for DeleteACodeInsightsReport
func NewDeleteACodeInsightsReportRequest(server string, projectKey string, repositorySlug string, commitId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetACodeInsightsReportRequest generates requests for GetACodeInsightsReport
func NewGetACodeInsightsReportRequest(server string, projectKey string, repositorySlug string, commitId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetACodeInsightsReportRequest calls the generic SetACodeInsightsReport builder with application/json body
func NewSetACodeInsightsReportRequest(server string, projectKey string, repositorySlug string, commitId string, key string, body SetACodeInsightsReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetACodeInsightsReportRequestWithBody(server, projectKey, repositorySlug, commitId, key, "application/json", bodyReader)
}

// NewSetACodeInsightsReportRequestWithBody generates requests for SetACodeInsightsReport with any type of body
func NewSetACodeInsightsReportRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAnnotationsRequest generates requests for DeleteAnnotations
func NewDeleteAnnotationsRequest(server string, projectKey string, repositorySlug string, commitId string, key string, params *DeleteAnnotationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s/annotations", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "externalId", runtime.ParamLocationQuery, *params.ExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnnotationsRequest generates requests for GetAnnotations
func NewGetAnnotationsRequest(server string, projectKey string, repositorySlug string, commitId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s/annotations", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAnnotationsRequest calls the generic AddAnnotations builder with application/json body
func NewAddAnnotationsRequest(server string, projectKey string, repositorySlug string, commitId string, key string, body AddAnnotationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAnnotationsRequestWithBody(server, projectKey, repositorySlug, commitId, key, "application/json", bodyReader)
}

// NewAddAnnotationsRequestWithBody generates requests for AddAnnotations with any type of body
func NewAddAnnotationsRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s/annotations", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetAnnotationRequest calls the generic SetAnnotation builder with application/json body
func NewSetAnnotationRequest(server string, projectKey string, repositorySlug string, commitId string, key string, externalId string, body SetAnnotationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAnnotationRequestWithBody(server, projectKey, repositorySlug, commitId, key, externalId, "application/json", bodyReader)
}

// NewSetAnnotationRequestWithBody generates requests for SetAnnotation with any type of body
func NewSetAnnotationRequestWithBody(server string, projectKey string, repositorySlug string, commitId string, key string, externalId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "externalId", runtime.ParamLocationPath, externalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights/latest/projects/%s/repos/%s/commits/%s/reports/%s/annotations/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIssueRequest calls the generic CreateIssue builder with application/json body
func NewCreateIssueRequest(server string, commentId string, params *CreateIssueParams, body CreateIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIssueRequestWithBody(server, commentId, params, "application/json", bodyReader)
}

// NewCreateIssueRequestWithBody generates requests for CreateIssue with any type of body
func NewCreateIssueRequestWithBody(server string, commentId string, params *CreateIssueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "commentId", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jira/latest/comments/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ApplicationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applicationId", runtime.ParamLocationQuery, *params.ApplicationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitsByIssueKeyRequest generates requests for GetCommitsByIssueKey
func NewGetCommitsByIssueKeyRequest(server string, issueKey string, params *GetCommitsByIssueKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issueKey", runtime.ParamLocationPath, issueKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jira/latest/issues/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxChanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxChanges", runtime.ParamLocationQuery, *params.MaxChanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnhancedEntityLinkForProjectRequest generates requests for GetEnhancedEntityLinkForProject
func NewGetEnhancedEntityLinkForProjectRequest(server string, projectKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jira/latest/projects/%s/primary-enhanced-entitylink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIssueKeysForPullRequestRequest generates requests for GetIssueKeysForPullRequest
func NewGetIssueKeysForPullRequestRequest(server string, projectKey string, repositorySlug string, pullRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pullRequestId", runtime.ParamLocationPath, pullRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jira/latest/projects/%s/repos/%s/pull-requests/%s/issues", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForRepository1Request generates requests for GetForRepository1
func NewGetForRepository1Request(server string, projectKey string, repositorySlug string, params *GetForRepository1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/repos/%s/ssh", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinimumPermission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minimumPermission", runtime.ParamLocationQuery, *params.MinimumPermission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddForRepositoryRequest calls the generic AddForRepository builder with application/json body
func NewAddForRepositoryRequest(server string, projectKey string, repositorySlug string, body AddForRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddForRepositoryRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewAddForRepositoryRequestWithBody generates requests for AddForRepository with any type of body
func NewAddForRepositoryRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/repos/%s/ssh", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeForRepositoryRequest generates requests for RevokeForRepository
func NewRevokeForRepositoryRequest(server string, projectKey string, repositorySlug string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/repos/%s/ssh/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForRepositoryRequest generates requests for GetForRepository
func NewGetForRepositoryRequest(server string, projectKey string, repositorySlug string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/repos/%s/ssh/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePermission1Request generates requests for UpdatePermission1
func NewUpdatePermission1Request(server string, projectKey string, repositorySlug string, keyId string, permission string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "permission", runtime.ParamLocationPath, permission)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/repos/%s/ssh/%s/permission/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSshKeysForProjectRequest generates requests for GetSshKeysForProject
func NewGetSshKeysForProjectRequest(server string, projectKey string, params *GetSshKeysForProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/ssh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Permission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permission", runtime.ParamLocationQuery, *params.Permission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddForProjectRequest calls the generic AddForProject builder with application/json body
func NewAddForProjectRequest(server string, projectKey string, body AddForProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddForProjectRequestWithBody(server, projectKey, "application/json", bodyReader)
}

// NewAddForProjectRequestWithBody generates requests for AddForProject with any type of body
func NewAddForProjectRequestWithBody(server string, projectKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/ssh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeForProjectRequest generates requests for RevokeForProject
func NewRevokeForProjectRequest(server string, projectKey string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/ssh/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForProjectRequest generates requests for GetForProject
func NewGetForProjectRequest(server string, projectKey string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/ssh/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePermissionRequest generates requests for UpdatePermission
func NewUpdatePermissionRequest(server string, projectKey string, keyId string, permission string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "permission", runtime.ParamLocationPath, permission)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/projects/%s/ssh/%s/permission/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeManyRequest calls the generic RevokeMany builder with application/json body
func NewRevokeManyRequest(server string, keyId string, body RevokeManyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeManyRequestWithBody(server, keyId, "application/json", bodyReader)
}

// NewRevokeManyRequestWithBody generates requests for RevokeMany with any type of body
func NewRevokeManyRequestWithBody(server string, keyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/ssh/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetForProjectsRequest generates requests for GetForProjects
func NewGetForProjectsRequest(server string, keyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/ssh/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetForRepositoriesRequest generates requests for GetForRepositories
func NewGetForRepositoriesRequest(server string, keyId string, params *GetForRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys/latest/ssh/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithRestrictions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withRestrictions", runtime.ParamLocationQuery, *params.WithRestrictions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePreferredMirrorIdRequest generates requests for DeletePreferredMirrorId
func NewDeletePreferredMirrorIdRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/account/settings/preferred-mirror")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreferredMirrorIdRequest generates requests for GetPreferredMirrorId
func NewGetPreferredMirrorIdRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/account/settings/preferred-mirror")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPreferredMirrorIdRequest calls the generic SetPreferredMirrorId builder with application/json body
func NewSetPreferredMirrorIdRequest(server string, body SetPreferredMirrorIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPreferredMirrorIdRequestWithBody(server, "application/json", bodyReader)
}

// NewSetPreferredMirrorIdRequestWithBody generates requests for SetPreferredMirrorId with any type of body
func NewSetPreferredMirrorIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/account/settings/preferred-mirror")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAnalyticsSettingsRequest generates requests for AnalyticsSettings
func NewAnalyticsSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/analyticsSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticateRequest calls the generic Authenticate builder with application/json body
func NewAuthenticateRequest(server string, body AuthenticateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateRequestWithBody generates requests for Authenticate with any type of body
func NewAuthenticateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/authenticate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFarmNodesRequest generates requests for GetFarmNodes
func NewGetFarmNodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/farmNodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMirroredRepositoryRequest generates requests for GetMirroredRepository
func NewGetMirroredRepositoryRequest(server string, externalRepositoryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalRepositoryId", runtime.ParamLocationPath, externalRepositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorRepos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMirrorsRequest generates requests for ListMirrors
func NewListMirrorsRequest(server string, params *ListMirrorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorServers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRequest generates requests for Remove
func NewRemoveRequest(server string, mirrorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirrorId", runtime.ParamLocationPath, mirrorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMirrorRequest generates requests for GetMirror
func NewGetMirrorRequest(server string, mirrorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirrorId", runtime.ParamLocationPath, mirrorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeRequest calls the generic Upgrade builder with application/json body
func NewUpgradeRequest(server string, mirrorId string, body UpgradeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeRequestWithBody(server, mirrorId, "application/json", bodyReader)
}

// NewUpgradeRequestWithBody generates requests for Upgrade with any type of body
func NewUpgradeRequestWithBody(server string, mirrorId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirrorId", runtime.ParamLocationPath, mirrorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishEventRequest calls the generic PublishEvent builder with application/json body
func NewPublishEventRequest(server string, mirrorId string, body PublishEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishEventRequestWithBody(server, mirrorId, "application/json", bodyReader)
}

// NewPublishEventRequestWithBody generates requests for PublishEvent with any type of body
func NewPublishEventRequestWithBody(server string, mirrorId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirrorId", runtime.ParamLocationPath, mirrorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/mirrorServers/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSynchronizationProgressRequest generates requests for GetSynchronizationProgress
func NewGetSynchronizationProgressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectByIdRequest generates requests for GetProjectById
func NewGetProjectByIdRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllReposForProjectRequest generates requests for GetAllReposForProject
func NewGetAllReposForProjectRequest(server string, projectId string, params *GetAllReposForProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/projects/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDefaultBranch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDefaultBranch", runtime.ParamLocationQuery, *params.IncludeDefaultBranch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllContentHashesRequest generates requests for GetAllContentHashes
func NewGetAllContentHashesRequest(server string, params *GetAllContentHashesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDefaultBranch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDefaultBranch", runtime.ParamLocationQuery, *params.IncludeDefaultBranch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentHashByIdRequest generates requests for GetContentHashById
func NewGetContentHashByIdRequest(server string, repoId string, params *GetContentHashByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoId", runtime.ParamLocationPath, repoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/repos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDefaultBranch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDefaultBranch", runtime.ParamLocationQuery, *params.IncludeDefaultBranch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryMirrorsRequest generates requests for GetRepositoryMirrors
func NewGetRepositoryMirrorsRequest(server string, repoId string, params *GetRepositoryMirrorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoId", runtime.ParamLocationPath, repoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/repos/%s/mirrors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PreAuthorized != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preAuthorized", runtime.ParamLocationQuery, *params.PreAuthorized); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequestsRequest generates requests for ListRequests
func NewListRequestsRequest(server string, params *ListRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterRequest calls the generic Register builder with application/json body
func NewRegisterRequest(server string, body RegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterRequestWithBody generates requests for Register with any type of body
func NewRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMirroringRequestRequest generates requests for DeleteMirroringRequest
func NewDeleteMirroringRequestRequest(server string, mirroringRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirroringRequestId", runtime.ParamLocationPath, mirroringRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMirroringRequestRequest generates requests for GetMirroringRequest
func NewGetMirroringRequestRequest(server string, mirroringRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirroringRequestId", runtime.ParamLocationPath, mirroringRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptRequest generates requests for Accept
func NewAcceptRequest(server string, mirroringRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirroringRequestId", runtime.ParamLocationPath, mirroringRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests/%s/accept", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectRequest generates requests for Reject
func NewRejectRequest(server string, mirroringRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mirroringRequestId", runtime.ParamLocationPath, mirroringRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/requests/%s/reject", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutOfSyncRepositoriesRequest generates requests for GetOutOfSyncRepositories
func NewGetOutOfSyncRepositoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/out-of-sync-repos/content")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryLockOwnerRequest generates requests for GetRepositoryLockOwner
func NewGetRepositoryLockOwnerRequest(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/projects/%s/repos/%s/repo-lock-owner", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepoSyncStatus1Request generates requests for GetRepoSyncStatus1
func NewGetRepoSyncStatus1Request(server string, projectKey string, repositorySlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/projects/%s/repos/%s/repoSyncStatus", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRefChangesQueueRequest generates requests for GetRefChangesQueue
func NewGetRefChangesQueueRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/refChangesQueue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRefChangesQueueCountRequest generates requests for GetRefChangesQueueCount
func NewGetRefChangesQueueCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/refChangesQueue/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryLockOwnersRequest generates requests for GetRepositoryLockOwners
func NewGetRepositoryLockOwnersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/repo-lock-owners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepoSyncStatusRequest generates requests for GetRepoSyncStatus
func NewGetRepoSyncStatusRequest(server string, params *GetRepoSyncStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/supportInfo/repoSyncStatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMirrorSettingsRequest generates requests for GetMirrorSettings
func NewGetMirrorSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMirrorSettingsRequest calls the generic SetMirrorSettings builder with application/json body
func NewSetMirrorSettingsRequest(server string, body SetMirrorSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMirrorSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetMirrorSettingsRequestWithBody generates requests for SetMirrorSettings with any type of body
func NewSetMirrorSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMirrorModeRequest generates requests for GetMirrorMode
func NewGetMirrorModeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMirrorModeRequest calls the generic SetMirrorMode builder with application/json body
func NewSetMirrorModeRequest(server string, body SetMirrorModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMirrorModeRequestWithBody(server, "application/json", bodyReader)
}

// NewSetMirrorModeRequestWithBody generates requests for SetMirrorMode with any type of body
func NewSetMirrorModeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMirroredProjectsRequest generates requests for GetMirroredProjects
func NewGetMirroredProjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartMirroringProjectsRequest calls the generic StartMirroringProjects builder with application/json body
func NewStartMirroringProjectsRequest(server string, body StartMirroringProjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartMirroringProjectsRequestWithBody(server, "application/json", bodyReader)
}

// NewStartMirroringProjectsRequestWithBody generates requests for StartMirroringProjects with any type of body
func NewStartMirroringProjectsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopMirroringProjectRequest generates requests for StopMirroringProject
func NewStopMirroringProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartMirroringProjectRequest generates requests for StartMirroringProject
func NewStartMirroringProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/syncSettings/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpstreamServerRequest generates requests for GetUpstreamServer
func NewGetUpstreamServerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/upstreamServer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndRollingUpgradeRequest generates requests for EndRollingUpgrade
func NewEndRollingUpgradeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/zdu/end")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartRollingUpgradeRequest generates requests for StartRollingUpgrade
func NewStartRollingUpgradeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mirroring/latest/zdu/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryArchivePolicyRequest generates requests for GetRepositoryArchivePolicy
func NewGetRepositoryArchivePolicyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/latest/admin/repos/archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryArchivePolicyRequest calls the generic SetRepositoryArchivePolicy builder with application/json body
func NewSetRepositoryArchivePolicyRequest(server string, body SetRepositoryArchivePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryArchivePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewSetRepositoryArchivePolicyRequestWithBody generates requests for SetRepositoryArchivePolicy with any type of body
func NewSetRepositoryArchivePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/latest/admin/repos/archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryDeletePolicyRequest generates requests for GetRepositoryDeletePolicy
func NewGetRepositoryDeletePolicyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/latest/admin/repos/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryDeletePolicyRequest calls the generic SetRepositoryDeletePolicy builder with application/json body
func NewSetRepositoryDeletePolicyRequest(server string, body SetRepositoryDeletePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryDeletePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewSetRepositoryDeletePolicyRequestWithBody generates requests for SetRepositoryDeletePolicy with any type of body
func NewSetRepositoryDeletePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/latest/admin/repos/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRequiredBuildsMergeCheckRequestWithBody generates requests for CreateRequiredBuildsMergeCheck with any type of body
func NewCreateRequiredBuildsMergeCheckRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/required-builds/latest/projects/%s/repos/%s/condition", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequiredBuildsMergeCheckRequest generates requests for DeleteRequiredBuildsMergeCheck
func NewDeleteRequiredBuildsMergeCheckRequest(server string, projectKey string, repositorySlug string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/required-builds/latest/projects/%s/repos/%s/condition/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequiredBuildsMergeCheckRequestWithBody generates requests for UpdateRequiredBuildsMergeCheck with any type of body
func NewUpdateRequiredBuildsMergeCheckRequestWithBody(server string, projectKey string, repositorySlug string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/required-builds/latest/projects/%s/repos/%s/condition/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPageOfRequiredBuildsMergeChecksRequest generates requests for GetPageOfRequiredBuildsMergeChecks
func NewGetPageOfRequiredBuildsMergeChecksRequest(server string, projectKey string, repositorySlug string, params *GetPageOfRequiredBuildsMergeChecksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/required-builds/latest/projects/%s/repos/%s/conditions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSshKeysRequest generates requests for DeleteSshKeys
func NewDeleteSshKeysRequest(server string, params *DeleteSshKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userName", runtime.ParamLocationQuery, *params.UserName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSshKeysRequest generates requests for GetSshKeys
func NewGetSshKeysRequest(server string, params *GetSshKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userName", runtime.ParamLocationQuery, *params.UserName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSshKeyRequest calls the generic AddSshKey builder with application/json body
func NewAddSshKeyRequest(server string, params *AddSshKeyParams, body AddSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSshKeyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddSshKeyRequestWithBody generates requests for AddSshKey with any type of body
func NewAddSshKeyRequestWithBody(server string, params *AddSshKeyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryParamBuf, err := json.Marshal(*params.User); err != nil {
				return nil, err
			} else {
				queryValues.Add("user", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSshKeyRequest generates requests for DeleteSshKey
func NewDeleteSshKeyRequest(server string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSshKeyRequest generates requests for GetSshKey
func NewGetSshKeyRequest(server string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSshSettingsRequest generates requests for SshSettings
func NewSshSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh/latest/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string, projectKey string, repositorySlug string, params *GetStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.At != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "at", runtime.ParamLocationQuery, *params.At); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEnabledRequest calls the generic SetEnabled builder with application/json body
func NewSetEnabledRequest(server string, projectKey string, repositorySlug string, body SetEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetEnabledRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSetEnabledRequestWithBody generates requests for SetEnabled with any type of body
func NewSetEnabledRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/latest/projects/%s/repos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSynchronizeRequest calls the generic Synchronize builder with application/json body
func NewSynchronizeRequest(server string, projectKey string, repositorySlug string, body SynchronizeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSynchronizeRequestWithBody(server, projectKey, repositorySlug, "application/json", bodyReader)
}

// NewSynchronizeRequestWithBody generates requests for Synchronize with any type of body
func NewSynchronizeRequestWithBody(server string, projectKey string, repositorySlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectKey", runtime.ParamLocationPath, projectKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositorySlug", runtime.ParamLocationPath, repositorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/latest/projects/%s/repos/%s/synchronize", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllAccessTokensWithResponse request
	GetAllAccessTokensWithResponse(ctx context.Context, projectKey string, params *GetAllAccessTokensParams, reqEditors ...RequestEditorFn) (*GetAllAccessTokensResponse, error)

	// CreateAccessTokenWithBodyWithResponse request with any body
	CreateAccessTokenWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessTokenResponse, error)

	CreateAccessTokenWithResponse(ctx context.Context, projectKey string, body CreateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessTokenResponse, error)

	// GetAllAccessTokens1WithResponse request
	GetAllAccessTokens1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetAllAccessTokens1Params, reqEditors ...RequestEditorFn) (*GetAllAccessTokens1Response, error)

	// CreateAccessToken1WithBodyWithResponse request with any body
	CreateAccessToken1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessToken1Response, error)

	CreateAccessToken1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessToken1Response, error)

	// DeleteById1WithResponse request
	DeleteById1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteById1Response, error)

	// GetById1WithResponse request
	GetById1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*GetById1Response, error)

	// UpdateAccessToken1WithBodyWithResponse request with any body
	UpdateAccessToken1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessToken1Response, error)

	UpdateAccessToken1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, body UpdateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessToken1Response, error)

	// DeleteByIdWithResponse request
	DeleteByIdWithResponse(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error)

	// GetByIdWithResponse request
	GetByIdWithResponse(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*GetByIdResponse, error)

	// UpdateAccessTokenWithBodyWithResponse request with any body
	UpdateAccessTokenWithBodyWithResponse(ctx context.Context, projectKey string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessTokenResponse, error)

	UpdateAccessTokenWithResponse(ctx context.Context, projectKey string, tokenId string, body UpdateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessTokenResponse, error)

	// GetAllAccessTokens2WithResponse request
	GetAllAccessTokens2WithResponse(ctx context.Context, userSlug string, params *GetAllAccessTokens2Params, reqEditors ...RequestEditorFn) (*GetAllAccessTokens2Response, error)

	// CreateAccessToken2WithBodyWithResponse request with any body
	CreateAccessToken2WithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessToken2Response, error)

	CreateAccessToken2WithResponse(ctx context.Context, userSlug string, body CreateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessToken2Response, error)

	// DeleteById2WithResponse request
	DeleteById2WithResponse(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteById2Response, error)

	// GetById2WithResponse request
	GetById2WithResponse(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*GetById2Response, error)

	// UpdateAccessToken2WithBodyWithResponse request with any body
	UpdateAccessToken2WithBodyWithResponse(ctx context.Context, userSlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessToken2Response, error)

	UpdateAccessToken2WithResponse(ctx context.Context, userSlug string, tokenId string, body UpdateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessToken2Response, error)

	// GetGlobalSettingsWithResponse request
	GetGlobalSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalSettingsResponse, error)

	// UpdateGlobalSettingsWithBodyWithResponse request with any body
	UpdateGlobalSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalSettingsResponse, error)

	UpdateGlobalSettingsWithResponse(ctx context.Context, body UpdateGlobalSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalSettingsResponse, error)

	// GetSupportedKeyTypesWithResponse request
	GetSupportedKeyTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportedKeyTypesResponse, error)

	// DeleteBannerWithResponse request
	DeleteBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteBannerResponse, error)

	// GetBannerWithResponse request
	GetBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBannerResponse, error)

	// SetBannerWithBodyWithResponse request with any body
	SetBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBannerResponse, error)

	SetBannerWithResponse(ctx context.Context, body SetBannerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBannerResponse, error)

	// GetInformationWithResponse request
	GetInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInformationResponse, error)

	// ClearDefaultBranchWithResponse request
	ClearDefaultBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearDefaultBranchResponse, error)

	// GetDefaultBranchWithResponse request
	GetDefaultBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultBranchResponse, error)

	// SetDefaultBranchWithBodyWithResponse request with any body
	SetDefaultBranchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranchResponse, error)

	SetDefaultBranchWithResponse(ctx context.Context, body SetDefaultBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranchResponse, error)

	// GetControlPlanePublicKeyWithResponse request
	GetControlPlanePublicKeyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetControlPlanePublicKeyResponse, error)

	// ConnectivityWithResponse request
	ConnectivityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConnectivityResponse, error)

	// GetAllRegisteredMeshNodesWithResponse request
	GetAllRegisteredMeshNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllRegisteredMeshNodesResponse, error)

	// RegisterNewMeshNodeWithBodyWithResponse request with any body
	RegisterNewMeshNodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterNewMeshNodeResponse, error)

	RegisterNewMeshNodeWithResponse(ctx context.Context, body RegisterNewMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterNewMeshNodeResponse, error)

	// Delete2WithResponse request
	Delete2WithResponse(ctx context.Context, id int64, params *Delete2Params, reqEditors ...RequestEditorFn) (*Delete2Response, error)

	// GetRegisteredMeshNodeByIdWithResponse request
	GetRegisteredMeshNodeByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegisteredMeshNodeByIdResponse, error)

	// UpdateMeshNodeWithBodyWithResponse request with any body
	UpdateMeshNodeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMeshNodeResponse, error)

	UpdateMeshNodeWithResponse(ctx context.Context, id string, body UpdateMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMeshNodeResponse, error)

	// GetSupportZipsWithResponse request
	GetSupportZipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportZipsResponse, error)

	// GetSupportZipWithResponse request
	GetSupportZipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSupportZipResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroups1WithResponse request
	GetGroups1WithResponse(ctx context.Context, params *GetGroups1Params, reqEditors ...RequestEditorFn) (*GetGroups1Response, error)

	// CreateGroupWithResponse request
	CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// AddUserToGroupWithBodyWithResponse request with any body
	AddUserToGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	AddUserToGroupWithResponse(ctx context.Context, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	// AddUsersToGroupWithBodyWithResponse request with any body
	AddUsersToGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUsersToGroupResponse, error)

	AddUsersToGroupWithResponse(ctx context.Context, body AddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUsersToGroupResponse, error)

	// FindUsersInGroupWithResponse request
	FindUsersInGroupWithResponse(ctx context.Context, params *FindUsersInGroupParams, reqEditors ...RequestEditorFn) (*FindUsersInGroupResponse, error)

	// FindUsersNotInGroupWithResponse request
	FindUsersNotInGroupWithResponse(ctx context.Context, params *FindUsersNotInGroupParams, reqEditors ...RequestEditorFn) (*FindUsersNotInGroupResponse, error)

	// RemoveUserFromGroupWithBodyWithResponse request with any body
	RemoveUserFromGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error)

	RemoveUserFromGroupWithResponse(ctx context.Context, body RemoveUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error)

	// Get2WithResponse request
	Get2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Get2Response, error)

	// UpdateLicenseWithBodyWithResponse request with any body
	UpdateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	UpdateLicenseWithResponse(ctx context.Context, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	// DeleteMailConfigWithResponse request
	DeleteMailConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteMailConfigResponse, error)

	// GetMailConfigWithResponse request
	GetMailConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMailConfigResponse, error)

	// SetMailConfigWithBodyWithResponse request with any body
	SetMailConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMailConfigResponse, error)

	SetMailConfigWithResponse(ctx context.Context, body SetMailConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMailConfigResponse, error)

	// ClearSenderAddressWithResponse request
	ClearSenderAddressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearSenderAddressResponse, error)

	// GetSenderAddressWithResponse request
	GetSenderAddressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSenderAddressResponse, error)

	// SetSenderAddressWithBodyWithResponse request with any body
	SetSenderAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSenderAddressResponse, error)

	SetSenderAddressWithResponse(ctx context.Context, body SetSenderAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSenderAddressResponse, error)

	// RevokePermissionsForGroupWithResponse request
	RevokePermissionsForGroupWithResponse(ctx context.Context, params *RevokePermissionsForGroupParams, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroupResponse, error)

	// GetGroupsWithAnyPermissionWithResponse request
	GetGroupsWithAnyPermissionWithResponse(ctx context.Context, params *GetGroupsWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermissionResponse, error)

	// SetPermissionForGroupsWithResponse request
	SetPermissionForGroupsWithResponse(ctx context.Context, params *SetPermissionForGroupsParams, reqEditors ...RequestEditorFn) (*SetPermissionForGroupsResponse, error)

	// GetGroupsWithoutAnyPermissionWithResponse request
	GetGroupsWithoutAnyPermissionWithResponse(ctx context.Context, params *GetGroupsWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermissionResponse, error)

	// RevokePermissionsForUserWithResponse request
	RevokePermissionsForUserWithResponse(ctx context.Context, params *RevokePermissionsForUserParams, reqEditors ...RequestEditorFn) (*RevokePermissionsForUserResponse, error)

	// GetUsersWithAnyPermissionWithResponse request
	GetUsersWithAnyPermissionWithResponse(ctx context.Context, params *GetUsersWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermissionResponse, error)

	// SetPermissionForUsersWithResponse request
	SetPermissionForUsersWithResponse(ctx context.Context, params *SetPermissionForUsersParams, reqEditors ...RequestEditorFn) (*SetPermissionForUsersResponse, error)

	// GetUsersWithoutAnyPermissionWithResponse request
	GetUsersWithoutAnyPermissionWithResponse(ctx context.Context, params *GetUsersWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithoutAnyPermissionResponse, error)

	// GetMergeConfigWithResponse request
	GetMergeConfigWithResponse(ctx context.Context, scmId string, reqEditors ...RequestEditorFn) (*GetMergeConfigResponse, error)

	// SetMergeConfigWithBodyWithResponse request with any body
	SetMergeConfigWithBodyWithResponse(ctx context.Context, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMergeConfigResponse, error)

	SetMergeConfigWithResponse(ctx context.Context, scmId string, body SetMergeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMergeConfigResponse, error)

	// GetHistoryWithResponse request
	GetHistoryWithResponse(ctx context.Context, params *GetHistoryParams, reqEditors ...RequestEditorFn) (*GetHistoryResponse, error)

	// GetSettings2WithResponse request
	GetSettings2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettings2Response, error)

	// SetSettings2WithBodyWithResponse request with any body
	SetSettings2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettings2Response, error)

	SetSettings2WithResponse(ctx context.Context, body SetSettings2JSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettings2Response, error)

	// GetAllRateLimitSettingsWithResponse request
	GetAllRateLimitSettingsWithResponse(ctx context.Context, params *GetAllRateLimitSettingsParams, reqEditors ...RequestEditorFn) (*GetAllRateLimitSettingsResponse, error)

	// Set2WithBodyWithResponse request with any body
	Set2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set2Response, error)

	Set2WithResponse(ctx context.Context, body Set2JSONRequestBody, reqEditors ...RequestEditorFn) (*Set2Response, error)

	// Delete8WithResponse request
	Delete8WithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*Delete8Response, error)

	// Get6WithResponse request
	Get6WithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*Get6Response, error)

	// Set3WithBodyWithResponse request with any body
	Set3WithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set3Response, error)

	Set3WithResponse(ctx context.Context, userSlug string, body Set3JSONRequestBody, reqEditors ...RequestEditorFn) (*Set3Response, error)

	// GetUserDirectoriesWithResponse request
	GetUserDirectoriesWithResponse(ctx context.Context, params *GetUserDirectoriesParams, reqEditors ...RequestEditorFn) (*GetUserDirectoriesResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUsers1WithResponse request
	GetUsers1WithResponse(ctx context.Context, params *GetUsers1Params, reqEditors ...RequestEditorFn) (*GetUsers1Response, error)

	// CreateUserWithResponse request
	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// UpdateUserDetailsWithBodyWithResponse request with any body
	UpdateUserDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDetailsResponse, error)

	UpdateUserDetailsWithResponse(ctx context.Context, body UpdateUserDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDetailsResponse, error)

	// AddGroupToUserWithBodyWithResponse request with any body
	AddGroupToUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupToUserResponse, error)

	AddGroupToUserWithResponse(ctx context.Context, body AddGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupToUserResponse, error)

	// AddUserToGroupsWithBodyWithResponse request with any body
	AddUserToGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupsResponse, error)

	AddUserToGroupsWithResponse(ctx context.Context, body AddUserToGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupsResponse, error)

	// ClearUserCaptchaChallengeWithResponse request
	ClearUserCaptchaChallengeWithResponse(ctx context.Context, params *ClearUserCaptchaChallengeParams, reqEditors ...RequestEditorFn) (*ClearUserCaptchaChallengeResponse, error)

	// UpdateUserPasswordWithBodyWithResponse request with any body
	UpdateUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithResponse(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	// ValidateErasableWithResponse request
	ValidateErasableWithResponse(ctx context.Context, params *ValidateErasableParams, reqEditors ...RequestEditorFn) (*ValidateErasableResponse, error)

	// EraseUserWithResponse request
	EraseUserWithResponse(ctx context.Context, params *EraseUserParams, reqEditors ...RequestEditorFn) (*EraseUserResponse, error)

	// FindGroupsForUserWithResponse request
	FindGroupsForUserWithResponse(ctx context.Context, params *FindGroupsForUserParams, reqEditors ...RequestEditorFn) (*FindGroupsForUserResponse, error)

	// FindOtherGroupsForUserWithResponse request
	FindOtherGroupsForUserWithResponse(ctx context.Context, params *FindOtherGroupsForUserParams, reqEditors ...RequestEditorFn) (*FindOtherGroupsForUserResponse, error)

	// RemoveGroupFromUserWithBodyWithResponse request with any body
	RemoveGroupFromUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGroupFromUserResponse, error)

	RemoveGroupFromUserWithResponse(ctx context.Context, body RemoveGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGroupFromUserResponse, error)

	// RenameUserWithBodyWithResponse request with any body
	RenameUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameUserResponse, error)

	RenameUserWithResponse(ctx context.Context, body RenameUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameUserResponse, error)

	// GetApplicationPropertiesWithResponse request
	GetApplicationPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationPropertiesResponse, error)

	// GetCapabilitiesWithResponse request
	GetCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCapabilitiesResponse, error)

	// GetPullRequestSuggestionsWithResponse request
	GetPullRequestSuggestionsWithResponse(ctx context.Context, params *GetPullRequestSuggestionsParams, reqEditors ...RequestEditorFn) (*GetPullRequestSuggestionsResponse, error)

	// GetPullRequests1WithResponse request
	GetPullRequests1WithResponse(ctx context.Context, params *GetPullRequests1Params, reqEditors ...RequestEditorFn) (*GetPullRequests1Response, error)

	// GetCapabilities1WithResponse request
	GetCapabilities1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCapabilities1Response, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// CreateHookScriptWithBodyWithResponse request with any body
	CreateHookScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHookScriptResponse, error)

	// DeleteHookScriptWithResponse request
	DeleteHookScriptWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*DeleteHookScriptResponse, error)

	// GetHookScriptWithResponse request
	GetHookScriptWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*GetHookScriptResponse, error)

	// UpdateHookScriptWithBodyWithResponse request with any body
	UpdateHookScriptWithBodyWithResponse(ctx context.Context, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHookScriptResponse, error)

	// ReadWithResponse request
	ReadWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*ReadResponse, error)

	// GetAvatarWithResponse request
	GetAvatarWithResponse(ctx context.Context, hookKey string, params *GetAvatarParams, reqEditors ...RequestEditorFn) (*GetAvatarResponse, error)

	// GetPullRequests2WithResponse request
	GetPullRequests2WithResponse(ctx context.Context, params *GetPullRequests2Params, reqEditors ...RequestEditorFn) (*GetPullRequests2Response, error)

	// GetPullRequestCountWithResponse request
	GetPullRequestCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPullRequestCountResponse, error)

	// GetLabelsWithResponse request
	GetLabelsWithResponse(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error)

	// GetLabelWithResponse request
	GetLabelWithResponse(ctx context.Context, labelName string, reqEditors ...RequestEditorFn) (*GetLabelResponse, error)

	// GetLabelablesWithResponse request
	GetLabelablesWithResponse(ctx context.Context, labelName string, params *GetLabelablesParams, reqEditors ...RequestEditorFn) (*GetLabelablesResponse, error)

	// GetLevelWithResponse request
	GetLevelWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*GetLevelResponse, error)

	// SetLevelWithResponse request
	SetLevelWithResponse(ctx context.Context, loggerName string, levelName string, reqEditors ...RequestEditorFn) (*SetLevelResponse, error)

	// GetRootLevelWithResponse request
	GetRootLevelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootLevelResponse, error)

	// SetRootLevelWithResponse request
	SetRootLevelWithResponse(ctx context.Context, levelName string, reqEditors ...RequestEditorFn) (*SetRootLevelResponse, error)

	// PreviewWithBodyWithResponse request with any body
	PreviewWithBodyWithResponse(ctx context.Context, params *PreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewResponse, error)

	// StartExportWithBodyWithResponse request with any body
	StartExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartExportResponse, error)

	StartExportWithResponse(ctx context.Context, body StartExportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartExportResponse, error)

	// PreviewExportWithBodyWithResponse request with any body
	PreviewExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewExportResponse, error)

	PreviewExportWithResponse(ctx context.Context, body PreviewExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewExportResponse, error)

	// GetExportJobWithResponse request
	GetExportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetExportJobResponse, error)

	// CancelExportJobWithResponse request
	CancelExportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelExportJobResponse, error)

	// GetExportJobMessagesWithResponse request
	GetExportJobMessagesWithResponse(ctx context.Context, jobId string, params *GetExportJobMessagesParams, reqEditors ...RequestEditorFn) (*GetExportJobMessagesResponse, error)

	// StartImportWithBodyWithResponse request with any body
	StartImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartImportResponse, error)

	StartImportWithResponse(ctx context.Context, body StartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartImportResponse, error)

	// GetImportJobWithResponse request
	GetImportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetImportJobResponse, error)

	// CancelImportJobWithResponse request
	CancelImportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelImportJobResponse, error)

	// GetImportJobMessagesWithResponse request
	GetImportJobMessagesWithResponse(ctx context.Context, jobId string, params *GetImportJobMessagesParams, reqEditors ...RequestEditorFn) (*GetImportJobMessagesResponse, error)

	// StartMeshMigrationWithBodyWithResponse request with any body
	StartMeshMigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartMeshMigrationResponse, error)

	StartMeshMigrationWithResponse(ctx context.Context, body StartMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*StartMeshMigrationResponse, error)

	// PreviewMeshMigrationWithBodyWithResponse request with any body
	PreviewMeshMigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewMeshMigrationResponse, error)

	PreviewMeshMigrationWithResponse(ctx context.Context, body PreviewMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewMeshMigrationResponse, error)

	// SearchMeshMigrationReposWithResponse request
	SearchMeshMigrationReposWithResponse(ctx context.Context, params *SearchMeshMigrationReposParams, reqEditors ...RequestEditorFn) (*SearchMeshMigrationReposResponse, error)

	// GetAllMeshMigrationSummariesWithResponse request
	GetAllMeshMigrationSummariesWithResponse(ctx context.Context, params *GetAllMeshMigrationSummariesParams, reqEditors ...RequestEditorFn) (*GetAllMeshMigrationSummariesResponse, error)

	// GetActiveMeshMigrationSummaryWithResponse request
	GetActiveMeshMigrationSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveMeshMigrationSummaryResponse, error)

	// GetMeshMigrationJobWithResponse request
	GetMeshMigrationJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobResponse, error)

	// CancelMeshMigrationJobWithResponse request
	CancelMeshMigrationJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelMeshMigrationJobResponse, error)

	// GetMeshMigrationJobMessagesWithResponse request
	GetMeshMigrationJobMessagesWithResponse(ctx context.Context, jobId string, params *GetMeshMigrationJobMessagesParams, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobMessagesResponse, error)

	// GetMeshMigrationJobSummaryWithResponse request
	GetMeshMigrationJobSummaryWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobSummaryResponse, error)

	// GetRepositoriesRecentlyAccessedWithResponse request
	GetRepositoriesRecentlyAccessedWithResponse(ctx context.Context, params *GetRepositoriesRecentlyAccessedParams, reqEditors ...RequestEditorFn) (*GetRepositoriesRecentlyAccessedResponse, error)

	// GetProjectsWithResponse request
	GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectKey string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// GetProjectAvatarWithResponse request
	GetProjectAvatarWithResponse(ctx context.Context, projectKey string, params *GetProjectAvatarParams, reqEditors ...RequestEditorFn) (*GetProjectAvatarResponse, error)

	// UploadAvatarWithBodyWithResponse request with any body
	UploadAvatarWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAvatarResponse, error)

	// GetConfigurationsWithResponse request
	GetConfigurationsWithResponse(ctx context.Context, projectKey string, params *GetConfigurationsParams, reqEditors ...RequestEditorFn) (*GetConfigurationsResponse, error)

	// RemoveConfigurationWithResponse request
	RemoveConfigurationWithResponse(ctx context.Context, projectKey string, scriptId string, reqEditors ...RequestEditorFn) (*RemoveConfigurationResponse, error)

	// SetConfigurationWithBodyWithResponse request with any body
	SetConfigurationWithBodyWithResponse(ctx context.Context, projectKey string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error)

	SetConfigurationWithResponse(ctx context.Context, projectKey string, scriptId string, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error)

	// RevokePermissionsWithResponse request
	RevokePermissionsWithResponse(ctx context.Context, projectKey string, params *RevokePermissionsParams, reqEditors ...RequestEditorFn) (*RevokePermissionsResponse, error)

	// RevokePermissionsForGroup1WithResponse request
	RevokePermissionsForGroup1WithResponse(ctx context.Context, projectKey string, params *RevokePermissionsForGroup1Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroup1Response, error)

	// GetGroupsWithAnyPermission1WithResponse request
	GetGroupsWithAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetGroupsWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermission1Response, error)

	// SetPermissionForGroups1WithResponse request
	SetPermissionForGroups1WithResponse(ctx context.Context, projectKey string, params *SetPermissionForGroups1Params, reqEditors ...RequestEditorFn) (*SetPermissionForGroups1Response, error)

	// GetGroupsWithoutAnyPermission1WithResponse request
	GetGroupsWithoutAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetGroupsWithoutAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermission1Response, error)

	// SearchPermissionsWithResponse request
	SearchPermissionsWithResponse(ctx context.Context, projectKey string, params *SearchPermissionsParams, reqEditors ...RequestEditorFn) (*SearchPermissionsResponse, error)

	// RevokePermissionsForUser1WithResponse request
	RevokePermissionsForUser1WithResponse(ctx context.Context, projectKey string, params *RevokePermissionsForUser1Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForUser1Response, error)

	// GetUsersWithAnyPermission1WithResponse request
	GetUsersWithAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetUsersWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermission1Response, error)

	// SetPermissionForUsers1WithResponse request
	SetPermissionForUsers1WithResponse(ctx context.Context, projectKey string, params *SetPermissionForUsers1Params, reqEditors ...RequestEditorFn) (*SetPermissionForUsers1Response, error)

	// GetUsersWithoutPermissionWithResponse request
	GetUsersWithoutPermissionWithResponse(ctx context.Context, projectKey string, params *GetUsersWithoutPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithoutPermissionResponse, error)

	// HasAllUserPermissionWithResponse request
	HasAllUserPermissionWithResponse(ctx context.Context, projectKey string, permission string, reqEditors ...RequestEditorFn) (*HasAllUserPermissionResponse, error)

	// ModifyAllUserPermissionWithResponse request
	ModifyAllUserPermissionWithResponse(ctx context.Context, projectKey string, permission string, params *ModifyAllUserPermissionParams, reqEditors ...RequestEditorFn) (*ModifyAllUserPermissionResponse, error)

	// GetRepositoriesWithResponse request
	GetRepositoriesWithResponse(ctx context.Context, projectKey string, params *GetRepositoriesParams, reqEditors ...RequestEditorFn) (*GetRepositoriesResponse, error)

	// CreateRepositoryWithBodyWithResponse request with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, projectKey string, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// DeleteRepositoryWithResponse request
	DeleteRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepositoryWithResponse request
	GetRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// ForkRepositoryWithBodyWithResponse request with any body
	ForkRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForkRepositoryResponse, error)

	ForkRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body ForkRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ForkRepositoryResponse, error)

	// UpdateRepositoryWithBodyWithResponse request with any body
	UpdateRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error)

	UpdateRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error)

	// GetArchiveWithResponse request
	GetArchiveWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetArchiveParams, reqEditors ...RequestEditorFn) (*GetArchiveResponse, error)

	// DeleteAttachmentWithResponse request
	DeleteAttachmentWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error)

	// GetAttachmentWithResponse request
	GetAttachmentWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error)

	// DeleteAttachmentMetadataWithResponse request
	DeleteAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*DeleteAttachmentMetadataResponse, error)

	// GetAttachmentMetadataWithResponse request
	GetAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*GetAttachmentMetadataResponse, error)

	// SaveAttachmentMetadataWithBodyWithResponse request with any body
	SaveAttachmentMetadataWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveAttachmentMetadataResponse, error)

	SaveAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, body SaveAttachmentMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveAttachmentMetadataResponse, error)

	// GetBranchesWithResponse request
	GetBranchesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetBranchesParams, reqEditors ...RequestEditorFn) (*GetBranchesResponse, error)

	// CreateBranchForRepositoryWithBodyWithResponse request with any body
	CreateBranchForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForRepositoryResponse, error)

	CreateBranchForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForRepositoryResponse, error)

	// GetDefaultBranch1WithResponse request
	GetDefaultBranch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetDefaultBranch1Response, error)

	// SetDefaultBranch1WithBodyWithResponse request with any body
	SetDefaultBranch1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranch1Response, error)

	SetDefaultBranch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranch1Response, error)

	// GetContentWithResponse request
	GetContentWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetContentParams, reqEditors ...RequestEditorFn) (*GetContentResponse, error)

	// GetContent1WithResponse request
	GetContent1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetContent1Params, reqEditors ...RequestEditorFn) (*GetContent1Response, error)

	// EditFileWithBodyWithResponse request with any body
	EditFileWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditFileResponse, error)

	// GetChanges1WithResponse request
	GetChanges1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetChanges1Params, reqEditors ...RequestEditorFn) (*GetChanges1Response, error)

	// GetCommitsWithResponse request
	GetCommitsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetCommitsParams, reqEditors ...RequestEditorFn) (*GetCommitsResponse, error)

	// GetCommitWithResponse request
	GetCommitWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommitParams, reqEditors ...RequestEditorFn) (*GetCommitResponse, error)

	// DeleteWithResponse request
	DeleteWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResponse, error)

	// GetWithResponse request
	GetWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetParams, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// AddWithBodyWithResponse request with any body
	AddWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddResponse, error)

	// GetChangesWithResponse request
	GetChangesWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetChangesParams, reqEditors ...RequestEditorFn) (*GetChangesResponse, error)

	// GetCommentsWithResponse request
	GetCommentsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*GetCommentsResponse, error)

	// CreateCommentWithBodyWithResponse request with any body
	CreateCommentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentResponse, error)

	CreateCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentResponse, error)

	// DeleteCommentWithResponse request
	DeleteCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error)

	// GetCommentWithResponse request
	GetCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, reqEditors ...RequestEditorFn) (*GetCommentResponse, error)

	// UpdateCommentWithBodyWithResponse request with any body
	UpdateCommentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error)

	UpdateCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, body UpdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error)

	// Delete1WithResponse request
	Delete1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Delete1Params, reqEditors ...RequestEditorFn) (*Delete1Response, error)

	// Get1WithResponse request
	Get1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Get1Params, reqEditors ...RequestEditorFn) (*Get1Response, error)

	// CreateOrUpdateDeploymentWithBodyWithResponse request with any body
	CreateOrUpdateDeploymentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateDeploymentResponse, error)

	// GetDiffStatsSummaryWithResponse request
	GetDiffStatsSummaryWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *GetDiffStatsSummaryParams, reqEditors ...RequestEditorFn) (*GetDiffStatsSummaryResponse, error)

	// StreamDiffWithResponse request
	StreamDiffWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *StreamDiffParams, reqEditors ...RequestEditorFn) (*StreamDiffResponse, error)

	// GetMergeBaseWithResponse request
	GetMergeBaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetMergeBaseParams, reqEditors ...RequestEditorFn) (*GetMergeBaseResponse, error)

	// GetPullRequestsWithResponse request
	GetPullRequestsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetPullRequestsParams, reqEditors ...RequestEditorFn) (*GetPullRequestsResponse, error)

	// UnwatchWithResponse request
	UnwatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*UnwatchResponse, error)

	// WatchWithResponse request
	WatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*WatchResponse, error)

	// StreamChangesWithResponse request
	StreamChangesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamChangesParams, reqEditors ...RequestEditorFn) (*StreamChangesResponse, error)

	// StreamCommitsWithResponse request
	StreamCommitsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamCommitsParams, reqEditors ...RequestEditorFn) (*StreamCommitsResponse, error)

	// GetDiffStatsSummary1WithResponse request
	GetDiffStatsSummary1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetDiffStatsSummary1Params, reqEditors ...RequestEditorFn) (*GetDiffStatsSummary1Response, error)

	// StreamDiff1WithResponse request
	StreamDiff1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamDiff1Params, reqEditors ...RequestEditorFn) (*StreamDiff1Response, error)

	// StreamContributingWithResponse request
	StreamContributingWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamContributingParams, reqEditors ...RequestEditorFn) (*StreamContributingResponse, error)

	// GetDefaultBranch2WithResponse request
	GetDefaultBranch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetDefaultBranch2Response, error)

	// SetDefaultBranch2WithBodyWithResponse request with any body
	SetDefaultBranch2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranch2Response, error)

	SetDefaultBranch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch2JSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranch2Response, error)

	// StreamRawDiffWithResponse request
	StreamRawDiffWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamRawDiffParams, reqEditors ...RequestEditorFn) (*StreamRawDiffResponse, error)

	// StreamRawDiff1WithResponse request
	StreamRawDiff1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawDiff1Params, reqEditors ...RequestEditorFn) (*StreamRawDiff1Response, error)

	// StreamFilesWithResponse request
	StreamFilesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamFilesParams, reqEditors ...RequestEditorFn) (*StreamFilesResponse, error)

	// StreamFiles1WithResponse request
	StreamFiles1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamFiles1Params, reqEditors ...RequestEditorFn) (*StreamFiles1Response, error)

	// GetForkedRepositoriesWithResponse request
	GetForkedRepositoriesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetForkedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetForkedRepositoriesResponse, error)

	// GetConfigurations1WithResponse request
	GetConfigurations1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetConfigurations1Params, reqEditors ...RequestEditorFn) (*GetConfigurations1Response, error)

	// RemoveConfiguration1WithResponse request
	RemoveConfiguration1WithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, reqEditors ...RequestEditorFn) (*RemoveConfiguration1Response, error)

	// SetConfiguration1WithBodyWithResponse request with any body
	SetConfiguration1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfiguration1Response, error)

	SetConfiguration1WithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, body SetConfiguration1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfiguration1Response, error)

	// GetAllLabelsForRepositoryWithResponse request
	GetAllLabelsForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetAllLabelsForRepositoryResponse, error)

	// AddLabelWithBodyWithResponse request with any body
	AddLabelWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLabelResponse, error)

	AddLabelWithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLabelResponse, error)

	// RemoveLabelWithResponse request
	RemoveLabelWithResponse(ctx context.Context, projectKey string, repositorySlug string, labelName string, reqEditors ...RequestEditorFn) (*RemoveLabelResponse, error)

	// StreamWithResponse request
	StreamWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamParams, reqEditors ...RequestEditorFn) (*StreamResponse, error)

	// Stream1WithResponse request
	Stream1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *Stream1Params, reqEditors ...RequestEditorFn) (*Stream1Response, error)

	// StreamLicenseWithResponse request
	StreamLicenseWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamLicenseParams, reqEditors ...RequestEditorFn) (*StreamLicenseResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// StreamPatchWithResponse request
	StreamPatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamPatchParams, reqEditors ...RequestEditorFn) (*StreamPatchResponse, error)

	// RevokePermissions1WithResponse request
	RevokePermissions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissions1Params, reqEditors ...RequestEditorFn) (*RevokePermissions1Response, error)

	// RevokePermissionsForGroup2WithResponse request
	RevokePermissionsForGroup2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForGroup2Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroup2Response, error)

	// GetGroupsWithAnyPermission2WithResponse request
	GetGroupsWithAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermission2Response, error)

	// SetPermissionForGroupWithResponse request
	SetPermissionForGroupWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForGroupParams, reqEditors ...RequestEditorFn) (*SetPermissionForGroupResponse, error)

	// GetGroupsWithoutAnyPermission2WithResponse request
	GetGroupsWithoutAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithoutAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermission2Response, error)

	// SearchPermissions1WithResponse request
	SearchPermissions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchPermissions1Params, reqEditors ...RequestEditorFn) (*SearchPermissions1Response, error)

	// RevokePermissionsForUser2WithResponse request
	RevokePermissionsForUser2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForUser2Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForUser2Response, error)

	// GetUsersWithAnyPermission2WithResponse request
	GetUsersWithAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermission2Response, error)

	// SetPermissionForUserWithResponse request
	SetPermissionForUserWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForUserParams, reqEditors ...RequestEditorFn) (*SetPermissionForUserResponse, error)

	// GetUsersWithoutPermission1WithResponse request
	GetUsersWithoutPermission1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithoutPermission1Params, reqEditors ...RequestEditorFn) (*GetUsersWithoutPermission1Response, error)

	// GetPageWithResponse request
	GetPageWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetPageParams, reqEditors ...RequestEditorFn) (*GetPageResponse, error)

	// CreateWithBodyWithResponse request with any body
	CreateWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// Delete3WithBodyWithResponse request with any body
	Delete3WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Delete3Response, error)

	Delete3WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body Delete3JSONRequestBody, reqEditors ...RequestEditorFn) (*Delete3Response, error)

	// Get3WithResponse request
	Get3WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Get3Response, error)

	// UpdateWithBodyWithResponse request with any body
	UpdateWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	UpdateWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	// StreamRawDiff2WithResponse request
	StreamRawDiff2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamRawDiff2Params, reqEditors ...RequestEditorFn) (*StreamRawDiff2Response, error)

	// StreamPatch1WithResponse request
	StreamPatch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*StreamPatch1Response, error)

	// GetActivitiesWithResponse request
	GetActivitiesWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error)

	// WithdrawApprovalWithResponse request
	WithdrawApprovalWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*WithdrawApprovalResponse, error)

	// ApproveWithResponse request
	ApproveWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*ApproveResponse, error)

	// CancelAutoMergeWithResponse request
	CancelAutoMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CancelAutoMergeResponse, error)

	// GetAutoMergeRequestWithResponse request
	GetAutoMergeRequestWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetAutoMergeRequestResponse, error)

	// TryAutoMergeWithResponse request
	TryAutoMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*TryAutoMergeResponse, error)

	// GetComments1WithResponse request
	GetComments1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments1Params, reqEditors ...RequestEditorFn) (*GetComments1Response, error)

	// CreateComment1WithBodyWithResponse request with any body
	CreateComment1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComment1Response, error)

	CreateComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComment1Response, error)

	// DeleteComment1WithResponse request
	DeleteComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment1Params, reqEditors ...RequestEditorFn) (*DeleteComment1Response, error)

	// GetComment1WithResponse request
	GetComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*GetComment1Response, error)

	// UpdateComment1WithBodyWithResponse request with any body
	UpdateComment1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComment1Response, error)

	UpdateComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComment1Response, error)

	// StreamChanges1WithResponse request
	StreamChanges1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamChanges1Params, reqEditors ...RequestEditorFn) (*StreamChanges1Response, error)

	// GetComments2WithResponse request
	GetComments2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments2Params, reqEditors ...RequestEditorFn) (*GetComments2Response, error)

	// CreateComment2WithBodyWithResponse request with any body
	CreateComment2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComment2Response, error)

	CreateComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComment2Response, error)

	// DeleteComment2WithResponse request
	DeleteComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment2Params, reqEditors ...RequestEditorFn) (*DeleteComment2Response, error)

	// GetComment2WithResponse request
	GetComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*GetComment2Response, error)

	// UpdateComment2WithBodyWithResponse request with any body
	UpdateComment2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComment2Response, error)

	UpdateComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComment2Response, error)

	// ApplySuggestionWithBodyWithResponse request with any body
	ApplySuggestionWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplySuggestionResponse, error)

	ApplySuggestionWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body ApplySuggestionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySuggestionResponse, error)

	// GetCommitMessageSuggestionWithResponse request
	GetCommitMessageSuggestionWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetCommitMessageSuggestionResponse, error)

	// GetCommits1WithResponse request
	GetCommits1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetCommits1Params, reqEditors ...RequestEditorFn) (*GetCommits1Response, error)

	// DeclineWithBodyWithResponse request with any body
	DeclineWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineResponse, error)

	DeclineWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, body DeclineJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineResponse, error)

	// GetDiffStatsSummary2WithResponse request
	GetDiffStatsSummary2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *GetDiffStatsSummary2Params, reqEditors ...RequestEditorFn) (*GetDiffStatsSummary2Response, error)

	// StreamDiff2WithResponse request
	StreamDiff2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *StreamDiff2Params, reqEditors ...RequestEditorFn) (*StreamDiff2Response, error)

	// CanMergeWithResponse request
	CanMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CanMergeResponse, error)

	// MergeWithBodyWithResponse request with any body
	MergeWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeResponse, error)

	MergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, body MergeJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeResponse, error)

	// GetMergeBase1WithResponse request
	GetMergeBase1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetMergeBase1Response, error)

	// UnassignParticipantRole1WithResponse request
	UnassignParticipantRole1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *UnassignParticipantRole1Params, reqEditors ...RequestEditorFn) (*UnassignParticipantRole1Response, error)

	// ListParticipantsWithResponse request
	ListParticipantsWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ListParticipantsParams, reqEditors ...RequestEditorFn) (*ListParticipantsResponse, error)

	// AssignParticipantRoleWithBodyWithResponse request with any body
	AssignParticipantRoleWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignParticipantRoleResponse, error)

	AssignParticipantRoleWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body AssignParticipantRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignParticipantRoleResponse, error)

	// UnassignParticipantRoleWithResponse request
	UnassignParticipantRoleWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, reqEditors ...RequestEditorFn) (*UnassignParticipantRoleResponse, error)

	// UpdateStatusWithBodyWithResponse request with any body
	UpdateStatusWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error)

	UpdateStatusWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error)

	// ReopenWithBodyWithResponse request with any body
	ReopenWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReopenResponse, error)

	ReopenWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, body ReopenJSONRequestBody, reqEditors ...RequestEditorFn) (*ReopenResponse, error)

	// DiscardReviewWithResponse request
	DiscardReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*DiscardReviewResponse, error)

	// GetReviewWithResponse request
	GetReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetReviewParams, reqEditors ...RequestEditorFn) (*GetReviewResponse, error)

	// FinishReviewWithBodyWithResponse request with any body
	FinishReviewWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FinishReviewResponse, error)

	FinishReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, body FinishReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*FinishReviewResponse, error)

	// Unwatch1WithResponse request
	Unwatch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Unwatch1Response, error)

	// Watch1WithResponse request
	Watch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Watch1Response, error)

	// StreamRawWithResponse request
	StreamRawWithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawParams, reqEditors ...RequestEditorFn) (*StreamRawResponse, error)

	// StreamReadmeWithResponse request
	StreamReadmeWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamReadmeParams, reqEditors ...RequestEditorFn) (*StreamReadmeResponse, error)

	// RetryCreateRepositoryWithResponse request
	RetryCreateRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*RetryCreateRepositoryResponse, error)

	// GetRefChangeActivityWithResponse request
	GetRefChangeActivityWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRefChangeActivityParams, reqEditors ...RequestEditorFn) (*GetRefChangeActivityResponse, error)

	// FindBranchesWithResponse request
	FindBranchesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *FindBranchesParams, reqEditors ...RequestEditorFn) (*FindBranchesResponse, error)

	// GetRelatedRepositoriesWithResponse request
	GetRelatedRepositoriesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRelatedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetRelatedRepositoriesResponse, error)

	// Search2WithResponse request
	Search2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *Search2Params, reqEditors ...RequestEditorFn) (*Search2Response, error)

	// CreateAllowlistRule1WithBodyWithResponse request with any body
	CreateAllowlistRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistRule1Response, error)

	// DeleteAllowlistRule1WithResponse request
	DeleteAllowlistRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteAllowlistRule1Response, error)

	// GetAllowlistRule1WithResponse request
	GetAllowlistRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetAllowlistRule1Response, error)

	// EditAllowlistRule1WithBodyWithResponse request with any body
	EditAllowlistRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAllowlistRule1Response, error)

	// Search3WithResponse request
	Search3WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *Search3Params, reqEditors ...RequestEditorFn) (*Search3Response, error)

	// CreateRule1WithBodyWithResponse request with any body
	CreateRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRule1Response, error)

	// DeleteRule1WithResponse request
	DeleteRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteRule1Response, error)

	// GetRule1WithResponse request
	GetRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetRule1Response, error)

	// EditRule1WithBodyWithResponse request with any body
	EditRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRule1Response, error)

	// DeleteAutoDeclineSettings1WithResponse request
	DeleteAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteAutoDeclineSettings1Response, error)

	// GetAutoDeclineSettings1WithResponse request
	GetAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetAutoDeclineSettings1Response, error)

	// SetAutoDeclineSettings1WithBodyWithResponse request with any body
	SetAutoDeclineSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettings1Response, error)

	SetAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetAutoDeclineSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettings1Response, error)

	// Delete5WithResponse request
	Delete5WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Delete5Response, error)

	// Get5WithResponse request
	Get5WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Get5Response, error)

	// Set1WithBodyWithResponse request with any body
	Set1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set1Response, error)

	Set1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Set1JSONRequestBody, reqEditors ...RequestEditorFn) (*Set1Response, error)

	// GetRepositoryHooks1WithResponse request
	GetRepositoryHooks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRepositoryHooks1Params, reqEditors ...RequestEditorFn) (*GetRepositoryHooks1Response, error)

	// DeleteRepositoryHookWithResponse request
	DeleteRepositoryHookWithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*DeleteRepositoryHookResponse, error)

	// GetRepositoryHook1WithResponse request
	GetRepositoryHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*GetRepositoryHook1Response, error)

	// DisableHook1WithResponse request
	DisableHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*DisableHook1Response, error)

	// EnableHook1WithResponse request
	EnableHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, params *EnableHook1Params, reqEditors ...RequestEditorFn) (*EnableHook1Response, error)

	// GetSettings1WithResponse request
	GetSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*GetSettings1Response, error)

	// SetSettings1WithBodyWithResponse request with any body
	SetSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettings1Response, error)

	SetSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, body SetSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettings1Response, error)

	// GetPullRequestSettings1WithResponse request
	GetPullRequestSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetPullRequestSettings1Response, error)

	// UpdatePullRequestSettings1WithBodyWithResponse request with any body
	UpdatePullRequestSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettings1Response, error)

	UpdatePullRequestSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body UpdatePullRequestSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettings1Response, error)

	// GetReviewerGroups1WithResponse request
	GetReviewerGroups1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewerGroups1Params, reqEditors ...RequestEditorFn) (*GetReviewerGroups1Response, error)

	// Create2WithBodyWithResponse request with any body
	Create2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create2Response, error)

	Create2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*Create2Response, error)

	// Delete7WithResponse request
	Delete7WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*Delete7Response, error)

	// GetReviewerGroup1WithResponse request
	GetReviewerGroup1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetReviewerGroup1Response, error)

	// Update2WithBodyWithResponse request with any body
	Update2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Update2Response, error)

	Update2WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, body Update2JSONRequestBody, reqEditors ...RequestEditorFn) (*Update2Response, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// CreateTagForRepositoryWithBodyWithResponse request with any body
	CreateTagForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagForRepositoryResponse, error)

	CreateTagForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateTagForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagForRepositoryResponse, error)

	// GetTagWithResponse request
	GetTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// Unwatch2WithResponse request
	Unwatch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Unwatch2Response, error)

	// Watch2WithBodyWithResponse request with any body
	Watch2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Watch2Response, error)

	Watch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Watch2JSONRequestBody, reqEditors ...RequestEditorFn) (*Watch2Response, error)

	// FindWebhooks1WithResponse request
	FindWebhooks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *FindWebhooks1Params, reqEditors ...RequestEditorFn) (*FindWebhooks1Response, error)

	// CreateWebhook1WithBodyWithResponse request with any body
	CreateWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhook1Response, error)

	CreateWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhook1Response, error)

	// SearchWebhooksWithResponse request
	SearchWebhooksWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchWebhooksParams, reqEditors ...RequestEditorFn) (*SearchWebhooksResponse, error)

	// TestWebhook1WithBodyWithResponse request with any body
	TestWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhook1Response, error)

	TestWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, body TestWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhook1Response, error)

	// DeleteWebhook1WithResponse request
	DeleteWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhook1Response, error)

	// GetWebhook1WithResponse request
	GetWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetWebhook1Params, reqEditors ...RequestEditorFn) (*GetWebhook1Response, error)

	// UpdateWebhook1WithBodyWithResponse request with any body
	UpdateWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhook1Response, error)

	UpdateWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, body UpdateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhook1Response, error)

	// GetLatestInvocation1WithResponse request
	GetLatestInvocation1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetLatestInvocation1Params, reqEditors ...RequestEditorFn) (*GetLatestInvocation1Response, error)

	// GetStatistics1WithResponse request
	GetStatistics1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetStatistics1Params, reqEditors ...RequestEditorFn) (*GetStatistics1Response, error)

	// GetStatisticsSummary1WithResponse request
	GetStatisticsSummary1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*GetStatisticsSummary1Response, error)

	// SearchAllowlistRuleWithResponse request
	SearchAllowlistRuleWithResponse(ctx context.Context, projectKey string, params *SearchAllowlistRuleParams, reqEditors ...RequestEditorFn) (*SearchAllowlistRuleResponse, error)

	// CreateAllowlistRuleWithBodyWithResponse request with any body
	CreateAllowlistRuleWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistRuleResponse, error)

	// DeleteAllowlistRuleWithResponse request
	DeleteAllowlistRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteAllowlistRuleResponse, error)

	// GetAllowlistRuleWithResponse request
	GetAllowlistRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetAllowlistRuleResponse, error)

	// EditAllowlistRuleWithBodyWithResponse request with any body
	EditAllowlistRuleWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAllowlistRuleResponse, error)

	// Search1WithResponse request
	Search1WithResponse(ctx context.Context, projectKey string, params *Search1Params, reqEditors ...RequestEditorFn) (*Search1Response, error)

	// CreateRuleWithBodyWithResponse request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleWithResponse request
	GetRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetRuleResponse, error)

	// EditRuleWithBodyWithResponse request with any body
	EditRuleWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRuleResponse, error)

	// Delete9WithResponse request
	Delete9WithResponse(ctx context.Context, projectKey string, params *Delete9Params, reqEditors ...RequestEditorFn) (*Delete9Response, error)

	// Get7WithResponse request
	Get7WithResponse(ctx context.Context, projectKey string, params *Get7Params, reqEditors ...RequestEditorFn) (*Get7Response, error)

	// Create3WithBodyWithResponse request with any body
	Create3WithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create3Response, error)

	Create3WithResponse(ctx context.Context, projectKey string, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*Create3Response, error)

	// GetAllWithResponse request
	GetAllWithResponse(ctx context.Context, projectKey string, params *GetAllParams, reqEditors ...RequestEditorFn) (*GetAllResponse, error)

	// DeleteAutoDeclineSettingsWithResponse request
	DeleteAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteAutoDeclineSettingsResponse, error)

	// GetAutoDeclineSettingsWithResponse request
	GetAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetAutoDeclineSettingsResponse, error)

	// SetAutoDeclineSettingsWithBodyWithResponse request with any body
	SetAutoDeclineSettingsWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettingsResponse, error)

	SetAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, body SetAutoDeclineSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettingsResponse, error)

	// Delete4WithResponse request
	Delete4WithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*Delete4Response, error)

	// Get4WithResponse request
	Get4WithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*Get4Response, error)

	// SetWithBodyWithResponse request with any body
	SetWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetResponse, error)

	SetWithResponse(ctx context.Context, projectKey string, body SetJSONRequestBody, reqEditors ...RequestEditorFn) (*SetResponse, error)

	// GetRepositoryHooksWithResponse request
	GetRepositoryHooksWithResponse(ctx context.Context, projectKey string, params *GetRepositoryHooksParams, reqEditors ...RequestEditorFn) (*GetRepositoryHooksResponse, error)

	// GetRepositoryHookWithResponse request
	GetRepositoryHookWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*GetRepositoryHookResponse, error)

	// DisableHookWithResponse request
	DisableHookWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*DisableHookResponse, error)

	// EnableHookWithResponse request
	EnableHookWithResponse(ctx context.Context, projectKey string, hookKey string, params *EnableHookParams, reqEditors ...RequestEditorFn) (*EnableHookResponse, error)

	// GetSettingsWithResponse request
	GetSettingsWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// SetSettingsWithBodyWithResponse request with any body
	SetSettingsWithBodyWithResponse(ctx context.Context, projectKey string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettingsResponse, error)

	SetSettingsWithResponse(ctx context.Context, projectKey string, hookKey string, body SetSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettingsResponse, error)

	// GetPullRequestSettingsWithResponse request
	GetPullRequestSettingsWithResponse(ctx context.Context, projectKey string, scmId string, reqEditors ...RequestEditorFn) (*GetPullRequestSettingsResponse, error)

	// UpdatePullRequestSettingsWithBodyWithResponse request with any body
	UpdatePullRequestSettingsWithBodyWithResponse(ctx context.Context, projectKey string, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettingsResponse, error)

	UpdatePullRequestSettingsWithResponse(ctx context.Context, projectKey string, scmId string, body UpdatePullRequestSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettingsResponse, error)

	// GetReviewerGroupsWithResponse request
	GetReviewerGroupsWithResponse(ctx context.Context, projectKey string, params *GetReviewerGroupsParams, reqEditors ...RequestEditorFn) (*GetReviewerGroupsResponse, error)

	// Create1WithBodyWithResponse request with any body
	Create1WithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create1Response, error)

	Create1WithResponse(ctx context.Context, projectKey string, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*Create1Response, error)

	// Delete6WithResponse request
	Delete6WithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*Delete6Response, error)

	// GetReviewerGroupWithResponse request
	GetReviewerGroupWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetReviewerGroupResponse, error)

	// Update1WithBodyWithResponse request with any body
	Update1WithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Update1Response, error)

	Update1WithResponse(ctx context.Context, projectKey string, id string, body Update1JSONRequestBody, reqEditors ...RequestEditorFn) (*Update1Response, error)

	// FindWebhooksWithResponse request
	FindWebhooksWithResponse(ctx context.Context, projectKey string, params *FindWebhooksParams, reqEditors ...RequestEditorFn) (*FindWebhooksResponse, error)

	// CreateWebhookWithBodyWithResponse request with any body
	CreateWebhookWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	CreateWebhookWithResponse(ctx context.Context, projectKey string, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	// TestWebhookWithBodyWithResponse request with any body
	TestWebhookWithBodyWithResponse(ctx context.Context, projectKey string, params *TestWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error)

	TestWebhookWithResponse(ctx context.Context, projectKey string, params *TestWebhookParams, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// UpdateWebhookWithBodyWithResponse request with any body
	UpdateWebhookWithBodyWithResponse(ctx context.Context, projectKey string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	// GetLatestInvocationWithResponse request
	GetLatestInvocationWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetLatestInvocationParams, reqEditors ...RequestEditorFn) (*GetLatestInvocationResponse, error)

	// GetStatisticsWithResponse request
	GetStatisticsWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetStatisticsParams, reqEditors ...RequestEditorFn) (*GetStatisticsResponse, error)

	// GetStatisticsSummaryWithResponse request
	GetStatisticsSummaryWithResponse(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*GetStatisticsSummaryResponse, error)

	// GetRepositories1WithResponse request
	GetRepositories1WithResponse(ctx context.Context, params *GetRepositories1Params, reqEditors ...RequestEditorFn) (*GetRepositories1Response, error)

	// FindExemptReposByScopeWithResponse request
	FindExemptReposByScopeWithResponse(ctx context.Context, params *FindExemptReposByScopeParams, reqEditors ...RequestEditorFn) (*FindExemptReposByScopeResponse, error)

	// BulkAddExemptRepositoriesWithBodyWithResponse request with any body
	BulkAddExemptRepositoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddExemptRepositoriesResponse, error)

	// Search4WithResponse request
	Search4WithResponse(ctx context.Context, params *Search4Params, reqEditors ...RequestEditorFn) (*Search4Response, error)

	// CreateRule2WithBodyWithResponse request with any body
	CreateRule2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRule2Response, error)

	// DeleteRule2WithResponse request
	DeleteRule2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRule2Response, error)

	// GetRule2WithResponse request
	GetRule2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRule2Response, error)

	// EditRule2WithBodyWithResponse request with any body
	EditRule2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRule2Response, error)

	// GetAllCertificatesWithResponse request
	GetAllCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCertificatesResponse, error)

	// CreateCertificateWithBodyWithResponse request with any body
	CreateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error)

	// UpdateCertificateRevocationListEntriesWithResponse request
	UpdateCertificateRevocationListEntriesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UpdateCertificateRevocationListEntriesResponse, error)

	// DeleteCertificateWithResponse request
	DeleteCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCertificateResponse, error)

	// GetSystemSigningConfigurationWithResponse request
	GetSystemSigningConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSigningConfigurationResponse, error)

	// UpdateSystemSigningConfigurationWithBodyWithResponse request with any body
	UpdateSystemSigningConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemSigningConfigurationResponse, error)

	UpdateSystemSigningConfigurationWithResponse(ctx context.Context, body UpdateSystemSigningConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemSigningConfigurationResponse, error)

	// GetUsers2WithResponse request
	GetUsers2WithResponse(ctx context.Context, params *GetUsers2Params, reqEditors ...RequestEditorFn) (*GetUsers2Response, error)

	// UpdateUserDetails1WithBodyWithResponse request with any body
	UpdateUserDetails1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDetails1Response, error)

	UpdateUserDetails1WithResponse(ctx context.Context, body UpdateUserDetails1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDetails1Response, error)

	// UpdateUserPassword1WithBodyWithResponse request with any body
	UpdateUserPassword1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPassword1Response, error)

	UpdateUserPassword1WithResponse(ctx context.Context, body UpdateUserPassword1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPassword1Response, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// DeleteAvatarWithResponse request
	DeleteAvatarWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*DeleteAvatarResponse, error)

	// UploadAvatar1WithBodyWithResponse request with any body
	UploadAvatar1WithBodyWithResponse(ctx context.Context, userSlug string, params *UploadAvatar1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAvatar1Response, error)

	// GetUserSettingsWithResponse request
	GetUserSettingsWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error)

	// UpdateSettingsWithBodyWithResponse request with any body
	UpdateSettingsWithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error)

	UpdateSettingsWithResponse(ctx context.Context, userSlug string, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error)

	// DismissRetentionConfigReviewNotificationWithResponse request
	DismissRetentionConfigReviewNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DismissRetentionConfigReviewNotificationResponse, error)

	// GetRestrictions1WithResponse request
	GetRestrictions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRestrictions1Params, reqEditors ...RequestEditorFn) (*GetRestrictions1Response, error)

	// CreateRestrictions1WithBodyWithResponse request with any body
	CreateRestrictions1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestrictions1Response, error)

	CreateRestrictions1WithApplicationVndAtlBitbucketBulkPlusJSONBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestrictions1Response, error)

	// DeleteRestriction1WithResponse request
	DeleteRestriction1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteRestriction1Response, error)

	// GetRestriction1WithResponse request
	GetRestriction1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetRestriction1Response, error)

	// GetRestrictionsWithResponse request
	GetRestrictionsWithResponse(ctx context.Context, projectKey string, params *GetRestrictionsParams, reqEditors ...RequestEditorFn) (*GetRestrictionsResponse, error)

	// CreateRestrictionsWithBodyWithResponse request with any body
	CreateRestrictionsWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestrictionsResponse, error)

	CreateRestrictionsWithApplicationVndAtlBitbucketBulkPlusJSONBodyWithResponse(ctx context.Context, projectKey string, body CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestrictionsResponse, error)

	// DeleteRestrictionWithResponse request
	DeleteRestrictionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteRestrictionResponse, error)

	// GetRestrictionWithResponse request
	GetRestrictionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetRestrictionResponse, error)

	// DeleteBranchWithBodyWithResponse request with any body
	DeleteBranchWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	DeleteBranchWithResponse(ctx context.Context, projectKey string, repositorySlug string, body DeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	// CreateBranchWithBodyWithResponse request with any body
	CreateBranchWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	CreateBranchWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	// FindByCommitWithResponse request
	FindByCommitWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *FindByCommitParams, reqEditors ...RequestEditorFn) (*FindByCommitResponse, error)

	// GetMultipleBuildStatusStatsWithBodyWithResponse request with any body
	GetMultipleBuildStatusStatsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMultipleBuildStatusStatsResponse, error)

	GetMultipleBuildStatusStatsWithResponse(ctx context.Context, body GetMultipleBuildStatusStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMultipleBuildStatusStatsResponse, error)

	// GetBuildStatusStatsWithResponse request
	GetBuildStatusStatsWithResponse(ctx context.Context, commitId string, params *GetBuildStatusStatsParams, reqEditors ...RequestEditorFn) (*GetBuildStatusStatsResponse, error)

	// GetBuildStatusWithResponse request
	GetBuildStatusWithResponse(ctx context.Context, commitId string, params *GetBuildStatusParams, reqEditors ...RequestEditorFn) (*GetBuildStatusResponse, error)

	// AddBuildStatusWithBodyWithResponse request with any body
	AddBuildStatusWithBodyWithResponse(ctx context.Context, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuildStatusResponse, error)

	AddBuildStatusWithResponse(ctx context.Context, commitId string, body AddBuildStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuildStatusResponse, error)

	// UnReactWithResponse request
	UnReactWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*UnReactResponse, error)

	// ReactWithResponse request
	ReactWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*ReactResponse, error)

	// UnReact1WithResponse request
	UnReact1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*UnReact1Response, error)

	// React1WithResponse request
	React1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*React1Response, error)

	// CreatePullRequestConditionWithBodyWithResponse request with any body
	CreatePullRequestConditionWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestConditionResponse, error)

	CreatePullRequestConditionWithResponse(ctx context.Context, projectKey string, body CreatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestConditionResponse, error)

	// DeletePullRequestConditionWithResponse request
	DeletePullRequestConditionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeletePullRequestConditionResponse, error)

	// UpdatePullRequestConditionWithBodyWithResponse request with any body
	UpdatePullRequestConditionWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestConditionResponse, error)

	UpdatePullRequestConditionWithResponse(ctx context.Context, projectKey string, id string, body UpdatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestConditionResponse, error)

	// GetPullRequestConditionsWithResponse request
	GetPullRequestConditionsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetPullRequestConditionsResponse, error)

	// CreatePullRequestCondition1WithBodyWithResponse request with any body
	CreatePullRequestCondition1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestCondition1Response, error)

	CreatePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestCondition1Response, error)

	// DeletePullRequestCondition1WithResponse request
	DeletePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id int32, reqEditors ...RequestEditorFn) (*DeletePullRequestCondition1Response, error)

	// UpdatePullRequestCondition1WithBodyWithResponse request with any body
	UpdatePullRequestCondition1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestCondition1Response, error)

	UpdatePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, body UpdatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestCondition1Response, error)

	// GetPullRequestConditions1WithResponse request
	GetPullRequestConditions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetPullRequestConditions1Response, error)

	// GetReviewersWithResponse request
	GetReviewersWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewersParams, reqEditors ...RequestEditorFn) (*GetReviewersResponse, error)

	// DeleteAllDefaultTasks1WithResponse request
	DeleteAllDefaultTasks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteAllDefaultTasks1Response, error)

	// GetDefaultTasks1WithResponse request
	GetDefaultTasks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetDefaultTasks1Params, reqEditors ...RequestEditorFn) (*GetDefaultTasks1Response, error)

	// AddDefaultTask1WithBodyWithResponse request with any body
	AddDefaultTask1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultTask1Response, error)

	AddDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultTask1Response, error)

	// DeleteDefaultTask1WithResponse request
	DeleteDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, reqEditors ...RequestEditorFn) (*DeleteDefaultTask1Response, error)

	// UpdateDefaultTask1WithBodyWithResponse request with any body
	UpdateDefaultTask1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDefaultTask1Response, error)

	UpdateDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, body UpdateDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDefaultTask1Response, error)

	// DeleteAllDefaultTasksWithResponse request
	DeleteAllDefaultTasksWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteAllDefaultTasksResponse, error)

	// GetDefaultTasksWithResponse request
	GetDefaultTasksWithResponse(ctx context.Context, projectKey string, params *GetDefaultTasksParams, reqEditors ...RequestEditorFn) (*GetDefaultTasksResponse, error)

	// AddDefaultTaskWithBodyWithResponse request with any body
	AddDefaultTaskWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultTaskResponse, error)

	AddDefaultTaskWithResponse(ctx context.Context, projectKey string, body AddDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultTaskResponse, error)

	// DeleteDefaultTaskWithResponse request
	DeleteDefaultTaskWithResponse(ctx context.Context, projectKey string, taskId string, reqEditors ...RequestEditorFn) (*DeleteDefaultTaskResponse, error)

	// UpdateDefaultTaskWithBodyWithResponse request with any body
	UpdateDefaultTaskWithBodyWithResponse(ctx context.Context, projectKey string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDefaultTaskResponse, error)

	UpdateDefaultTaskWithResponse(ctx context.Context, projectKey string, taskId string, body UpdateDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDefaultTaskResponse, error)

	// CanRebaseWithResponse request
	CanRebaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CanRebaseResponse, error)

	// RebaseWithBodyWithResponse request with any body
	RebaseWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebaseResponse, error)

	RebaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body RebaseJSONRequestBody, reqEditors ...RequestEditorFn) (*RebaseResponse, error)

	// CreateTagWithBodyWithResponse request with any body
	CreateTagWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// DeleteForUserWithResponse request
	DeleteForUserWithResponse(ctx context.Context, params *DeleteForUserParams, reqEditors ...RequestEditorFn) (*DeleteForUserResponse, error)

	// GetKeysForUserWithResponse request
	GetKeysForUserWithResponse(ctx context.Context, params *GetKeysForUserParams, reqEditors ...RequestEditorFn) (*GetKeysForUserResponse, error)

	// AddKeyWithBodyWithResponse request with any body
	AddKeyWithBodyWithResponse(ctx context.Context, params *AddKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddKeyResponse, error)

	AddKeyWithResponse(ctx context.Context, params *AddKeyParams, body AddKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddKeyResponse, error)

	// DeleteKeyWithResponse request
	DeleteKeyWithResponse(ctx context.Context, fingerprintOrId string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error)

	// GetAnnotations1WithResponse request
	GetAnnotations1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetAnnotations1Params, reqEditors ...RequestEditorFn) (*GetAnnotations1Response, error)

	// GetReportsWithResponse request
	GetReportsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetReportsParams, reqEditors ...RequestEditorFn) (*GetReportsResponse, error)

	// DeleteACodeInsightsReportWithResponse request
	DeleteACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*DeleteACodeInsightsReportResponse, error)

	// GetACodeInsightsReportWithResponse request
	GetACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*GetACodeInsightsReportResponse, error)

	// SetACodeInsightsReportWithBodyWithResponse request with any body
	SetACodeInsightsReportWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetACodeInsightsReportResponse, error)

	SetACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body SetACodeInsightsReportJSONRequestBody, reqEditors ...RequestEditorFn) (*SetACodeInsightsReportResponse, error)

	// DeleteAnnotationsWithResponse request
	DeleteAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, params *DeleteAnnotationsParams, reqEditors ...RequestEditorFn) (*DeleteAnnotationsResponse, error)

	// GetAnnotationsWithResponse request
	GetAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*GetAnnotationsResponse, error)

	// AddAnnotationsWithBodyWithResponse request with any body
	AddAnnotationsWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAnnotationsResponse, error)

	AddAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body AddAnnotationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAnnotationsResponse, error)

	// SetAnnotationWithBodyWithResponse request with any body
	SetAnnotationWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAnnotationResponse, error)

	SetAnnotationWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, body SetAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAnnotationResponse, error)

	// CreateIssueWithBodyWithResponse request with any body
	CreateIssueWithBodyWithResponse(ctx context.Context, commentId string, params *CreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIssueResponse, error)

	CreateIssueWithResponse(ctx context.Context, commentId string, params *CreateIssueParams, body CreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIssueResponse, error)

	// GetCommitsByIssueKeyWithResponse request
	GetCommitsByIssueKeyWithResponse(ctx context.Context, issueKey string, params *GetCommitsByIssueKeyParams, reqEditors ...RequestEditorFn) (*GetCommitsByIssueKeyResponse, error)

	// GetEnhancedEntityLinkForProjectWithResponse request
	GetEnhancedEntityLinkForProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetEnhancedEntityLinkForProjectResponse, error)

	// GetIssueKeysForPullRequestWithResponse request
	GetIssueKeysForPullRequestWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetIssueKeysForPullRequestResponse, error)

	// GetForRepository1WithResponse request
	GetForRepository1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetForRepository1Params, reqEditors ...RequestEditorFn) (*GetForRepository1Response, error)

	// AddForRepositoryWithBodyWithResponse request with any body
	AddForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddForRepositoryResponse, error)

	AddForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddForRepositoryResponse, error)

	// RevokeForRepositoryWithResponse request
	RevokeForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*RevokeForRepositoryResponse, error)

	// GetForRepositoryWithResponse request
	GetForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*GetForRepositoryResponse, error)

	// UpdatePermission1WithResponse request
	UpdatePermission1WithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, permission string, reqEditors ...RequestEditorFn) (*UpdatePermission1Response, error)

	// GetSshKeysForProjectWithResponse request
	GetSshKeysForProjectWithResponse(ctx context.Context, projectKey string, params *GetSshKeysForProjectParams, reqEditors ...RequestEditorFn) (*GetSshKeysForProjectResponse, error)

	// AddForProjectWithBodyWithResponse request with any body
	AddForProjectWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddForProjectResponse, error)

	AddForProjectWithResponse(ctx context.Context, projectKey string, body AddForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AddForProjectResponse, error)

	// RevokeForProjectWithResponse request
	RevokeForProjectWithResponse(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*RevokeForProjectResponse, error)

	// GetForProjectWithResponse request
	GetForProjectWithResponse(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*GetForProjectResponse, error)

	// UpdatePermissionWithResponse request
	UpdatePermissionWithResponse(ctx context.Context, projectKey string, keyId string, permission string, reqEditors ...RequestEditorFn) (*UpdatePermissionResponse, error)

	// RevokeManyWithBodyWithResponse request with any body
	RevokeManyWithBodyWithResponse(ctx context.Context, keyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeManyResponse, error)

	RevokeManyWithResponse(ctx context.Context, keyId string, body RevokeManyJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeManyResponse, error)

	// GetForProjectsWithResponse request
	GetForProjectsWithResponse(ctx context.Context, keyId int32, reqEditors ...RequestEditorFn) (*GetForProjectsResponse, error)

	// GetForRepositoriesWithResponse request
	GetForRepositoriesWithResponse(ctx context.Context, keyId string, params *GetForRepositoriesParams, reqEditors ...RequestEditorFn) (*GetForRepositoriesResponse, error)

	// DeletePreferredMirrorIdWithResponse request
	DeletePreferredMirrorIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeletePreferredMirrorIdResponse, error)

	// GetPreferredMirrorIdWithResponse request
	GetPreferredMirrorIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPreferredMirrorIdResponse, error)

	// SetPreferredMirrorIdWithBodyWithResponse request with any body
	SetPreferredMirrorIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPreferredMirrorIdResponse, error)

	SetPreferredMirrorIdWithResponse(ctx context.Context, body SetPreferredMirrorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPreferredMirrorIdResponse, error)

	// AnalyticsSettingsWithResponse request
	AnalyticsSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AnalyticsSettingsResponse, error)

	// AuthenticateWithBodyWithResponse request with any body
	AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error)

	AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error)

	// GetFarmNodesWithResponse request
	GetFarmNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFarmNodesResponse, error)

	// GetMirroredRepositoryWithResponse request
	GetMirroredRepositoryWithResponse(ctx context.Context, externalRepositoryId string, reqEditors ...RequestEditorFn) (*GetMirroredRepositoryResponse, error)

	// ListMirrorsWithResponse request
	ListMirrorsWithResponse(ctx context.Context, params *ListMirrorsParams, reqEditors ...RequestEditorFn) (*ListMirrorsResponse, error)

	// RemoveWithResponse request
	RemoveWithResponse(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*RemoveResponse, error)

	// GetMirrorWithResponse request
	GetMirrorWithResponse(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*GetMirrorResponse, error)

	// UpgradeWithBodyWithResponse request with any body
	UpgradeWithBodyWithResponse(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeResponse, error)

	UpgradeWithResponse(ctx context.Context, mirrorId string, body UpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeResponse, error)

	// PublishEventWithBodyWithResponse request with any body
	PublishEventWithBodyWithResponse(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishEventResponse, error)

	PublishEventWithResponse(ctx context.Context, mirrorId string, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishEventResponse, error)

	// GetSynchronizationProgressWithResponse request
	GetSynchronizationProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSynchronizationProgressResponse, error)

	// GetProjectByIdWithResponse request
	GetProjectByIdWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectByIdResponse, error)

	// GetAllReposForProjectWithResponse request
	GetAllReposForProjectWithResponse(ctx context.Context, projectId string, params *GetAllReposForProjectParams, reqEditors ...RequestEditorFn) (*GetAllReposForProjectResponse, error)

	// GetAllContentHashesWithResponse request
	GetAllContentHashesWithResponse(ctx context.Context, params *GetAllContentHashesParams, reqEditors ...RequestEditorFn) (*GetAllContentHashesResponse, error)

	// GetContentHashByIdWithResponse request
	GetContentHashByIdWithResponse(ctx context.Context, repoId string, params *GetContentHashByIdParams, reqEditors ...RequestEditorFn) (*GetContentHashByIdResponse, error)

	// GetRepositoryMirrorsWithResponse request
	GetRepositoryMirrorsWithResponse(ctx context.Context, repoId string, params *GetRepositoryMirrorsParams, reqEditors ...RequestEditorFn) (*GetRepositoryMirrorsResponse, error)

	// ListRequestsWithResponse request
	ListRequestsWithResponse(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*ListRequestsResponse, error)

	// RegisterWithBodyWithResponse request with any body
	RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	// DeleteMirroringRequestWithResponse request
	DeleteMirroringRequestWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*DeleteMirroringRequestResponse, error)

	// GetMirroringRequestWithResponse request
	GetMirroringRequestWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*GetMirroringRequestResponse, error)

	// AcceptWithResponse request
	AcceptWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*AcceptResponse, error)

	// RejectWithResponse request
	RejectWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*RejectResponse, error)

	// GetOutOfSyncRepositoriesWithResponse request
	GetOutOfSyncRepositoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutOfSyncRepositoriesResponse, error)

	// GetRepositoryLockOwnerWithResponse request
	GetRepositoryLockOwnerWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepositoryLockOwnerResponse, error)

	// GetRepoSyncStatus1WithResponse request
	GetRepoSyncStatus1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepoSyncStatus1Response, error)

	// GetRefChangesQueueWithResponse request
	GetRefChangesQueueWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefChangesQueueResponse, error)

	// GetRefChangesQueueCountWithResponse request
	GetRefChangesQueueCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefChangesQueueCountResponse, error)

	// GetRepositoryLockOwnersWithResponse request
	GetRepositoryLockOwnersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryLockOwnersResponse, error)

	// GetRepoSyncStatusWithResponse request
	GetRepoSyncStatusWithResponse(ctx context.Context, params *GetRepoSyncStatusParams, reqEditors ...RequestEditorFn) (*GetRepoSyncStatusResponse, error)

	// GetMirrorSettingsWithResponse request
	GetMirrorSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirrorSettingsResponse, error)

	// SetMirrorSettingsWithBodyWithResponse request with any body
	SetMirrorSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMirrorSettingsResponse, error)

	SetMirrorSettingsWithResponse(ctx context.Context, body SetMirrorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMirrorSettingsResponse, error)

	// GetMirrorModeWithResponse request
	GetMirrorModeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirrorModeResponse, error)

	// SetMirrorModeWithBodyWithResponse request with any body
	SetMirrorModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMirrorModeResponse, error)

	SetMirrorModeWithResponse(ctx context.Context, body SetMirrorModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMirrorModeResponse, error)

	// GetMirroredProjectsWithResponse request
	GetMirroredProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirroredProjectsResponse, error)

	// StartMirroringProjectsWithBodyWithResponse request with any body
	StartMirroringProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartMirroringProjectsResponse, error)

	StartMirroringProjectsWithResponse(ctx context.Context, body StartMirroringProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*StartMirroringProjectsResponse, error)

	// StopMirroringProjectWithResponse request
	StopMirroringProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*StopMirroringProjectResponse, error)

	// StartMirroringProjectWithResponse request
	StartMirroringProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*StartMirroringProjectResponse, error)

	// GetUpstreamServerWithResponse request
	GetUpstreamServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpstreamServerResponse, error)

	// EndRollingUpgradeWithResponse request
	EndRollingUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EndRollingUpgradeResponse, error)

	// StartRollingUpgradeWithResponse request
	StartRollingUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StartRollingUpgradeResponse, error)

	// GetRepositoryArchivePolicyWithResponse request
	GetRepositoryArchivePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryArchivePolicyResponse, error)

	// SetRepositoryArchivePolicyWithBodyWithResponse request with any body
	SetRepositoryArchivePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryArchivePolicyResponse, error)

	SetRepositoryArchivePolicyWithResponse(ctx context.Context, body SetRepositoryArchivePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryArchivePolicyResponse, error)

	// GetRepositoryDeletePolicyWithResponse request
	GetRepositoryDeletePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryDeletePolicyResponse, error)

	// SetRepositoryDeletePolicyWithBodyWithResponse request with any body
	SetRepositoryDeletePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryDeletePolicyResponse, error)

	SetRepositoryDeletePolicyWithResponse(ctx context.Context, body SetRepositoryDeletePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryDeletePolicyResponse, error)

	// CreateRequiredBuildsMergeCheckWithBodyWithResponse request with any body
	CreateRequiredBuildsMergeCheckWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequiredBuildsMergeCheckResponse, error)

	// DeleteRequiredBuildsMergeCheckWithResponse request
	DeleteRequiredBuildsMergeCheckWithResponse(ctx context.Context, projectKey string, repositorySlug string, id int64, reqEditors ...RequestEditorFn) (*DeleteRequiredBuildsMergeCheckResponse, error)

	// UpdateRequiredBuildsMergeCheckWithBodyWithResponse request with any body
	UpdateRequiredBuildsMergeCheckWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequiredBuildsMergeCheckResponse, error)

	// GetPageOfRequiredBuildsMergeChecksWithResponse request
	GetPageOfRequiredBuildsMergeChecksWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetPageOfRequiredBuildsMergeChecksParams, reqEditors ...RequestEditorFn) (*GetPageOfRequiredBuildsMergeChecksResponse, error)

	// DeleteSshKeysWithResponse request
	DeleteSshKeysWithResponse(ctx context.Context, params *DeleteSshKeysParams, reqEditors ...RequestEditorFn) (*DeleteSshKeysResponse, error)

	// GetSshKeysWithResponse request
	GetSshKeysWithResponse(ctx context.Context, params *GetSshKeysParams, reqEditors ...RequestEditorFn) (*GetSshKeysResponse, error)

	// AddSshKeyWithBodyWithResponse request with any body
	AddSshKeyWithBodyWithResponse(ctx context.Context, params *AddSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error)

	AddSshKeyWithResponse(ctx context.Context, params *AddSshKeyParams, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error)

	// DeleteSshKeyWithResponse request
	DeleteSshKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error)

	// GetSshKeyWithResponse request
	GetSshKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*GetSshKeyResponse, error)

	// SshSettingsWithResponse request
	SshSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SshSettingsResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// SetEnabledWithBodyWithResponse request with any body
	SetEnabledWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEnabledResponse, error)

	SetEnabledWithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEnabledResponse, error)

	// SynchronizeWithBodyWithResponse request with any body
	SynchronizeWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SynchronizeResponse, error)

	SynchronizeWithResponse(ctx context.Context, projectKey string, repositorySlug string, body SynchronizeJSONRequestBody, reqEditors ...RequestEditorFn) (*SynchronizeResponse, error)
}

type GetAllAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestAccessToken `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRawAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccessTokens1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestAccessToken `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllAccessTokens1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessTokens1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessToken1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRawAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAccessToken1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessToken1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteById1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteById1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteById1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetById1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetById1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetById1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessToken1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAccessToken1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessToken1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAccessTokens2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestAccessToken `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllAccessTokens2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAccessTokens2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessToken2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRawAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAccessToken2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessToken2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteById2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteById2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteById2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetById2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetById2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetById2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessToken2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAccessToken
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAccessToken2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessToken2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshKeySettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGlobalSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGlobalSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateGlobalSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGlobalSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportedKeyTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSupportedKeyTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportedKeyTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteBannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAnnouncementBanner
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetBannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestClusterInformation
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearDefaultBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ClearDefaultBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearDefaultBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetDefaultBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControlPlanePublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetControlPlanePublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControlPlanePublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshConnectivityReport
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRegisteredMeshNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshNode
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllRegisteredMeshNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRegisteredMeshNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterNewMeshNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshNode
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterNewMeshNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterNewMeshNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Delete2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegisteredMeshNodeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshNode
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRegisteredMeshNodeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegisteredMeshNodeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMeshNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshNode
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateMeshNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMeshNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportZipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetSupportZipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportZipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportZipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RestErrors
	JSON404      *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetSupportZipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportZipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroups1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestDetailedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroups1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroups1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUsersToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddUsersToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUsersToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUsersInGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestDetailedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindUsersInGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUsersInGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUsersNotInGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestDetailedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindUsersNotInGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUsersNotInGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBitbucketLicense
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBitbucketLicense
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMailConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMailConfiguration
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMailConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMailConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMailConfiguration
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetMailConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMailConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearSenderAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ClearSenderAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearSenderAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSenderAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSenderAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSenderAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSenderAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetSenderAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSenderAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithAnyPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestPermittedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithAnyPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithAnyPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithoutAnyPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestDetailedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithoutAnyPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithoutAnyPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithAnyPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestPermittedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithAnyPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithAnyPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithoutAnyPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                  `json:"isLastPage,omitempty"`
		Limit         *float32               `json:"limit,omitempty"`
		NextPageStart *int32                 `json:"nextPageStart,omitempty"`
		Size          *float32               `json:"size,omitempty"`
		Start         *int32                 `json:"start,omitempty"`
		Values        *[]RestApplicationUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithoutAnyPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithoutAnyPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMergeConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestMergeConfig
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMergeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMergeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMergeConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestMergeConfig
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetMergeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMergeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                         `json:"isLastPage,omitempty"`
		Limit         *float32                      `json:"limit,omitempty"`
		NextPageStart *int32                        `json:"nextPageStart,omitempty"`
		Size          *float32                      `json:"size,omitempty"`
		Start         *int32                        `json:"start,omitempty"`
		Values        *[]RestAggregateRejectCounter `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettings2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRateLimitSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettings2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettings2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSettings2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRateLimitSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetSettings2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSettings2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRateLimitSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                        `json:"isLastPage,omitempty"`
		Limit         *float32                     `json:"limit,omitempty"`
		NextPageStart *int32                       `json:"nextPageStart,omitempty"`
		Size          *float32                     `json:"size,omitempty"`
		Start         *int32                       `json:"start,omitempty"`
		Values        *[]RestUserRateLimitSettings `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllRateLimitSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRateLimitSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Set2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserRateLimitSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Set2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Set2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserRateLimitSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Set3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserRateLimitSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Set3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Set3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDirectoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserDirectory
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserDirectoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDirectoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsers1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestDetailedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsers1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsers1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateUserDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddGroupToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearUserCaptchaChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ClearUserCaptchaChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearUserCaptchaChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateErasableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ValidateErasableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateErasableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EraseUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestErasedUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EraseUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EraseUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGroupsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestDetailedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindGroupsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGroupsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOtherGroupsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestDetailedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindOtherGroupsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOtherGroupsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveGroupFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveGroupFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveGroupFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RenameUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestApplicationProperties
}

// Status returns HTTPResponse.Status
func (r GetApplicationPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBuildCapabilities
}

// Status returns HTTPResponse.Status
func (r GetCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestSuggestionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                        `json:"isLastPage,omitempty"`
		Limit         *float32                     `json:"limit,omitempty"`
		NextPageStart *int32                       `json:"nextPageStart,omitempty"`
		Size          *float32                     `json:"size,omitempty"`
		Start         *int32                       `json:"start,omitempty"`
		Values        *[]RestPullRequestSuggestion `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPullRequestSuggestionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestSuggestionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequests1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestPullRequest `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPullRequests1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequests1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCapabilities1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCapabilities1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCapabilities1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool     `json:"isLastPage,omitempty"`
		Limit         *float32  `json:"limit,omitempty"`
		NextPageStart *int32    `json:"nextPageStart,omitempty"`
		Size          *float32  `json:"size,omitempty"`
		Start         *int32    `json:"start,omitempty"`
		Values        *[]string `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHookScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestHookScript
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateHookScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHookScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHookScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteHookScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHookScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHookScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestHookScript
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHookScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHookScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHookScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestHookScript
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON422 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateHookScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHookScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequests2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPullRequests2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequests2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPullRequestCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool        `json:"isLastPage,omitempty"`
		Limit         *float32     `json:"limit,omitempty"`
		NextPageStart *int32       `json:"nextPageStart,omitempty"`
		Size          *float32     `json:"size,omitempty"`
		Start         *int32       `json:"start,omitempty"`
		Values        *[]RestLabel `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestLabel
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabelablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool            `json:"isLastPage,omitempty"`
		Limit         *float32         `json:"limit,omitempty"`
		NextPageStart *int32           `json:"nextPageStart,omitempty"`
		Size          *float32         `json:"size,omitempty"`
		Start         *int32           `json:"start,omitempty"`
		Values        *[]RestLabelable `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLabelablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabelablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestLogLevel
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestLogLevel
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRootLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRootLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetRootLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRootLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMarkup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestJob
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON503 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestScopesExample
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PreviewExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestJob
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelExportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelExportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelExportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportJobMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestJobMessage `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExportJobMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportJobMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestJob
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON503 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestJob
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportJobMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestJobMessage `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetImportJobMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportJobMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartMeshMigrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestJob
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON503 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartMeshMigrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartMeshMigrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewMeshMigrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExamplePreviewMigration
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PreviewMeshMigrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewMeshMigrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMeshMigrationReposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                      `json:"isLastPage,omitempty"`
		Limit         *float32                   `json:"limit,omitempty"`
		NextPageStart *int32                     `json:"nextPageStart,omitempty"`
		Size          *float32                   `json:"size,omitempty"`
		Start         *int32                     `json:"start,omitempty"`
		Values        *[]RestMigrationRepository `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchMeshMigrationReposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMeshMigrationReposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllMeshMigrationSummariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                       `json:"isLastPage,omitempty"`
		Limit         *float32                    `json:"limit,omitempty"`
		NextPageStart *int32                      `json:"nextPageStart,omitempty"`
		Size          *float32                    `json:"size,omitempty"`
		Start         *int32                      `json:"start,omitempty"`
		Values        *[]RestMeshMigrationSummary `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllMeshMigrationSummariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllMeshMigrationSummariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveMeshMigrationSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshMigrationSummary
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetActiveMeshMigrationSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveMeshMigrationSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeshMigrationJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMeshMigrationJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeshMigrationJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelMeshMigrationJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelMeshMigrationJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelMeshMigrationJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeshMigrationJobMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestJobMessage `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMeshMigrationJobMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeshMigrationJobMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeshMigrationJobSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMeshMigrationSummary
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMeshMigrationJobSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeshMigrationJobSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesRecentlyAccessedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesRecentlyAccessedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesRecentlyAccessedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool          `json:"isLastPage,omitempty"`
		Limit         *float32       `json:"limit,omitempty"`
		NextPageStart *int32         `json:"nextPageStart,omitempty"`
		Size          *float32       `json:"size,omitempty"`
		Start         *int32         `json:"start,omitempty"`
		Values        *[]RestProject `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestProject
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestProject
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestProject
	JSON201      *RestProject
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                   `json:"isLastPage,omitempty"`
		Limit         *float32                `json:"limit,omitempty"`
		NextPageStart *int32                  `json:"nextPageStart,omitempty"`
		Size          *float32                `json:"size,omitempty"`
		Start         *int32                  `json:"start,omitempty"`
		Values        *[]RestHookScriptConfig `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestHookScriptConfig
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForGroup1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForGroup1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForGroup1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithAnyPermission1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestPermittedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithAnyPermission1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithAnyPermission1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForGroups1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForGroups1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForGroups1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithoutAnyPermission1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestDetailedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithoutAnyPermission1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithoutAnyPermission1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForUser1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForUser1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForUser1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithAnyPermission1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestPermittedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithAnyPermission1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithAnyPermission1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForUsers1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForUsers1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForUsers1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithoutPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                  `json:"isLastPage,omitempty"`
		Limit         *float32               `json:"limit,omitempty"`
		NextPageStart *int32                 `json:"nextPageStart,omitempty"`
		Size          *float32               `json:"size,omitempty"`
		Start         *int32                 `json:"start,omitempty"`
		Values        *[]RestApplicationUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithoutPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithoutPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HasAllUserPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPermitted
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r HasAllUserPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HasAllUserPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyAllUserPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ModifyAllUserPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyAllUserPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestRepository
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepository
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForkRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestRepository
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ForkRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForkRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestRepository
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArchiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttachmentMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAttachmentMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttachmentMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAttachmentMetadata
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAttachmentMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveAttachmentMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SaveAttachmentMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveAttachmentMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestBranch `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBranch
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBranchForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultBranch1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBranch
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultBranch1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultBranch1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultBranch1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetDefaultBranch1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultBranch1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContent1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContent1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContent1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommit
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChanges1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestChange `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetChanges1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChanges1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestCommit `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommit
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBuildStatus
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestChange `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool          `json:"isLastPage,omitempty"`
		Limit         *float32       `json:"limit,omitempty"`
		NextPageStart *int32         `json:"nextPageStart,omitempty"`
		Size          *float32       `json:"size,omitempty"`
		Start         *int32         `json:"start,omitempty"`
		Values        *[]RestComment `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDeployment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDeployment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiffStatsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiffStatsSummary
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDiffStatsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiffStatsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiff
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMergeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommit
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMergeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMergeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestPullRequest `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnwatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UnwatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnwatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestChange `json:"values,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestCommit `json:"values,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiffStatsSummary1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiff
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDiffStatsSummary1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiffStatsSummary1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamDiff1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiff
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamDiff1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamDiff1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamContributingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamContributingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamContributingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultBranch2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMinimalRef
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultBranch2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultBranch2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultBranch2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetDefaultBranch2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultBranch2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRawDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamRawDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRawDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRawDiff1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamRawDiff1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRawDiff1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]FileListResource `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFiles1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]FileListResource `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamFiles1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFiles1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForkedRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForkedRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForkedRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurations1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                   `json:"isLastPage,omitempty"`
		Limit         *float32                `json:"limit,omitempty"`
		NextPageStart *int32                  `json:"nextPageStart,omitempty"`
		Size          *float32                `json:"size,omitempty"`
		Start         *int32                  `json:"start,omitempty"`
		Values        *[]RestHookScriptConfig `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConfigurations1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurations1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveConfiguration1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveConfiguration1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveConfiguration1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetConfiguration1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestHookScriptConfig
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetConfiguration1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetConfiguration1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLabelsForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestLabel
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllLabelsForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLabelsForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestLabel
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleFiles
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Stream1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleFiles
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Stream1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Stream1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                  `json:"isLastPage,omitempty"`
		Limit         *float32               `json:"limit,omitempty"`
		NextPageStart *int32                 `json:"nextPageStart,omitempty"`
		Size          *float32               `json:"size,omitempty"`
		Start         *int32                 `json:"start,omitempty"`
		Values        *[]RestApplicationUser `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForGroup2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForGroup2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForGroup2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithAnyPermission2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestPermittedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithAnyPermission2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithAnyPermission2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsWithoutAnyPermission2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestDetailedGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupsWithoutAnyPermission2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsWithoutAnyPermission2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPermissions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchPermissions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPermissions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsForUser2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsForUser2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsForUser2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithAnyPermission2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestPermittedUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithAnyPermission2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithAnyPermission2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPermissionForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPermissionForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPermissionForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithoutPermission1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                  `json:"isLastPage,omitempty"`
		Limit         *float32               `json:"limit,omitempty"`
		NextPageStart *int32                 `json:"nextPageStart,omitempty"`
		Size          *float32               `json:"size,omitempty"`
		Start         *int32                 `json:"start,omitempty"`
		Values        *[]RestApplicationUser `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersWithoutPermission1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithoutPermission1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestPullRequest `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestPullRequest
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequest
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequest
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRawDiff2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamRawDiff2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRawDiff2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamPatch1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamPatch1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamPatch1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                      `json:"isLastPage,omitempty"`
		Limit         *float32                   `json:"limit,omitempty"`
		NextPageStart *int32                     `json:"nextPageStart,omitempty"`
		Size          *float32                   `json:"size,omitempty"`
		Start         *int32                     `json:"start,omitempty"`
		Values        *[]RestPullRequestActivity `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawApprovalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestParticipant
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WithdrawApprovalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawApprovalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestParticipant
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ApproveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelAutoMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelAutoMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelAutoMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoMergeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeRequest
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAutoMergeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoMergeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TryAutoMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeProcessingResult
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TryAutoMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TryAutoMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComments1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool          `json:"isLastPage,omitempty"`
		Limit         *float32       `json:"limit,omitempty"`
		NextPageStart *int32         `json:"nextPageStart,omitempty"`
		Size          *float32       `json:"size,omitempty"`
		Start         *int32         `json:"start,omitempty"`
		Values        *[]RestComment `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComments1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComments1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComment1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateComment1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComment1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComment1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteComment1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComment1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComment1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComment1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComment1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComment1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateComment1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComment1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamChanges1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestChange
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamChanges1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamChanges1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComments2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool          `json:"isLastPage,omitempty"`
		Limit         *float32       `json:"limit,omitempty"`
		NextPageStart *int32         `json:"nextPageStart,omitempty"`
		Size          *float32       `json:"size,omitempty"`
		Start         *int32         `json:"start,omitempty"`
		Values        *[]RestComment `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComments2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComments2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComment2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateComment2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComment2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComment2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteComment2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComment2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComment2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComment2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComment2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComment2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestComment
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateComment2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComment2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApplySuggestionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ApplySuggestionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplySuggestionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitMessageSuggestionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommitMessageSuggestion
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommitMessageSuggestionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitMessageSuggestionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommits1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestCommit `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommits1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommits1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequest
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeclineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiffStatsSummary2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiffStatsSummary
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDiffStatsSummary2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiffStatsSummary2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamDiff2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDiff
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamDiff2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamDiff2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CanMergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestMergeability
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CanMergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CanMergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequest
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMergeBase1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommit
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMergeBase1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMergeBase1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignParticipantRole1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UnassignParticipantRole1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignParticipantRole1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                         `json:"isLastPage,omitempty"`
		Limit         *float32                      `json:"limit,omitempty"`
		NextPageStart *int32                        `json:"nextPageStart,omitempty"`
		Size          *float32                      `json:"size,omitempty"`
		Start         *int32                        `json:"start,omitempty"`
		Values        *[]RestPullRequestParticipant `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignParticipantRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestParticipant
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssignParticipantRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignParticipantRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignParticipantRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UnassignParticipantRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignParticipantRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestParticipant
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReopenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequest
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReopenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReopenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscardReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DiscardReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscardReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool          `json:"isLastPage,omitempty"`
		Limit         *float32       `json:"limit,omitempty"`
		NextPageStart *int32         `json:"nextPageStart,omitempty"`
		Size          *float32       `json:"size,omitempty"`
		Start         *int32         `json:"start,omitempty"`
		Values        *[]RestComment `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FinishReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FinishReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FinishReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Unwatch1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Unwatch1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Unwatch1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Watch1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Watch1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Watch1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamRawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamReadmeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StreamReadmeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamReadmeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryCreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepository
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RetryCreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryCreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefChangeActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                              `json:"isLastPage,omitempty"`
		Limit         *float32                           `json:"limit,omitempty"`
		NextPageStart *int32                             `json:"nextPageStart,omitempty"`
		Size          *float32                           `json:"size,omitempty"`
		Start         *int32                             `json:"start,omitempty"`
		Values        *[]RestRepositoryRefChangeActivity `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRefChangeActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefChangeActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestMinimalRef `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRelatedRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRelatedRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRelatedRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                              `json:"isLastPage,omitempty"`
		Limit         *float32                           `json:"limit,omitempty"`
		NextPageStart *int32                             `json:"nextPageStart,omitempty"`
		Size          *float32                           `json:"size,omitempty"`
		Start         *int32                             `json:"start,omitempty"`
		Values        *[]RestSecretScanningAllowlistRule `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Search2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAllowlistRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAllowlistRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAllowlistRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllowlistRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAllowlistRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllowlistRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllowlistRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllowlistRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllowlistRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAllowlistRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditAllowlistRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAllowlistRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                     `json:"isLastPage,omitempty"`
		Limit         *float32                  `json:"limit,omitempty"`
		NextPageStart *int32                    `json:"nextPageStart,omitempty"`
		Size          *float32                  `json:"size,omitempty"`
		Start         *int32                    `json:"start,omitempty"`
		Values        *[]RestSecretScanningRule `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Search3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditRule1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditRule1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditRule1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAutoDeclineSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAutoDeclineSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAutoDeclineSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoDeclineSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoDeclineSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAutoDeclineSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoDeclineSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoDeclineSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoDeclineSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetAutoDeclineSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoDeclineSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeRestrictedSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Set1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeRestrictedSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON403 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Set1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Set1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryHooks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestRepositoryHook `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryHooks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryHooks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryHook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryHook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryHook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableHook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableHook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableHook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableHook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableHook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableHook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPullRequestSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPullRequestSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestSettings1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPullRequestSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestSettings1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestSettings1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewerGroups1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestReviewerGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReviewerGroups1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewerGroups1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestReviewerGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Create2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewerGroup1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestReviewerGroup
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReviewerGroup1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewerGroup1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Update2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestReviewerGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Update2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Update2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]RestApplicationUser
	ApplicationjsonCharsetUTF8401 *RestErrors
	ApplicationjsonCharsetUTF8404 *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool      `json:"isLastPage,omitempty"`
		Limit         *float32   `json:"limit,omitempty"`
		NextPageStart *int32     `json:"nextPageStart,omitempty"`
		Size          *float32   `json:"size,omitempty"`
		Start         *int32     `json:"start,omitempty"`
		Values        *[]RestTag `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestTag
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTagForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestTag
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Unwatch2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Unwatch2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Unwatch2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Watch2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Watch2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Watch2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWebhooks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindWebhooks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWebhooks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWebhook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestWebhook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhookRequestResponse
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TestWebhook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestWebhook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWebhook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWebhook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhook1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWebhook1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhook1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestInvocation1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedInvocation
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLatestInvocation1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestInvocation1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatistics1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInvocationHistory
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatistics1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatistics1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsSummary1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInvocationHistory
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsSummary1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsSummary1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAllowlistRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                              `json:"isLastPage,omitempty"`
		Limit         *float32                           `json:"limit,omitempty"`
		NextPageStart *int32                             `json:"nextPageStart,omitempty"`
		Size          *float32                           `json:"size,omitempty"`
		Start         *int32                             `json:"start,omitempty"`
		Values        *[]RestSecretScanningAllowlistRule `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchAllowlistRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAllowlistRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAllowlistRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAllowlistRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAllowlistRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllowlistRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAllowlistRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllowlistRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllowlistRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllowlistRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllowlistRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAllowlistRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningAllowlistRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditAllowlistRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAllowlistRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                     `json:"isLastPage,omitempty"`
		Limit         *float32                  `json:"limit,omitempty"`
		NextPageStart *int32                    `json:"nextPageStart,omitempty"`
		Size          *float32                  `json:"size,omitempty"`
		Start         *int32                    `json:"start,omitempty"`
		Values        *[]RestSecretScanningRule `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Search1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete9Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete9Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete9Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestProjectSettingsRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestProjectSettingsRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Create3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                             `json:"isLastPage,omitempty"`
		Limit         *float32                          `json:"limit,omitempty"`
		NextPageStart *int32                            `json:"nextPageStart,omitempty"`
		Size          *float32                          `json:"size,omitempty"`
		Start         *int32                            `json:"start,omitempty"`
		Values        *[]RestProjectSettingsRestriction `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAutoDeclineSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAutoDeclineSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAutoDeclineSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoDeclineSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoDeclineSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAutoDeclineSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoDeclineSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoDeclineSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoDeclineSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetAutoDeclineSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoDeclineSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Get4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeRestrictedSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Get4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Get4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAutoMergeRestrictedSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestRepositoryHook `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryHook
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPullRequestSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestSettings
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestReviewerGroup `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReviewerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestReviewerGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Create1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Delete6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Delete6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Delete6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestReviewerGroup
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReviewerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Update1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestReviewerGroup
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Update1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Update1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhookRequestResponse
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TestWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestWebhook
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestInvocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDetailedInvocation
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLatestInvocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestInvocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInvocationHistory
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInvocationHistory
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositories1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositories1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositories1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindExemptReposByScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestRepository `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindExemptReposByScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindExemptReposByScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddExemptRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddExemptRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddExemptRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Search4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                     `json:"isLastPage,omitempty"`
		Limit         *float32                  `json:"limit,omitempty"`
		NextPageStart *int32                    `json:"nextPageStart,omitempty"`
		Size          *float32                  `json:"size,omitempty"`
		Start         *int32                    `json:"start,omitempty"`
		Values        *[]RestSecretScanningRule `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r Search4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Search4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRule2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRule2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRule2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRule2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRule2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRule2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRule2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRule2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRule2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditRule2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSecretScanningRule
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditRule2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditRule2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestX509Certificate
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestX509Certificate
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCertificateRevocationListEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCertificateRevocationListEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCertificateRevocationListEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *RestX509Certificate
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSigningConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSystemSigningConfiguration
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSystemSigningConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSigningConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSystemSigningConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSystemSigningConfiguration
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateSystemSigningConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSystemSigningConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsers2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestApplicationUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsers2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsers2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserDetails1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestApplicationUser
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateUserDetails1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserDetails1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPassword1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateUserPassword1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPassword1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestApplicationUser
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestNamedLink
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAvatar1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadAvatar1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAvatar1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExampleSettingsMap
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DismissRetentionConfigReviewNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DismissRetentionConfigReviewNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DismissRetentionConfigReviewNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestrictions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestRefRestriction `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRestrictions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestrictions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRestrictions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRestrictions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRestrictions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRestriction1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRestriction1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRestriction1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestriction1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRestriction1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestriction1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]RestRefRestriction `json:"values,omitempty"`
	}
	JSON400 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRestrictionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRestrictionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRestrictionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRestrictionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefRestriction
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRestrictionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRestrictionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestBranch
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindByCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool             `json:"isLastPage,omitempty"`
		Limit         *float32          `json:"limit,omitempty"`
		NextPageStart *int32            `json:"nextPageStart,omitempty"`
		Size          *float32          `json:"size,omitempty"`
		Start         *int32            `json:"start,omitempty"`
		Values        *[]RestMinimalRef `json:"values,omitempty"`
	}
	JSON500 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FindByCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindByCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleBuildStatusStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMultipleBuildStats
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMultipleBuildStatusStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleBuildStatusStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildStatusStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestBuildStats
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBuildStatusStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildStatusStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestBuildStatus `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBuildStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBuildStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddBuildStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBuildStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnReactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnReactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnReactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserReaction
}

// Status returns HTTPResponse.Status
func (r ReactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnReact1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnReact1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnReact1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type React1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUserReaction
}

// Status returns HTTPResponse.Status
func (r React1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r React1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePullRequestConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePullRequestConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePullRequestConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePullRequestConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePullRequestConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePullRequestConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RestPullRequestCondition
}

// Status returns HTTPResponse.Status
func (r GetPullRequestConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePullRequestCondition1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePullRequestCondition1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePullRequestCondition1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePullRequestCondition1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePullRequestCondition1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePullRequestCondition1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePullRequestCondition1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePullRequestCondition1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePullRequestCondition1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestConditions1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RestPullRequestCondition
}

// Status returns HTTPResponse.Status
func (r GetPullRequestConditions1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestConditions1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReviewersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RestPullRequestCondition
	JSON400      *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetReviewersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReviewersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllDefaultTasks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAllDefaultTasks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllDefaultTasks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultTasks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestDefaultTask `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultTasks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultTasks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDefaultTask1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDefaultTask
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDefaultTask1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDefaultTask1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDefaultTask1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDefaultTask1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDefaultTask1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDefaultTask1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDefaultTask
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDefaultTask1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDefaultTask1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllDefaultTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAllDefaultTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllDefaultTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool              `json:"isLastPage,omitempty"`
		Limit         *float32           `json:"limit,omitempty"`
		NextPageStart *int32             `json:"nextPageStart,omitempty"`
		Size          *float32           `json:"size,omitempty"`
		Start         *int32             `json:"start,omitempty"`
		Values        *[]RestDefaultTask `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDefaultTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDefaultTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDefaultTask
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddDefaultTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDefaultTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDefaultTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDefaultTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDefaultTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDefaultTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestDefaultTask
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDefaultTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDefaultTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CanRebaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestRebaseability
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CanRebaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CanRebaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestPullRequestRebaseResult
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RebaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestTag
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestGpgKey `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetKeysForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestGpgKey
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnnotations1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInsightAnnotationsResponse
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnnotations1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnnotations1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                `json:"isLastPage,omitempty"`
		Limit         *float32             `json:"limit,omitempty"`
		NextPageStart *int32               `json:"nextPageStart,omitempty"`
		Size          *float32             `json:"size,omitempty"`
		Start         *int32               `json:"start,omitempty"`
		Values        *[]RestInsightReport `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACodeInsightsReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteACodeInsightsReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACodeInsightsReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACodeInsightsReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInsightReport
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetACodeInsightsReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACodeInsightsReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetACodeInsightsReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInsightReport
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetACodeInsightsReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetACodeInsightsReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAnnotationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAnnotationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAnnotationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnnotationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestInsightAnnotationsResponse
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnnotationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnnotationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAnnotationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddAnnotationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAnnotationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAnnotationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetAnnotationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAnnotationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestCommentJiraIssue
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitsByIssueKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool            `json:"isLastPage,omitempty"`
		Limit         *float32         `json:"limit,omitempty"`
		NextPageStart *int32           `json:"nextPageStart,omitempty"`
		Size          *float32         `json:"size,omitempty"`
		Start         *int32           `json:"start,omitempty"`
		Values        *[]RestChangeset `json:"values,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCommitsByIssueKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitsByIssueKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnhancedEntityLinkForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestEnhancedEntityLink
}

// Status returns HTTPResponse.Status
func (r GetEnhancedEntityLinkForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnhancedEntityLinkForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIssueKeysForPullRequestResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]RestJiraIssue
}

// Status returns HTTPResponse.Status
func (r GetIssueKeysForPullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIssueKeysForPullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForRepository1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestSshAccessKey `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForRepository1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForRepository1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestSshAccessKey
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshAccessKey
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePermission1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshAccessKey
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePermission1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePermission1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshKeysForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestSshAccessKey `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSshKeysForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshKeysForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestSshAccessKey
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshAccessKey
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshAccessKey
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetForRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePreferredMirrorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePreferredMirrorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePreferredMirrorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreferredMirrorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorServer
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPreferredMirrorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreferredMirrorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPreferredMirrorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetPreferredMirrorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPreferredMirrorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyticsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestAnalyticsSettings
}

// Status returns HTTPResponse.Status
func (r AnalyticsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyticsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestApplicationUserWithPermissions
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuthenticateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFarmNodesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]RestClusterNode
	ApplicationjsonCharsetUTF8404 *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetFarmNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFarmNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirroredRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirroredRepository
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirroredRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirroredRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMirrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool               `json:"isLastPage,omitempty"`
		Limit         *float32            `json:"limit,omitempty"`
		NextPageStart *int32              `json:"nextPageStart,omitempty"`
		Size          *float32            `json:"size,omitempty"`
		Start         *int32              `json:"start,omitempty"`
		Values        *[]RestMirrorServer `json:"values,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMirrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMirrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorServer
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorServer
}

// Status returns HTTPResponse.Status
func (r UpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PublishEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSynchronizationProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSyncProgress
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSynchronizationProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSynchronizationProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestProject
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllReposForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                 `json:"isLastPage,omitempty"`
		Limit         *float32              `json:"limit,omitempty"`
		NextPageStart *int32                `json:"nextPageStart,omitempty"`
		Size          *float32              `json:"size,omitempty"`
		Start         *int32                `json:"start,omitempty"`
		Values        *[]EnrichedRepository `json:"values,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllReposForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllReposForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllContentHashesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedRepository
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllContentHashesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllContentHashesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentHashByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedRepository
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContentHashByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentHashByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryMirrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirroredRepositoryDescriptor
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryMirrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryMirrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                   `json:"isLastPage,omitempty"`
		Limit         *float32                `json:"limit,omitempty"`
		NextPageStart *int32                  `json:"nextPageStart,omitempty"`
		Size          *float32                `json:"size,omitempty"`
		Start         *int32                  `json:"start,omitempty"`
		Values        *[]RestMirroringRequest `json:"values,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirroringRequest
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMirroringRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMirroringRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMirroringRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirroringRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirroringRequest
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirroringRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirroringRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorServer
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorServer
	JSON409      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RejectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutOfSyncRepositoriesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *string
	ApplicationjsonCharsetUTF8401 *RestErrors
	ApplicationjsonCharsetUTF8409 *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetOutOfSyncRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutOfSyncRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryLockOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryLockOwner
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryLockOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryLockOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepoSyncStatus1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestMirrorRepositorySynchronizationStatus
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepoSyncStatus1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepoSyncStatus1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefChangesQueueResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *RestRefSyncQueue
	ApplicationjsonCharsetUTF8401 *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetRefChangesQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefChangesQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefChangesQueueCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRefChangesQueueCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefChangesQueueCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryLockOwnersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUTF8200 *[]RestRepositoryLockOwner
	ApplicationjsonCharsetUTF8401 *RestErrors
}

// Status returns HTTPResponse.Status
func (r GetRepositoryLockOwnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryLockOwnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepoSyncStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                                        `json:"isLastPage,omitempty"`
		Limit         *float32                                     `json:"limit,omitempty"`
		NextPageStart *int32                                       `json:"nextPageStart,omitempty"`
		Size          *float32                                     `json:"size,omitempty"`
		Start         *int32                                       `json:"start,omitempty"`
		Values        *[]RestMirrorRepositorySynchronizationStatus `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepoSyncStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepoSyncStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirrorSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUpstreamSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirrorSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirrorSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMirrorSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUpstreamSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetMirrorSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMirrorSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirrorModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirrorModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirrorModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMirrorModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetMirrorModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMirrorModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMirroredProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMirroredProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMirroredProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartMirroringProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartMirroringProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartMirroringProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopMirroringProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StopMirroringProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopMirroringProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartMirroringProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartMirroringProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartMirroringProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpstreamServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestUpstreamServer
	JSON404      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUpstreamServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpstreamServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndRollingUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRollingUpgradeState
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EndRollingUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndRollingUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartRollingUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRollingUpgradeState
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartRollingUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartRollingUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryArchivePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPolicy
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryArchivePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryArchivePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryArchivePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPolicy
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetRepositoryArchivePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryArchivePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryDeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPolicy
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRepositoryDeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryDeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryDeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRepositoryPolicy
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetRepositoryDeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryDeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequiredBuildsMergeCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRequiredBuildCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRequiredBuildsMergeCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequiredBuildsMergeCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRequiredBuildsMergeCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRequiredBuildsMergeCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRequiredBuildsMergeCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRequiredBuildsMergeCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRequiredBuildCondition
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRequiredBuildsMergeCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRequiredBuildsMergeCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageOfRequiredBuildsMergeChecksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool                         `json:"isLastPage,omitempty"`
		Limit         *float32                      `json:"limit,omitempty"`
		NextPageStart *int32                        `json:"nextPageStart,omitempty"`
		Size          *float32                      `json:"size,omitempty"`
		Start         *int32                        `json:"start,omitempty"`
		Values        *[]RestRequiredBuildCondition `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageOfRequiredBuildsMergeChecksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageOfRequiredBuildsMergeChecksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSshKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IsLastPage    *bool         `json:"isLastPage,omitempty"`
		Limit         *float32      `json:"limit,omitempty"`
		NextPageStart *int32        `json:"nextPageStart,omitempty"`
		Size          *float32      `json:"size,omitempty"`
		Start         *int32        `json:"start,omitempty"`
		Values        *[]RestSshKey `json:"values,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSshKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RestSshKey
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshKey
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SshSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestSshSettings
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SshSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SshSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefSyncStatus
	JSON401      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRefSyncStatus
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SetEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SynchronizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestRejectedRef
	JSON400      *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON401 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON404 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON409 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
	JSON501 *struct {
		Errors *[]RestErrorMessage `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SynchronizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SynchronizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllAccessTokensWithResponse request returning *GetAllAccessTokensResponse
func (c *ClientWithResponses) GetAllAccessTokensWithResponse(ctx context.Context, projectKey string, params *GetAllAccessTokensParams, reqEditors ...RequestEditorFn) (*GetAllAccessTokensResponse, error) {
	rsp, err := c.GetAllAccessTokens(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessTokensResponse(rsp)
}

// CreateAccessTokenWithBodyWithResponse request with arbitrary body returning *CreateAccessTokenResponse
func (c *ClientWithResponses) CreateAccessTokenWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessTokenResponse, error) {
	rsp, err := c.CreateAccessTokenWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateAccessTokenWithResponse(ctx context.Context, projectKey string, body CreateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessTokenResponse, error) {
	rsp, err := c.CreateAccessToken(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessTokenResponse(rsp)
}

// GetAllAccessTokens1WithResponse request returning *GetAllAccessTokens1Response
func (c *ClientWithResponses) GetAllAccessTokens1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetAllAccessTokens1Params, reqEditors ...RequestEditorFn) (*GetAllAccessTokens1Response, error) {
	rsp, err := c.GetAllAccessTokens1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessTokens1Response(rsp)
}

// CreateAccessToken1WithBodyWithResponse request with arbitrary body returning *CreateAccessToken1Response
func (c *ClientWithResponses) CreateAccessToken1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessToken1Response, error) {
	rsp, err := c.CreateAccessToken1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessToken1Response(rsp)
}

func (c *ClientWithResponses) CreateAccessToken1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessToken1Response, error) {
	rsp, err := c.CreateAccessToken1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessToken1Response(rsp)
}

// DeleteById1WithResponse request returning *DeleteById1Response
func (c *ClientWithResponses) DeleteById1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteById1Response, error) {
	rsp, err := c.DeleteById1(ctx, projectKey, repositorySlug, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteById1Response(rsp)
}

// GetById1WithResponse request returning *GetById1Response
func (c *ClientWithResponses) GetById1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, reqEditors ...RequestEditorFn) (*GetById1Response, error) {
	rsp, err := c.GetById1(ctx, projectKey, repositorySlug, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetById1Response(rsp)
}

// UpdateAccessToken1WithBodyWithResponse request with arbitrary body returning *UpdateAccessToken1Response
func (c *ClientWithResponses) UpdateAccessToken1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessToken1Response, error) {
	rsp, err := c.UpdateAccessToken1WithBody(ctx, projectKey, repositorySlug, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessToken1Response(rsp)
}

func (c *ClientWithResponses) UpdateAccessToken1WithResponse(ctx context.Context, projectKey string, repositorySlug string, tokenId string, body UpdateAccessToken1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessToken1Response, error) {
	rsp, err := c.UpdateAccessToken1(ctx, projectKey, repositorySlug, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessToken1Response(rsp)
}

// DeleteByIdWithResponse request returning *DeleteByIdResponse
func (c *ClientWithResponses) DeleteByIdWithResponse(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteByIdResponse, error) {
	rsp, err := c.DeleteById(ctx, projectKey, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteByIdResponse(rsp)
}

// GetByIdWithResponse request returning *GetByIdResponse
func (c *ClientWithResponses) GetByIdWithResponse(ctx context.Context, projectKey string, tokenId string, reqEditors ...RequestEditorFn) (*GetByIdResponse, error) {
	rsp, err := c.GetById(ctx, projectKey, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetByIdResponse(rsp)
}

// UpdateAccessTokenWithBodyWithResponse request with arbitrary body returning *UpdateAccessTokenResponse
func (c *ClientWithResponses) UpdateAccessTokenWithBodyWithResponse(ctx context.Context, projectKey string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessTokenResponse, error) {
	rsp, err := c.UpdateAccessTokenWithBody(ctx, projectKey, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccessTokenWithResponse(ctx context.Context, projectKey string, tokenId string, body UpdateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessTokenResponse, error) {
	rsp, err := c.UpdateAccessToken(ctx, projectKey, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessTokenResponse(rsp)
}

// GetAllAccessTokens2WithResponse request returning *GetAllAccessTokens2Response
func (c *ClientWithResponses) GetAllAccessTokens2WithResponse(ctx context.Context, userSlug string, params *GetAllAccessTokens2Params, reqEditors ...RequestEditorFn) (*GetAllAccessTokens2Response, error) {
	rsp, err := c.GetAllAccessTokens2(ctx, userSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAccessTokens2Response(rsp)
}

// CreateAccessToken2WithBodyWithResponse request with arbitrary body returning *CreateAccessToken2Response
func (c *ClientWithResponses) CreateAccessToken2WithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessToken2Response, error) {
	rsp, err := c.CreateAccessToken2WithBody(ctx, userSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessToken2Response(rsp)
}

func (c *ClientWithResponses) CreateAccessToken2WithResponse(ctx context.Context, userSlug string, body CreateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessToken2Response, error) {
	rsp, err := c.CreateAccessToken2(ctx, userSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessToken2Response(rsp)
}

// DeleteById2WithResponse request returning *DeleteById2Response
func (c *ClientWithResponses) DeleteById2WithResponse(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteById2Response, error) {
	rsp, err := c.DeleteById2(ctx, userSlug, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteById2Response(rsp)
}

// GetById2WithResponse request returning *GetById2Response
func (c *ClientWithResponses) GetById2WithResponse(ctx context.Context, userSlug string, tokenId string, reqEditors ...RequestEditorFn) (*GetById2Response, error) {
	rsp, err := c.GetById2(ctx, userSlug, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetById2Response(rsp)
}

// UpdateAccessToken2WithBodyWithResponse request with arbitrary body returning *UpdateAccessToken2Response
func (c *ClientWithResponses) UpdateAccessToken2WithBodyWithResponse(ctx context.Context, userSlug string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessToken2Response, error) {
	rsp, err := c.UpdateAccessToken2WithBody(ctx, userSlug, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessToken2Response(rsp)
}

func (c *ClientWithResponses) UpdateAccessToken2WithResponse(ctx context.Context, userSlug string, tokenId string, body UpdateAccessToken2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessToken2Response, error) {
	rsp, err := c.UpdateAccessToken2(ctx, userSlug, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessToken2Response(rsp)
}

// GetGlobalSettingsWithResponse request returning *GetGlobalSettingsResponse
func (c *ClientWithResponses) GetGlobalSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalSettingsResponse, error) {
	rsp, err := c.GetGlobalSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalSettingsResponse(rsp)
}

// UpdateGlobalSettingsWithBodyWithResponse request with arbitrary body returning *UpdateGlobalSettingsResponse
func (c *ClientWithResponses) UpdateGlobalSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalSettingsResponse, error) {
	rsp, err := c.UpdateGlobalSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateGlobalSettingsWithResponse(ctx context.Context, body UpdateGlobalSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalSettingsResponse, error) {
	rsp, err := c.UpdateGlobalSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalSettingsResponse(rsp)
}

// GetSupportedKeyTypesWithResponse request returning *GetSupportedKeyTypesResponse
func (c *ClientWithResponses) GetSupportedKeyTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportedKeyTypesResponse, error) {
	rsp, err := c.GetSupportedKeyTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportedKeyTypesResponse(rsp)
}

// DeleteBannerWithResponse request returning *DeleteBannerResponse
func (c *ClientWithResponses) DeleteBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteBannerResponse, error) {
	rsp, err := c.DeleteBanner(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBannerResponse(rsp)
}

// GetBannerWithResponse request returning *GetBannerResponse
func (c *ClientWithResponses) GetBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBannerResponse, error) {
	rsp, err := c.GetBanner(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBannerResponse(rsp)
}

// SetBannerWithBodyWithResponse request with arbitrary body returning *SetBannerResponse
func (c *ClientWithResponses) SetBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBannerResponse, error) {
	rsp, err := c.SetBannerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBannerResponse(rsp)
}

func (c *ClientWithResponses) SetBannerWithResponse(ctx context.Context, body SetBannerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBannerResponse, error) {
	rsp, err := c.SetBanner(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBannerResponse(rsp)
}

// GetInformationWithResponse request returning *GetInformationResponse
func (c *ClientWithResponses) GetInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInformationResponse, error) {
	rsp, err := c.GetInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInformationResponse(rsp)
}

// ClearDefaultBranchWithResponse request returning *ClearDefaultBranchResponse
func (c *ClientWithResponses) ClearDefaultBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearDefaultBranchResponse, error) {
	rsp, err := c.ClearDefaultBranch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearDefaultBranchResponse(rsp)
}

// GetDefaultBranchWithResponse request returning *GetDefaultBranchResponse
func (c *ClientWithResponses) GetDefaultBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultBranchResponse, error) {
	rsp, err := c.GetDefaultBranch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultBranchResponse(rsp)
}

// SetDefaultBranchWithBodyWithResponse request with arbitrary body returning *SetDefaultBranchResponse
func (c *ClientWithResponses) SetDefaultBranchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranchResponse, error) {
	rsp, err := c.SetDefaultBranchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranchResponse(rsp)
}

func (c *ClientWithResponses) SetDefaultBranchWithResponse(ctx context.Context, body SetDefaultBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranchResponse, error) {
	rsp, err := c.SetDefaultBranch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranchResponse(rsp)
}

// GetControlPlanePublicKeyWithResponse request returning *GetControlPlanePublicKeyResponse
func (c *ClientWithResponses) GetControlPlanePublicKeyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetControlPlanePublicKeyResponse, error) {
	rsp, err := c.GetControlPlanePublicKey(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetControlPlanePublicKeyResponse(rsp)
}

// ConnectivityWithResponse request returning *ConnectivityResponse
func (c *ClientWithResponses) ConnectivityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ConnectivityResponse, error) {
	rsp, err := c.Connectivity(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectivityResponse(rsp)
}

// GetAllRegisteredMeshNodesWithResponse request returning *GetAllRegisteredMeshNodesResponse
func (c *ClientWithResponses) GetAllRegisteredMeshNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllRegisteredMeshNodesResponse, error) {
	rsp, err := c.GetAllRegisteredMeshNodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRegisteredMeshNodesResponse(rsp)
}

// RegisterNewMeshNodeWithBodyWithResponse request with arbitrary body returning *RegisterNewMeshNodeResponse
func (c *ClientWithResponses) RegisterNewMeshNodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterNewMeshNodeResponse, error) {
	rsp, err := c.RegisterNewMeshNodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterNewMeshNodeResponse(rsp)
}

func (c *ClientWithResponses) RegisterNewMeshNodeWithResponse(ctx context.Context, body RegisterNewMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterNewMeshNodeResponse, error) {
	rsp, err := c.RegisterNewMeshNode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterNewMeshNodeResponse(rsp)
}

// Delete2WithResponse request returning *Delete2Response
func (c *ClientWithResponses) Delete2WithResponse(ctx context.Context, id int64, params *Delete2Params, reqEditors ...RequestEditorFn) (*Delete2Response, error) {
	rsp, err := c.Delete2(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete2Response(rsp)
}

// GetRegisteredMeshNodeByIdWithResponse request returning *GetRegisteredMeshNodeByIdResponse
func (c *ClientWithResponses) GetRegisteredMeshNodeByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegisteredMeshNodeByIdResponse, error) {
	rsp, err := c.GetRegisteredMeshNodeById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegisteredMeshNodeByIdResponse(rsp)
}

// UpdateMeshNodeWithBodyWithResponse request with arbitrary body returning *UpdateMeshNodeResponse
func (c *ClientWithResponses) UpdateMeshNodeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMeshNodeResponse, error) {
	rsp, err := c.UpdateMeshNodeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMeshNodeResponse(rsp)
}

func (c *ClientWithResponses) UpdateMeshNodeWithResponse(ctx context.Context, id string, body UpdateMeshNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMeshNodeResponse, error) {
	rsp, err := c.UpdateMeshNode(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMeshNodeResponse(rsp)
}

// GetSupportZipsWithResponse request returning *GetSupportZipsResponse
func (c *ClientWithResponses) GetSupportZipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportZipsResponse, error) {
	rsp, err := c.GetSupportZips(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportZipsResponse(rsp)
}

// GetSupportZipWithResponse request returning *GetSupportZipResponse
func (c *ClientWithResponses) GetSupportZipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSupportZipResponse, error) {
	rsp, err := c.GetSupportZip(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportZipResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroups1WithResponse request returning *GetGroups1Response
func (c *ClientWithResponses) GetGroups1WithResponse(ctx context.Context, params *GetGroups1Params, reqEditors ...RequestEditorFn) (*GetGroups1Response, error) {
	rsp, err := c.GetGroups1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroups1Response(rsp)
}

// CreateGroupWithResponse request returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// AddUserToGroupWithBodyWithResponse request with arbitrary body returning *AddUserToGroupResponse
func (c *ClientWithResponses) AddUserToGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupWithResponse(ctx context.Context, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

// AddUsersToGroupWithBodyWithResponse request with arbitrary body returning *AddUsersToGroupResponse
func (c *ClientWithResponses) AddUsersToGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUsersToGroupResponse, error) {
	rsp, err := c.AddUsersToGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUsersToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUsersToGroupWithResponse(ctx context.Context, body AddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUsersToGroupResponse, error) {
	rsp, err := c.AddUsersToGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUsersToGroupResponse(rsp)
}

// FindUsersInGroupWithResponse request returning *FindUsersInGroupResponse
func (c *ClientWithResponses) FindUsersInGroupWithResponse(ctx context.Context, params *FindUsersInGroupParams, reqEditors ...RequestEditorFn) (*FindUsersInGroupResponse, error) {
	rsp, err := c.FindUsersInGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUsersInGroupResponse(rsp)
}

// FindUsersNotInGroupWithResponse request returning *FindUsersNotInGroupResponse
func (c *ClientWithResponses) FindUsersNotInGroupWithResponse(ctx context.Context, params *FindUsersNotInGroupParams, reqEditors ...RequestEditorFn) (*FindUsersNotInGroupResponse, error) {
	rsp, err := c.FindUsersNotInGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUsersNotInGroupResponse(rsp)
}

// RemoveUserFromGroupWithBodyWithResponse request with arbitrary body returning *RemoveUserFromGroupResponse
func (c *ClientWithResponses) RemoveUserFromGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error) {
	rsp, err := c.RemoveUserFromGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserFromGroupWithResponse(ctx context.Context, body RemoveUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error) {
	rsp, err := c.RemoveUserFromGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromGroupResponse(rsp)
}

// Get2WithResponse request returning *Get2Response
func (c *ClientWithResponses) Get2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Get2Response, error) {
	rsp, err := c.Get2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet2Response(rsp)
}

// UpdateLicenseWithBodyWithResponse request with arbitrary body returning *UpdateLicenseResponse
func (c *ClientWithResponses) UpdateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

func (c *ClientWithResponses) UpdateLicenseWithResponse(ctx context.Context, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

// DeleteMailConfigWithResponse request returning *DeleteMailConfigResponse
func (c *ClientWithResponses) DeleteMailConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteMailConfigResponse, error) {
	rsp, err := c.DeleteMailConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailConfigResponse(rsp)
}

// GetMailConfigWithResponse request returning *GetMailConfigResponse
func (c *ClientWithResponses) GetMailConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMailConfigResponse, error) {
	rsp, err := c.GetMailConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailConfigResponse(rsp)
}

// SetMailConfigWithBodyWithResponse request with arbitrary body returning *SetMailConfigResponse
func (c *ClientWithResponses) SetMailConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMailConfigResponse, error) {
	rsp, err := c.SetMailConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMailConfigResponse(rsp)
}

func (c *ClientWithResponses) SetMailConfigWithResponse(ctx context.Context, body SetMailConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMailConfigResponse, error) {
	rsp, err := c.SetMailConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMailConfigResponse(rsp)
}

// ClearSenderAddressWithResponse request returning *ClearSenderAddressResponse
func (c *ClientWithResponses) ClearSenderAddressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearSenderAddressResponse, error) {
	rsp, err := c.ClearSenderAddress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearSenderAddressResponse(rsp)
}

// GetSenderAddressWithResponse request returning *GetSenderAddressResponse
func (c *ClientWithResponses) GetSenderAddressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSenderAddressResponse, error) {
	rsp, err := c.GetSenderAddress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSenderAddressResponse(rsp)
}

// SetSenderAddressWithBodyWithResponse request with arbitrary body returning *SetSenderAddressResponse
func (c *ClientWithResponses) SetSenderAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSenderAddressResponse, error) {
	rsp, err := c.SetSenderAddressWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSenderAddressResponse(rsp)
}

func (c *ClientWithResponses) SetSenderAddressWithResponse(ctx context.Context, body SetSenderAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSenderAddressResponse, error) {
	rsp, err := c.SetSenderAddress(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSenderAddressResponse(rsp)
}

// RevokePermissionsForGroupWithResponse request returning *RevokePermissionsForGroupResponse
func (c *ClientWithResponses) RevokePermissionsForGroupWithResponse(ctx context.Context, params *RevokePermissionsForGroupParams, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroupResponse, error) {
	rsp, err := c.RevokePermissionsForGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForGroupResponse(rsp)
}

// GetGroupsWithAnyPermissionWithResponse request returning *GetGroupsWithAnyPermissionResponse
func (c *ClientWithResponses) GetGroupsWithAnyPermissionWithResponse(ctx context.Context, params *GetGroupsWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermissionResponse, error) {
	rsp, err := c.GetGroupsWithAnyPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithAnyPermissionResponse(rsp)
}

// SetPermissionForGroupsWithResponse request returning *SetPermissionForGroupsResponse
func (c *ClientWithResponses) SetPermissionForGroupsWithResponse(ctx context.Context, params *SetPermissionForGroupsParams, reqEditors ...RequestEditorFn) (*SetPermissionForGroupsResponse, error) {
	rsp, err := c.SetPermissionForGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForGroupsResponse(rsp)
}

// GetGroupsWithoutAnyPermissionWithResponse request returning *GetGroupsWithoutAnyPermissionResponse
func (c *ClientWithResponses) GetGroupsWithoutAnyPermissionWithResponse(ctx context.Context, params *GetGroupsWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermissionResponse, error) {
	rsp, err := c.GetGroupsWithoutAnyPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithoutAnyPermissionResponse(rsp)
}

// RevokePermissionsForUserWithResponse request returning *RevokePermissionsForUserResponse
func (c *ClientWithResponses) RevokePermissionsForUserWithResponse(ctx context.Context, params *RevokePermissionsForUserParams, reqEditors ...RequestEditorFn) (*RevokePermissionsForUserResponse, error) {
	rsp, err := c.RevokePermissionsForUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForUserResponse(rsp)
}

// GetUsersWithAnyPermissionWithResponse request returning *GetUsersWithAnyPermissionResponse
func (c *ClientWithResponses) GetUsersWithAnyPermissionWithResponse(ctx context.Context, params *GetUsersWithAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermissionResponse, error) {
	rsp, err := c.GetUsersWithAnyPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithAnyPermissionResponse(rsp)
}

// SetPermissionForUsersWithResponse request returning *SetPermissionForUsersResponse
func (c *ClientWithResponses) SetPermissionForUsersWithResponse(ctx context.Context, params *SetPermissionForUsersParams, reqEditors ...RequestEditorFn) (*SetPermissionForUsersResponse, error) {
	rsp, err := c.SetPermissionForUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForUsersResponse(rsp)
}

// GetUsersWithoutAnyPermissionWithResponse request returning *GetUsersWithoutAnyPermissionResponse
func (c *ClientWithResponses) GetUsersWithoutAnyPermissionWithResponse(ctx context.Context, params *GetUsersWithoutAnyPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithoutAnyPermissionResponse, error) {
	rsp, err := c.GetUsersWithoutAnyPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithoutAnyPermissionResponse(rsp)
}

// GetMergeConfigWithResponse request returning *GetMergeConfigResponse
func (c *ClientWithResponses) GetMergeConfigWithResponse(ctx context.Context, scmId string, reqEditors ...RequestEditorFn) (*GetMergeConfigResponse, error) {
	rsp, err := c.GetMergeConfig(ctx, scmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMergeConfigResponse(rsp)
}

// SetMergeConfigWithBodyWithResponse request with arbitrary body returning *SetMergeConfigResponse
func (c *ClientWithResponses) SetMergeConfigWithBodyWithResponse(ctx context.Context, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMergeConfigResponse, error) {
	rsp, err := c.SetMergeConfigWithBody(ctx, scmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMergeConfigResponse(rsp)
}

func (c *ClientWithResponses) SetMergeConfigWithResponse(ctx context.Context, scmId string, body SetMergeConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMergeConfigResponse, error) {
	rsp, err := c.SetMergeConfig(ctx, scmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMergeConfigResponse(rsp)
}

// GetHistoryWithResponse request returning *GetHistoryResponse
func (c *ClientWithResponses) GetHistoryWithResponse(ctx context.Context, params *GetHistoryParams, reqEditors ...RequestEditorFn) (*GetHistoryResponse, error) {
	rsp, err := c.GetHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHistoryResponse(rsp)
}

// GetSettings2WithResponse request returning *GetSettings2Response
func (c *ClientWithResponses) GetSettings2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettings2Response, error) {
	rsp, err := c.GetSettings2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettings2Response(rsp)
}

// SetSettings2WithBodyWithResponse request with arbitrary body returning *SetSettings2Response
func (c *ClientWithResponses) SetSettings2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettings2Response, error) {
	rsp, err := c.SetSettings2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettings2Response(rsp)
}

func (c *ClientWithResponses) SetSettings2WithResponse(ctx context.Context, body SetSettings2JSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettings2Response, error) {
	rsp, err := c.SetSettings2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettings2Response(rsp)
}

// GetAllRateLimitSettingsWithResponse request returning *GetAllRateLimitSettingsResponse
func (c *ClientWithResponses) GetAllRateLimitSettingsWithResponse(ctx context.Context, params *GetAllRateLimitSettingsParams, reqEditors ...RequestEditorFn) (*GetAllRateLimitSettingsResponse, error) {
	rsp, err := c.GetAllRateLimitSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRateLimitSettingsResponse(rsp)
}

// Set2WithBodyWithResponse request with arbitrary body returning *Set2Response
func (c *ClientWithResponses) Set2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set2Response, error) {
	rsp, err := c.Set2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet2Response(rsp)
}

func (c *ClientWithResponses) Set2WithResponse(ctx context.Context, body Set2JSONRequestBody, reqEditors ...RequestEditorFn) (*Set2Response, error) {
	rsp, err := c.Set2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet2Response(rsp)
}

// Delete8WithResponse request returning *Delete8Response
func (c *ClientWithResponses) Delete8WithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*Delete8Response, error) {
	rsp, err := c.Delete8(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete8Response(rsp)
}

// Get6WithResponse request returning *Get6Response
func (c *ClientWithResponses) Get6WithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*Get6Response, error) {
	rsp, err := c.Get6(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet6Response(rsp)
}

// Set3WithBodyWithResponse request with arbitrary body returning *Set3Response
func (c *ClientWithResponses) Set3WithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set3Response, error) {
	rsp, err := c.Set3WithBody(ctx, userSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet3Response(rsp)
}

func (c *ClientWithResponses) Set3WithResponse(ctx context.Context, userSlug string, body Set3JSONRequestBody, reqEditors ...RequestEditorFn) (*Set3Response, error) {
	rsp, err := c.Set3(ctx, userSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet3Response(rsp)
}

// GetUserDirectoriesWithResponse request returning *GetUserDirectoriesResponse
func (c *ClientWithResponses) GetUserDirectoriesWithResponse(ctx context.Context, params *GetUserDirectoriesParams, reqEditors ...RequestEditorFn) (*GetUserDirectoriesResponse, error) {
	rsp, err := c.GetUserDirectories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDirectoriesResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUsers1WithResponse request returning *GetUsers1Response
func (c *ClientWithResponses) GetUsers1WithResponse(ctx context.Context, params *GetUsers1Params, reqEditors ...RequestEditorFn) (*GetUsers1Response, error) {
	rsp, err := c.GetUsers1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsers1Response(rsp)
}

// CreateUserWithResponse request returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// UpdateUserDetailsWithBodyWithResponse request with arbitrary body returning *UpdateUserDetailsResponse
func (c *ClientWithResponses) UpdateUserDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDetailsResponse, error) {
	rsp, err := c.UpdateUserDetailsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDetailsResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserDetailsWithResponse(ctx context.Context, body UpdateUserDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDetailsResponse, error) {
	rsp, err := c.UpdateUserDetails(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDetailsResponse(rsp)
}

// AddGroupToUserWithBodyWithResponse request with arbitrary body returning *AddGroupToUserResponse
func (c *ClientWithResponses) AddGroupToUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupToUserResponse, error) {
	rsp, err := c.AddGroupToUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupToUserResponse(rsp)
}

func (c *ClientWithResponses) AddGroupToUserWithResponse(ctx context.Context, body AddGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupToUserResponse, error) {
	rsp, err := c.AddGroupToUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupToUserResponse(rsp)
}

// AddUserToGroupsWithBodyWithResponse request with arbitrary body returning *AddUserToGroupsResponse
func (c *ClientWithResponses) AddUserToGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupsResponse, error) {
	rsp, err := c.AddUserToGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupsResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupsWithResponse(ctx context.Context, body AddUserToGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupsResponse, error) {
	rsp, err := c.AddUserToGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupsResponse(rsp)
}

// ClearUserCaptchaChallengeWithResponse request returning *ClearUserCaptchaChallengeResponse
func (c *ClientWithResponses) ClearUserCaptchaChallengeWithResponse(ctx context.Context, params *ClearUserCaptchaChallengeParams, reqEditors ...RequestEditorFn) (*ClearUserCaptchaChallengeResponse, error) {
	rsp, err := c.ClearUserCaptchaChallenge(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearUserCaptchaChallengeResponse(rsp)
}

// UpdateUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserPasswordResponse
func (c *ClientWithResponses) UpdateUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithResponse(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

// ValidateErasableWithResponse request returning *ValidateErasableResponse
func (c *ClientWithResponses) ValidateErasableWithResponse(ctx context.Context, params *ValidateErasableParams, reqEditors ...RequestEditorFn) (*ValidateErasableResponse, error) {
	rsp, err := c.ValidateErasable(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateErasableResponse(rsp)
}

// EraseUserWithResponse request returning *EraseUserResponse
func (c *ClientWithResponses) EraseUserWithResponse(ctx context.Context, params *EraseUserParams, reqEditors ...RequestEditorFn) (*EraseUserResponse, error) {
	rsp, err := c.EraseUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEraseUserResponse(rsp)
}

// FindGroupsForUserWithResponse request returning *FindGroupsForUserResponse
func (c *ClientWithResponses) FindGroupsForUserWithResponse(ctx context.Context, params *FindGroupsForUserParams, reqEditors ...RequestEditorFn) (*FindGroupsForUserResponse, error) {
	rsp, err := c.FindGroupsForUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGroupsForUserResponse(rsp)
}

// FindOtherGroupsForUserWithResponse request returning *FindOtherGroupsForUserResponse
func (c *ClientWithResponses) FindOtherGroupsForUserWithResponse(ctx context.Context, params *FindOtherGroupsForUserParams, reqEditors ...RequestEditorFn) (*FindOtherGroupsForUserResponse, error) {
	rsp, err := c.FindOtherGroupsForUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOtherGroupsForUserResponse(rsp)
}

// RemoveGroupFromUserWithBodyWithResponse request with arbitrary body returning *RemoveGroupFromUserResponse
func (c *ClientWithResponses) RemoveGroupFromUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGroupFromUserResponse, error) {
	rsp, err := c.RemoveGroupFromUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGroupFromUserResponse(rsp)
}

func (c *ClientWithResponses) RemoveGroupFromUserWithResponse(ctx context.Context, body RemoveGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGroupFromUserResponse, error) {
	rsp, err := c.RemoveGroupFromUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGroupFromUserResponse(rsp)
}

// RenameUserWithBodyWithResponse request with arbitrary body returning *RenameUserResponse
func (c *ClientWithResponses) RenameUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RenameUserResponse, error) {
	rsp, err := c.RenameUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameUserResponse(rsp)
}

func (c *ClientWithResponses) RenameUserWithResponse(ctx context.Context, body RenameUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RenameUserResponse, error) {
	rsp, err := c.RenameUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameUserResponse(rsp)
}

// GetApplicationPropertiesWithResponse request returning *GetApplicationPropertiesResponse
func (c *ClientWithResponses) GetApplicationPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationPropertiesResponse, error) {
	rsp, err := c.GetApplicationProperties(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationPropertiesResponse(rsp)
}

// GetCapabilitiesWithResponse request returning *GetCapabilitiesResponse
func (c *ClientWithResponses) GetCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCapabilitiesResponse, error) {
	rsp, err := c.GetCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCapabilitiesResponse(rsp)
}

// GetPullRequestSuggestionsWithResponse request returning *GetPullRequestSuggestionsResponse
func (c *ClientWithResponses) GetPullRequestSuggestionsWithResponse(ctx context.Context, params *GetPullRequestSuggestionsParams, reqEditors ...RequestEditorFn) (*GetPullRequestSuggestionsResponse, error) {
	rsp, err := c.GetPullRequestSuggestions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestSuggestionsResponse(rsp)
}

// GetPullRequests1WithResponse request returning *GetPullRequests1Response
func (c *ClientWithResponses) GetPullRequests1WithResponse(ctx context.Context, params *GetPullRequests1Params, reqEditors ...RequestEditorFn) (*GetPullRequests1Response, error) {
	rsp, err := c.GetPullRequests1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequests1Response(rsp)
}

// GetCapabilities1WithResponse request returning *GetCapabilities1Response
func (c *ClientWithResponses) GetCapabilities1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCapabilities1Response, error) {
	rsp, err := c.GetCapabilities1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCapabilities1Response(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// CreateHookScriptWithBodyWithResponse request with arbitrary body returning *CreateHookScriptResponse
func (c *ClientWithResponses) CreateHookScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHookScriptResponse, error) {
	rsp, err := c.CreateHookScriptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHookScriptResponse(rsp)
}

// DeleteHookScriptWithResponse request returning *DeleteHookScriptResponse
func (c *ClientWithResponses) DeleteHookScriptWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*DeleteHookScriptResponse, error) {
	rsp, err := c.DeleteHookScript(ctx, scriptId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHookScriptResponse(rsp)
}

// GetHookScriptWithResponse request returning *GetHookScriptResponse
func (c *ClientWithResponses) GetHookScriptWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*GetHookScriptResponse, error) {
	rsp, err := c.GetHookScript(ctx, scriptId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHookScriptResponse(rsp)
}

// UpdateHookScriptWithBodyWithResponse request with arbitrary body returning *UpdateHookScriptResponse
func (c *ClientWithResponses) UpdateHookScriptWithBodyWithResponse(ctx context.Context, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHookScriptResponse, error) {
	rsp, err := c.UpdateHookScriptWithBody(ctx, scriptId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHookScriptResponse(rsp)
}

// ReadWithResponse request returning *ReadResponse
func (c *ClientWithResponses) ReadWithResponse(ctx context.Context, scriptId string, reqEditors ...RequestEditorFn) (*ReadResponse, error) {
	rsp, err := c.Read(ctx, scriptId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadResponse(rsp)
}

// GetAvatarWithResponse request returning *GetAvatarResponse
func (c *ClientWithResponses) GetAvatarWithResponse(ctx context.Context, hookKey string, params *GetAvatarParams, reqEditors ...RequestEditorFn) (*GetAvatarResponse, error) {
	rsp, err := c.GetAvatar(ctx, hookKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvatarResponse(rsp)
}

// GetPullRequests2WithResponse request returning *GetPullRequests2Response
func (c *ClientWithResponses) GetPullRequests2WithResponse(ctx context.Context, params *GetPullRequests2Params, reqEditors ...RequestEditorFn) (*GetPullRequests2Response, error) {
	rsp, err := c.GetPullRequests2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequests2Response(rsp)
}

// GetPullRequestCountWithResponse request returning *GetPullRequestCountResponse
func (c *ClientWithResponses) GetPullRequestCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPullRequestCountResponse, error) {
	rsp, err := c.GetPullRequestCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestCountResponse(rsp)
}

// GetLabelsWithResponse request returning *GetLabelsResponse
func (c *ClientWithResponses) GetLabelsWithResponse(ctx context.Context, params *GetLabelsParams, reqEditors ...RequestEditorFn) (*GetLabelsResponse, error) {
	rsp, err := c.GetLabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelsResponse(rsp)
}

// GetLabelWithResponse request returning *GetLabelResponse
func (c *ClientWithResponses) GetLabelWithResponse(ctx context.Context, labelName string, reqEditors ...RequestEditorFn) (*GetLabelResponse, error) {
	rsp, err := c.GetLabel(ctx, labelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelResponse(rsp)
}

// GetLabelablesWithResponse request returning *GetLabelablesResponse
func (c *ClientWithResponses) GetLabelablesWithResponse(ctx context.Context, labelName string, params *GetLabelablesParams, reqEditors ...RequestEditorFn) (*GetLabelablesResponse, error) {
	rsp, err := c.GetLabelables(ctx, labelName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabelablesResponse(rsp)
}

// GetLevelWithResponse request returning *GetLevelResponse
func (c *ClientWithResponses) GetLevelWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*GetLevelResponse, error) {
	rsp, err := c.GetLevel(ctx, loggerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLevelResponse(rsp)
}

// SetLevelWithResponse request returning *SetLevelResponse
func (c *ClientWithResponses) SetLevelWithResponse(ctx context.Context, loggerName string, levelName string, reqEditors ...RequestEditorFn) (*SetLevelResponse, error) {
	rsp, err := c.SetLevel(ctx, loggerName, levelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLevelResponse(rsp)
}

// GetRootLevelWithResponse request returning *GetRootLevelResponse
func (c *ClientWithResponses) GetRootLevelWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootLevelResponse, error) {
	rsp, err := c.GetRootLevel(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootLevelResponse(rsp)
}

// SetRootLevelWithResponse request returning *SetRootLevelResponse
func (c *ClientWithResponses) SetRootLevelWithResponse(ctx context.Context, levelName string, reqEditors ...RequestEditorFn) (*SetRootLevelResponse, error) {
	rsp, err := c.SetRootLevel(ctx, levelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRootLevelResponse(rsp)
}

// PreviewWithBodyWithResponse request with arbitrary body returning *PreviewResponse
func (c *ClientWithResponses) PreviewWithBodyWithResponse(ctx context.Context, params *PreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewResponse, error) {
	rsp, err := c.PreviewWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewResponse(rsp)
}

// StartExportWithBodyWithResponse request with arbitrary body returning *StartExportResponse
func (c *ClientWithResponses) StartExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartExportResponse, error) {
	rsp, err := c.StartExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartExportResponse(rsp)
}

func (c *ClientWithResponses) StartExportWithResponse(ctx context.Context, body StartExportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartExportResponse, error) {
	rsp, err := c.StartExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartExportResponse(rsp)
}

// PreviewExportWithBodyWithResponse request with arbitrary body returning *PreviewExportResponse
func (c *ClientWithResponses) PreviewExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewExportResponse, error) {
	rsp, err := c.PreviewExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewExportResponse(rsp)
}

func (c *ClientWithResponses) PreviewExportWithResponse(ctx context.Context, body PreviewExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewExportResponse, error) {
	rsp, err := c.PreviewExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewExportResponse(rsp)
}

// GetExportJobWithResponse request returning *GetExportJobResponse
func (c *ClientWithResponses) GetExportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetExportJobResponse, error) {
	rsp, err := c.GetExportJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportJobResponse(rsp)
}

// CancelExportJobWithResponse request returning *CancelExportJobResponse
func (c *ClientWithResponses) CancelExportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelExportJobResponse, error) {
	rsp, err := c.CancelExportJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelExportJobResponse(rsp)
}

// GetExportJobMessagesWithResponse request returning *GetExportJobMessagesResponse
func (c *ClientWithResponses) GetExportJobMessagesWithResponse(ctx context.Context, jobId string, params *GetExportJobMessagesParams, reqEditors ...RequestEditorFn) (*GetExportJobMessagesResponse, error) {
	rsp, err := c.GetExportJobMessages(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportJobMessagesResponse(rsp)
}

// StartImportWithBodyWithResponse request with arbitrary body returning *StartImportResponse
func (c *ClientWithResponses) StartImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartImportResponse, error) {
	rsp, err := c.StartImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartImportResponse(rsp)
}

func (c *ClientWithResponses) StartImportWithResponse(ctx context.Context, body StartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartImportResponse, error) {
	rsp, err := c.StartImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartImportResponse(rsp)
}

// GetImportJobWithResponse request returning *GetImportJobResponse
func (c *ClientWithResponses) GetImportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetImportJobResponse, error) {
	rsp, err := c.GetImportJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportJobResponse(rsp)
}

// CancelImportJobWithResponse request returning *CancelImportJobResponse
func (c *ClientWithResponses) CancelImportJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelImportJobResponse, error) {
	rsp, err := c.CancelImportJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelImportJobResponse(rsp)
}

// GetImportJobMessagesWithResponse request returning *GetImportJobMessagesResponse
func (c *ClientWithResponses) GetImportJobMessagesWithResponse(ctx context.Context, jobId string, params *GetImportJobMessagesParams, reqEditors ...RequestEditorFn) (*GetImportJobMessagesResponse, error) {
	rsp, err := c.GetImportJobMessages(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportJobMessagesResponse(rsp)
}

// StartMeshMigrationWithBodyWithResponse request with arbitrary body returning *StartMeshMigrationResponse
func (c *ClientWithResponses) StartMeshMigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartMeshMigrationResponse, error) {
	rsp, err := c.StartMeshMigrationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartMeshMigrationResponse(rsp)
}

func (c *ClientWithResponses) StartMeshMigrationWithResponse(ctx context.Context, body StartMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*StartMeshMigrationResponse, error) {
	rsp, err := c.StartMeshMigration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartMeshMigrationResponse(rsp)
}

// PreviewMeshMigrationWithBodyWithResponse request with arbitrary body returning *PreviewMeshMigrationResponse
func (c *ClientWithResponses) PreviewMeshMigrationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewMeshMigrationResponse, error) {
	rsp, err := c.PreviewMeshMigrationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewMeshMigrationResponse(rsp)
}

func (c *ClientWithResponses) PreviewMeshMigrationWithResponse(ctx context.Context, body PreviewMeshMigrationJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewMeshMigrationResponse, error) {
	rsp, err := c.PreviewMeshMigration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewMeshMigrationResponse(rsp)
}

// SearchMeshMigrationReposWithResponse request returning *SearchMeshMigrationReposResponse
func (c *ClientWithResponses) SearchMeshMigrationReposWithResponse(ctx context.Context, params *SearchMeshMigrationReposParams, reqEditors ...RequestEditorFn) (*SearchMeshMigrationReposResponse, error) {
	rsp, err := c.SearchMeshMigrationRepos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMeshMigrationReposResponse(rsp)
}

// GetAllMeshMigrationSummariesWithResponse request returning *GetAllMeshMigrationSummariesResponse
func (c *ClientWithResponses) GetAllMeshMigrationSummariesWithResponse(ctx context.Context, params *GetAllMeshMigrationSummariesParams, reqEditors ...RequestEditorFn) (*GetAllMeshMigrationSummariesResponse, error) {
	rsp, err := c.GetAllMeshMigrationSummaries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllMeshMigrationSummariesResponse(rsp)
}

// GetActiveMeshMigrationSummaryWithResponse request returning *GetActiveMeshMigrationSummaryResponse
func (c *ClientWithResponses) GetActiveMeshMigrationSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveMeshMigrationSummaryResponse, error) {
	rsp, err := c.GetActiveMeshMigrationSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveMeshMigrationSummaryResponse(rsp)
}

// GetMeshMigrationJobWithResponse request returning *GetMeshMigrationJobResponse
func (c *ClientWithResponses) GetMeshMigrationJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobResponse, error) {
	rsp, err := c.GetMeshMigrationJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeshMigrationJobResponse(rsp)
}

// CancelMeshMigrationJobWithResponse request returning *CancelMeshMigrationJobResponse
func (c *ClientWithResponses) CancelMeshMigrationJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelMeshMigrationJobResponse, error) {
	rsp, err := c.CancelMeshMigrationJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelMeshMigrationJobResponse(rsp)
}

// GetMeshMigrationJobMessagesWithResponse request returning *GetMeshMigrationJobMessagesResponse
func (c *ClientWithResponses) GetMeshMigrationJobMessagesWithResponse(ctx context.Context, jobId string, params *GetMeshMigrationJobMessagesParams, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobMessagesResponse, error) {
	rsp, err := c.GetMeshMigrationJobMessages(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeshMigrationJobMessagesResponse(rsp)
}

// GetMeshMigrationJobSummaryWithResponse request returning *GetMeshMigrationJobSummaryResponse
func (c *ClientWithResponses) GetMeshMigrationJobSummaryWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetMeshMigrationJobSummaryResponse, error) {
	rsp, err := c.GetMeshMigrationJobSummary(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeshMigrationJobSummaryResponse(rsp)
}

// GetRepositoriesRecentlyAccessedWithResponse request returning *GetRepositoriesRecentlyAccessedResponse
func (c *ClientWithResponses) GetRepositoriesRecentlyAccessedWithResponse(ctx context.Context, params *GetRepositoriesRecentlyAccessedParams, reqEditors ...RequestEditorFn) (*GetRepositoriesRecentlyAccessedResponse, error) {
	rsp, err := c.GetRepositoriesRecentlyAccessed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesRecentlyAccessedResponse(rsp)
}

// GetProjectsWithResponse request returning *GetProjectsResponse
func (c *ClientWithResponses) GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams, reqEditors ...RequestEditorFn) (*GetProjectsResponse, error) {
	rsp, err := c.GetProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectKey string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// GetProjectAvatarWithResponse request returning *GetProjectAvatarResponse
func (c *ClientWithResponses) GetProjectAvatarWithResponse(ctx context.Context, projectKey string, params *GetProjectAvatarParams, reqEditors ...RequestEditorFn) (*GetProjectAvatarResponse, error) {
	rsp, err := c.GetProjectAvatar(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectAvatarResponse(rsp)
}

// UploadAvatarWithBodyWithResponse request with arbitrary body returning *UploadAvatarResponse
func (c *ClientWithResponses) UploadAvatarWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAvatarResponse, error) {
	rsp, err := c.UploadAvatarWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAvatarResponse(rsp)
}

// GetConfigurationsWithResponse request returning *GetConfigurationsResponse
func (c *ClientWithResponses) GetConfigurationsWithResponse(ctx context.Context, projectKey string, params *GetConfigurationsParams, reqEditors ...RequestEditorFn) (*GetConfigurationsResponse, error) {
	rsp, err := c.GetConfigurations(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationsResponse(rsp)
}

// RemoveConfigurationWithResponse request returning *RemoveConfigurationResponse
func (c *ClientWithResponses) RemoveConfigurationWithResponse(ctx context.Context, projectKey string, scriptId string, reqEditors ...RequestEditorFn) (*RemoveConfigurationResponse, error) {
	rsp, err := c.RemoveConfiguration(ctx, projectKey, scriptId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveConfigurationResponse(rsp)
}

// SetConfigurationWithBodyWithResponse request with arbitrary body returning *SetConfigurationResponse
func (c *ClientWithResponses) SetConfigurationWithBodyWithResponse(ctx context.Context, projectKey string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error) {
	rsp, err := c.SetConfigurationWithBody(ctx, projectKey, scriptId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigurationResponse(rsp)
}

func (c *ClientWithResponses) SetConfigurationWithResponse(ctx context.Context, projectKey string, scriptId string, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error) {
	rsp, err := c.SetConfiguration(ctx, projectKey, scriptId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigurationResponse(rsp)
}

// RevokePermissionsWithResponse request returning *RevokePermissionsResponse
func (c *ClientWithResponses) RevokePermissionsWithResponse(ctx context.Context, projectKey string, params *RevokePermissionsParams, reqEditors ...RequestEditorFn) (*RevokePermissionsResponse, error) {
	rsp, err := c.RevokePermissions(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsResponse(rsp)
}

// RevokePermissionsForGroup1WithResponse request returning *RevokePermissionsForGroup1Response
func (c *ClientWithResponses) RevokePermissionsForGroup1WithResponse(ctx context.Context, projectKey string, params *RevokePermissionsForGroup1Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroup1Response, error) {
	rsp, err := c.RevokePermissionsForGroup1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForGroup1Response(rsp)
}

// GetGroupsWithAnyPermission1WithResponse request returning *GetGroupsWithAnyPermission1Response
func (c *ClientWithResponses) GetGroupsWithAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetGroupsWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermission1Response, error) {
	rsp, err := c.GetGroupsWithAnyPermission1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithAnyPermission1Response(rsp)
}

// SetPermissionForGroups1WithResponse request returning *SetPermissionForGroups1Response
func (c *ClientWithResponses) SetPermissionForGroups1WithResponse(ctx context.Context, projectKey string, params *SetPermissionForGroups1Params, reqEditors ...RequestEditorFn) (*SetPermissionForGroups1Response, error) {
	rsp, err := c.SetPermissionForGroups1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForGroups1Response(rsp)
}

// GetGroupsWithoutAnyPermission1WithResponse request returning *GetGroupsWithoutAnyPermission1Response
func (c *ClientWithResponses) GetGroupsWithoutAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetGroupsWithoutAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermission1Response, error) {
	rsp, err := c.GetGroupsWithoutAnyPermission1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithoutAnyPermission1Response(rsp)
}

// SearchPermissionsWithResponse request returning *SearchPermissionsResponse
func (c *ClientWithResponses) SearchPermissionsWithResponse(ctx context.Context, projectKey string, params *SearchPermissionsParams, reqEditors ...RequestEditorFn) (*SearchPermissionsResponse, error) {
	rsp, err := c.SearchPermissions(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPermissionsResponse(rsp)
}

// RevokePermissionsForUser1WithResponse request returning *RevokePermissionsForUser1Response
func (c *ClientWithResponses) RevokePermissionsForUser1WithResponse(ctx context.Context, projectKey string, params *RevokePermissionsForUser1Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForUser1Response, error) {
	rsp, err := c.RevokePermissionsForUser1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForUser1Response(rsp)
}

// GetUsersWithAnyPermission1WithResponse request returning *GetUsersWithAnyPermission1Response
func (c *ClientWithResponses) GetUsersWithAnyPermission1WithResponse(ctx context.Context, projectKey string, params *GetUsersWithAnyPermission1Params, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermission1Response, error) {
	rsp, err := c.GetUsersWithAnyPermission1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithAnyPermission1Response(rsp)
}

// SetPermissionForUsers1WithResponse request returning *SetPermissionForUsers1Response
func (c *ClientWithResponses) SetPermissionForUsers1WithResponse(ctx context.Context, projectKey string, params *SetPermissionForUsers1Params, reqEditors ...RequestEditorFn) (*SetPermissionForUsers1Response, error) {
	rsp, err := c.SetPermissionForUsers1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForUsers1Response(rsp)
}

// GetUsersWithoutPermissionWithResponse request returning *GetUsersWithoutPermissionResponse
func (c *ClientWithResponses) GetUsersWithoutPermissionWithResponse(ctx context.Context, projectKey string, params *GetUsersWithoutPermissionParams, reqEditors ...RequestEditorFn) (*GetUsersWithoutPermissionResponse, error) {
	rsp, err := c.GetUsersWithoutPermission(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithoutPermissionResponse(rsp)
}

// HasAllUserPermissionWithResponse request returning *HasAllUserPermissionResponse
func (c *ClientWithResponses) HasAllUserPermissionWithResponse(ctx context.Context, projectKey string, permission string, reqEditors ...RequestEditorFn) (*HasAllUserPermissionResponse, error) {
	rsp, err := c.HasAllUserPermission(ctx, projectKey, permission, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHasAllUserPermissionResponse(rsp)
}

// ModifyAllUserPermissionWithResponse request returning *ModifyAllUserPermissionResponse
func (c *ClientWithResponses) ModifyAllUserPermissionWithResponse(ctx context.Context, projectKey string, permission string, params *ModifyAllUserPermissionParams, reqEditors ...RequestEditorFn) (*ModifyAllUserPermissionResponse, error) {
	rsp, err := c.ModifyAllUserPermission(ctx, projectKey, permission, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyAllUserPermissionResponse(rsp)
}

// GetRepositoriesWithResponse request returning *GetRepositoriesResponse
func (c *ClientWithResponses) GetRepositoriesWithResponse(ctx context.Context, projectKey string, params *GetRepositoriesParams, reqEditors ...RequestEditorFn) (*GetRepositoriesResponse, error) {
	rsp, err := c.GetRepositories(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, projectKey string, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// ForkRepositoryWithBodyWithResponse request with arbitrary body returning *ForkRepositoryResponse
func (c *ClientWithResponses) ForkRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForkRepositoryResponse, error) {
	rsp, err := c.ForkRepositoryWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForkRepositoryResponse(rsp)
}

func (c *ClientWithResponses) ForkRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body ForkRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ForkRepositoryResponse, error) {
	rsp, err := c.ForkRepository(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForkRepositoryResponse(rsp)
}

// UpdateRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateRepositoryResponse
func (c *ClientWithResponses) UpdateRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error) {
	rsp, err := c.UpdateRepositoryWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error) {
	rsp, err := c.UpdateRepository(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRepositoryResponse(rsp)
}

// GetArchiveWithResponse request returning *GetArchiveResponse
func (c *ClientWithResponses) GetArchiveWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetArchiveParams, reqEditors ...RequestEditorFn) (*GetArchiveResponse, error) {
	rsp, err := c.GetArchive(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchiveResponse(rsp)
}

// DeleteAttachmentWithResponse request returning *DeleteAttachmentResponse
func (c *ClientWithResponses) DeleteAttachmentWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error) {
	rsp, err := c.DeleteAttachment(ctx, projectKey, repositorySlug, attachmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttachmentResponse(rsp)
}

// GetAttachmentWithResponse request returning *GetAttachmentResponse
func (c *ClientWithResponses) GetAttachmentWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error) {
	rsp, err := c.GetAttachment(ctx, projectKey, repositorySlug, attachmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentResponse(rsp)
}

// DeleteAttachmentMetadataWithResponse request returning *DeleteAttachmentMetadataResponse
func (c *ClientWithResponses) DeleteAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*DeleteAttachmentMetadataResponse, error) {
	rsp, err := c.DeleteAttachmentMetadata(ctx, projectKey, repositorySlug, attachmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttachmentMetadataResponse(rsp)
}

// GetAttachmentMetadataWithResponse request returning *GetAttachmentMetadataResponse
func (c *ClientWithResponses) GetAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, reqEditors ...RequestEditorFn) (*GetAttachmentMetadataResponse, error) {
	rsp, err := c.GetAttachmentMetadata(ctx, projectKey, repositorySlug, attachmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentMetadataResponse(rsp)
}

// SaveAttachmentMetadataWithBodyWithResponse request with arbitrary body returning *SaveAttachmentMetadataResponse
func (c *ClientWithResponses) SaveAttachmentMetadataWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveAttachmentMetadataResponse, error) {
	rsp, err := c.SaveAttachmentMetadataWithBody(ctx, projectKey, repositorySlug, attachmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAttachmentMetadataResponse(rsp)
}

func (c *ClientWithResponses) SaveAttachmentMetadataWithResponse(ctx context.Context, projectKey string, repositorySlug string, attachmentId string, body SaveAttachmentMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveAttachmentMetadataResponse, error) {
	rsp, err := c.SaveAttachmentMetadata(ctx, projectKey, repositorySlug, attachmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAttachmentMetadataResponse(rsp)
}

// GetBranchesWithResponse request returning *GetBranchesResponse
func (c *ClientWithResponses) GetBranchesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetBranchesParams, reqEditors ...RequestEditorFn) (*GetBranchesResponse, error) {
	rsp, err := c.GetBranches(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchesResponse(rsp)
}

// CreateBranchForRepositoryWithBodyWithResponse request with arbitrary body returning *CreateBranchForRepositoryResponse
func (c *ClientWithResponses) CreateBranchForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchForRepositoryResponse, error) {
	rsp, err := c.CreateBranchForRepositoryWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchForRepositoryResponse, error) {
	rsp, err := c.CreateBranchForRepository(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchForRepositoryResponse(rsp)
}

// GetDefaultBranch1WithResponse request returning *GetDefaultBranch1Response
func (c *ClientWithResponses) GetDefaultBranch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetDefaultBranch1Response, error) {
	rsp, err := c.GetDefaultBranch1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultBranch1Response(rsp)
}

// SetDefaultBranch1WithBodyWithResponse request with arbitrary body returning *SetDefaultBranch1Response
func (c *ClientWithResponses) SetDefaultBranch1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranch1Response, error) {
	rsp, err := c.SetDefaultBranch1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranch1Response(rsp)
}

func (c *ClientWithResponses) SetDefaultBranch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranch1Response, error) {
	rsp, err := c.SetDefaultBranch1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranch1Response(rsp)
}

// GetContentWithResponse request returning *GetContentResponse
func (c *ClientWithResponses) GetContentWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetContentParams, reqEditors ...RequestEditorFn) (*GetContentResponse, error) {
	rsp, err := c.GetContent(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentResponse(rsp)
}

// GetContent1WithResponse request returning *GetContent1Response
func (c *ClientWithResponses) GetContent1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetContent1Params, reqEditors ...RequestEditorFn) (*GetContent1Response, error) {
	rsp, err := c.GetContent1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContent1Response(rsp)
}

// EditFileWithBodyWithResponse request with arbitrary body returning *EditFileResponse
func (c *ClientWithResponses) EditFileWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditFileResponse, error) {
	rsp, err := c.EditFileWithBody(ctx, projectKey, repositorySlug, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditFileResponse(rsp)
}

// GetChanges1WithResponse request returning *GetChanges1Response
func (c *ClientWithResponses) GetChanges1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetChanges1Params, reqEditors ...RequestEditorFn) (*GetChanges1Response, error) {
	rsp, err := c.GetChanges1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChanges1Response(rsp)
}

// GetCommitsWithResponse request returning *GetCommitsResponse
func (c *ClientWithResponses) GetCommitsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetCommitsParams, reqEditors ...RequestEditorFn) (*GetCommitsResponse, error) {
	rsp, err := c.GetCommits(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitsResponse(rsp)
}

// GetCommitWithResponse request returning *GetCommitResponse
func (c *ClientWithResponses) GetCommitWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommitParams, reqEditors ...RequestEditorFn) (*GetCommitResponse, error) {
	rsp, err := c.GetCommit(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitResponse(rsp)
}

// DeleteWithResponse request returning *DeleteResponse
func (c *ClientWithResponses) DeleteWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResponse, error) {
	rsp, err := c.Delete(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResponse(rsp)
}

// GetWithResponse request returning *GetResponse
func (c *ClientWithResponses) GetWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetParams, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.Get(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResponse(rsp)
}

// AddWithBodyWithResponse request with arbitrary body returning *AddResponse
func (c *ClientWithResponses) AddWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddResponse, error) {
	rsp, err := c.AddWithBody(ctx, projectKey, repositorySlug, commitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddResponse(rsp)
}

// GetChangesWithResponse request returning *GetChangesResponse
func (c *ClientWithResponses) GetChangesWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetChangesParams, reqEditors ...RequestEditorFn) (*GetChangesResponse, error) {
	rsp, err := c.GetChanges(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangesResponse(rsp)
}

// GetCommentsWithResponse request returning *GetCommentsResponse
func (c *ClientWithResponses) GetCommentsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*GetCommentsResponse, error) {
	rsp, err := c.GetComments(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentsResponse(rsp)
}

// CreateCommentWithBodyWithResponse request with arbitrary body returning *CreateCommentResponse
func (c *ClientWithResponses) CreateCommentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentResponse, error) {
	rsp, err := c.CreateCommentWithBody(ctx, projectKey, repositorySlug, commitId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentResponse(rsp)
}

func (c *ClientWithResponses) CreateCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *CreateCommentParams, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentResponse, error) {
	rsp, err := c.CreateComment(ctx, projectKey, repositorySlug, commitId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentResponse(rsp)
}

// DeleteCommentWithResponse request returning *DeleteCommentResponse
func (c *ClientWithResponses) DeleteCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, params *DeleteCommentParams, reqEditors ...RequestEditorFn) (*DeleteCommentResponse, error) {
	rsp, err := c.DeleteComment(ctx, projectKey, repositorySlug, commitId, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentResponse(rsp)
}

// GetCommentWithResponse request returning *GetCommentResponse
func (c *ClientWithResponses) GetCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, reqEditors ...RequestEditorFn) (*GetCommentResponse, error) {
	rsp, err := c.GetComment(ctx, projectKey, repositorySlug, commitId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentResponse(rsp)
}

// UpdateCommentWithBodyWithResponse request with arbitrary body returning *UpdateCommentResponse
func (c *ClientWithResponses) UpdateCommentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error) {
	rsp, err := c.UpdateCommentWithBody(ctx, projectKey, repositorySlug, commitId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommentWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, body UpdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error) {
	rsp, err := c.UpdateComment(ctx, projectKey, repositorySlug, commitId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentResponse(rsp)
}

// Delete1WithResponse request returning *Delete1Response
func (c *ClientWithResponses) Delete1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Delete1Params, reqEditors ...RequestEditorFn) (*Delete1Response, error) {
	rsp, err := c.Delete1(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete1Response(rsp)
}

// Get1WithResponse request returning *Get1Response
func (c *ClientWithResponses) Get1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *Get1Params, reqEditors ...RequestEditorFn) (*Get1Response, error) {
	rsp, err := c.Get1(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet1Response(rsp)
}

// CreateOrUpdateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateDeploymentResponse
func (c *ClientWithResponses) CreateOrUpdateDeploymentWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateDeploymentResponse, error) {
	rsp, err := c.CreateOrUpdateDeploymentWithBody(ctx, projectKey, repositorySlug, commitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateDeploymentResponse(rsp)
}

// GetDiffStatsSummaryWithResponse request returning *GetDiffStatsSummaryResponse
func (c *ClientWithResponses) GetDiffStatsSummaryWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *GetDiffStatsSummaryParams, reqEditors ...RequestEditorFn) (*GetDiffStatsSummaryResponse, error) {
	rsp, err := c.GetDiffStatsSummary(ctx, projectKey, repositorySlug, commitId, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiffStatsSummaryResponse(rsp)
}

// StreamDiffWithResponse request returning *StreamDiffResponse
func (c *ClientWithResponses) StreamDiffWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, path string, params *StreamDiffParams, reqEditors ...RequestEditorFn) (*StreamDiffResponse, error) {
	rsp, err := c.StreamDiff(ctx, projectKey, repositorySlug, commitId, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamDiffResponse(rsp)
}

// GetMergeBaseWithResponse request returning *GetMergeBaseResponse
func (c *ClientWithResponses) GetMergeBaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetMergeBaseParams, reqEditors ...RequestEditorFn) (*GetMergeBaseResponse, error) {
	rsp, err := c.GetMergeBase(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMergeBaseResponse(rsp)
}

// GetPullRequestsWithResponse request returning *GetPullRequestsResponse
func (c *ClientWithResponses) GetPullRequestsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetPullRequestsParams, reqEditors ...RequestEditorFn) (*GetPullRequestsResponse, error) {
	rsp, err := c.GetPullRequests(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestsResponse(rsp)
}

// UnwatchWithResponse request returning *UnwatchResponse
func (c *ClientWithResponses) UnwatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*UnwatchResponse, error) {
	rsp, err := c.Unwatch(ctx, projectKey, repositorySlug, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnwatchResponse(rsp)
}

// WatchWithResponse request returning *WatchResponse
func (c *ClientWithResponses) WatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, reqEditors ...RequestEditorFn) (*WatchResponse, error) {
	rsp, err := c.Watch(ctx, projectKey, repositorySlug, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchResponse(rsp)
}

// StreamChangesWithResponse request returning *StreamChangesResponse
func (c *ClientWithResponses) StreamChangesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamChangesParams, reqEditors ...RequestEditorFn) (*StreamChangesResponse, error) {
	rsp, err := c.StreamChanges(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamChangesResponse(rsp)
}

// StreamCommitsWithResponse request returning *StreamCommitsResponse
func (c *ClientWithResponses) StreamCommitsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamCommitsParams, reqEditors ...RequestEditorFn) (*StreamCommitsResponse, error) {
	rsp, err := c.StreamCommits(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamCommitsResponse(rsp)
}

// GetDiffStatsSummary1WithResponse request returning *GetDiffStatsSummary1Response
func (c *ClientWithResponses) GetDiffStatsSummary1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *GetDiffStatsSummary1Params, reqEditors ...RequestEditorFn) (*GetDiffStatsSummary1Response, error) {
	rsp, err := c.GetDiffStatsSummary1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiffStatsSummary1Response(rsp)
}

// StreamDiff1WithResponse request returning *StreamDiff1Response
func (c *ClientWithResponses) StreamDiff1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamDiff1Params, reqEditors ...RequestEditorFn) (*StreamDiff1Response, error) {
	rsp, err := c.StreamDiff1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamDiff1Response(rsp)
}

// StreamContributingWithResponse request returning *StreamContributingResponse
func (c *ClientWithResponses) StreamContributingWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamContributingParams, reqEditors ...RequestEditorFn) (*StreamContributingResponse, error) {
	rsp, err := c.StreamContributing(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamContributingResponse(rsp)
}

// GetDefaultBranch2WithResponse request returning *GetDefaultBranch2Response
func (c *ClientWithResponses) GetDefaultBranch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetDefaultBranch2Response, error) {
	rsp, err := c.GetDefaultBranch2(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultBranch2Response(rsp)
}

// SetDefaultBranch2WithBodyWithResponse request with arbitrary body returning *SetDefaultBranch2Response
func (c *ClientWithResponses) SetDefaultBranch2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultBranch2Response, error) {
	rsp, err := c.SetDefaultBranch2WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranch2Response(rsp)
}

func (c *ClientWithResponses) SetDefaultBranch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetDefaultBranch2JSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultBranch2Response, error) {
	rsp, err := c.SetDefaultBranch2(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultBranch2Response(rsp)
}

// StreamRawDiffWithResponse request returning *StreamRawDiffResponse
func (c *ClientWithResponses) StreamRawDiffWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamRawDiffParams, reqEditors ...RequestEditorFn) (*StreamRawDiffResponse, error) {
	rsp, err := c.StreamRawDiff(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRawDiffResponse(rsp)
}

// StreamRawDiff1WithResponse request returning *StreamRawDiff1Response
func (c *ClientWithResponses) StreamRawDiff1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawDiff1Params, reqEditors ...RequestEditorFn) (*StreamRawDiff1Response, error) {
	rsp, err := c.StreamRawDiff1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRawDiff1Response(rsp)
}

// StreamFilesWithResponse request returning *StreamFilesResponse
func (c *ClientWithResponses) StreamFilesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamFilesParams, reqEditors ...RequestEditorFn) (*StreamFilesResponse, error) {
	rsp, err := c.StreamFiles(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFilesResponse(rsp)
}

// StreamFiles1WithResponse request returning *StreamFiles1Response
func (c *ClientWithResponses) StreamFiles1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamFiles1Params, reqEditors ...RequestEditorFn) (*StreamFiles1Response, error) {
	rsp, err := c.StreamFiles1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFiles1Response(rsp)
}

// GetForkedRepositoriesWithResponse request returning *GetForkedRepositoriesResponse
func (c *ClientWithResponses) GetForkedRepositoriesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetForkedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetForkedRepositoriesResponse, error) {
	rsp, err := c.GetForkedRepositories(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForkedRepositoriesResponse(rsp)
}

// GetConfigurations1WithResponse request returning *GetConfigurations1Response
func (c *ClientWithResponses) GetConfigurations1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetConfigurations1Params, reqEditors ...RequestEditorFn) (*GetConfigurations1Response, error) {
	rsp, err := c.GetConfigurations1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurations1Response(rsp)
}

// RemoveConfiguration1WithResponse request returning *RemoveConfiguration1Response
func (c *ClientWithResponses) RemoveConfiguration1WithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, reqEditors ...RequestEditorFn) (*RemoveConfiguration1Response, error) {
	rsp, err := c.RemoveConfiguration1(ctx, projectKey, repositorySlug, scriptId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveConfiguration1Response(rsp)
}

// SetConfiguration1WithBodyWithResponse request with arbitrary body returning *SetConfiguration1Response
func (c *ClientWithResponses) SetConfiguration1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfiguration1Response, error) {
	rsp, err := c.SetConfiguration1WithBody(ctx, projectKey, repositorySlug, scriptId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfiguration1Response(rsp)
}

func (c *ClientWithResponses) SetConfiguration1WithResponse(ctx context.Context, projectKey string, repositorySlug string, scriptId string, body SetConfiguration1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfiguration1Response, error) {
	rsp, err := c.SetConfiguration1(ctx, projectKey, repositorySlug, scriptId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfiguration1Response(rsp)
}

// GetAllLabelsForRepositoryWithResponse request returning *GetAllLabelsForRepositoryResponse
func (c *ClientWithResponses) GetAllLabelsForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetAllLabelsForRepositoryResponse, error) {
	rsp, err := c.GetAllLabelsForRepository(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLabelsForRepositoryResponse(rsp)
}

// AddLabelWithBodyWithResponse request with arbitrary body returning *AddLabelResponse
func (c *ClientWithResponses) AddLabelWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLabelResponse, error) {
	rsp, err := c.AddLabelWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLabelResponse(rsp)
}

func (c *ClientWithResponses) AddLabelWithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLabelResponse, error) {
	rsp, err := c.AddLabel(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLabelResponse(rsp)
}

// RemoveLabelWithResponse request returning *RemoveLabelResponse
func (c *ClientWithResponses) RemoveLabelWithResponse(ctx context.Context, projectKey string, repositorySlug string, labelName string, reqEditors ...RequestEditorFn) (*RemoveLabelResponse, error) {
	rsp, err := c.RemoveLabel(ctx, projectKey, repositorySlug, labelName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveLabelResponse(rsp)
}

// StreamWithResponse request returning *StreamResponse
func (c *ClientWithResponses) StreamWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamParams, reqEditors ...RequestEditorFn) (*StreamResponse, error) {
	rsp, err := c.Stream(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamResponse(rsp)
}

// Stream1WithResponse request returning *Stream1Response
func (c *ClientWithResponses) Stream1WithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *Stream1Params, reqEditors ...RequestEditorFn) (*Stream1Response, error) {
	rsp, err := c.Stream1(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStream1Response(rsp)
}

// StreamLicenseWithResponse request returning *StreamLicenseResponse
func (c *ClientWithResponses) StreamLicenseWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamLicenseParams, reqEditors ...RequestEditorFn) (*StreamLicenseResponse, error) {
	rsp, err := c.StreamLicense(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamLicenseResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// StreamPatchWithResponse request returning *StreamPatchResponse
func (c *ClientWithResponses) StreamPatchWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamPatchParams, reqEditors ...RequestEditorFn) (*StreamPatchResponse, error) {
	rsp, err := c.StreamPatch(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamPatchResponse(rsp)
}

// RevokePermissions1WithResponse request returning *RevokePermissions1Response
func (c *ClientWithResponses) RevokePermissions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissions1Params, reqEditors ...RequestEditorFn) (*RevokePermissions1Response, error) {
	rsp, err := c.RevokePermissions1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissions1Response(rsp)
}

// RevokePermissionsForGroup2WithResponse request returning *RevokePermissionsForGroup2Response
func (c *ClientWithResponses) RevokePermissionsForGroup2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForGroup2Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForGroup2Response, error) {
	rsp, err := c.RevokePermissionsForGroup2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForGroup2Response(rsp)
}

// GetGroupsWithAnyPermission2WithResponse request returning *GetGroupsWithAnyPermission2Response
func (c *ClientWithResponses) GetGroupsWithAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetGroupsWithAnyPermission2Response, error) {
	rsp, err := c.GetGroupsWithAnyPermission2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithAnyPermission2Response(rsp)
}

// SetPermissionForGroupWithResponse request returning *SetPermissionForGroupResponse
func (c *ClientWithResponses) SetPermissionForGroupWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForGroupParams, reqEditors ...RequestEditorFn) (*SetPermissionForGroupResponse, error) {
	rsp, err := c.SetPermissionForGroup(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForGroupResponse(rsp)
}

// GetGroupsWithoutAnyPermission2WithResponse request returning *GetGroupsWithoutAnyPermission2Response
func (c *ClientWithResponses) GetGroupsWithoutAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetGroupsWithoutAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetGroupsWithoutAnyPermission2Response, error) {
	rsp, err := c.GetGroupsWithoutAnyPermission2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsWithoutAnyPermission2Response(rsp)
}

// SearchPermissions1WithResponse request returning *SearchPermissions1Response
func (c *ClientWithResponses) SearchPermissions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchPermissions1Params, reqEditors ...RequestEditorFn) (*SearchPermissions1Response, error) {
	rsp, err := c.SearchPermissions1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPermissions1Response(rsp)
}

// RevokePermissionsForUser2WithResponse request returning *RevokePermissionsForUser2Response
func (c *ClientWithResponses) RevokePermissionsForUser2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *RevokePermissionsForUser2Params, reqEditors ...RequestEditorFn) (*RevokePermissionsForUser2Response, error) {
	rsp, err := c.RevokePermissionsForUser2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsForUser2Response(rsp)
}

// GetUsersWithAnyPermission2WithResponse request returning *GetUsersWithAnyPermission2Response
func (c *ClientWithResponses) GetUsersWithAnyPermission2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithAnyPermission2Params, reqEditors ...RequestEditorFn) (*GetUsersWithAnyPermission2Response, error) {
	rsp, err := c.GetUsersWithAnyPermission2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithAnyPermission2Response(rsp)
}

// SetPermissionForUserWithResponse request returning *SetPermissionForUserResponse
func (c *ClientWithResponses) SetPermissionForUserWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SetPermissionForUserParams, reqEditors ...RequestEditorFn) (*SetPermissionForUserResponse, error) {
	rsp, err := c.SetPermissionForUser(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPermissionForUserResponse(rsp)
}

// GetUsersWithoutPermission1WithResponse request returning *GetUsersWithoutPermission1Response
func (c *ClientWithResponses) GetUsersWithoutPermission1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetUsersWithoutPermission1Params, reqEditors ...RequestEditorFn) (*GetUsersWithoutPermission1Response, error) {
	rsp, err := c.GetUsersWithoutPermission1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithoutPermission1Response(rsp)
}

// GetPageWithResponse request returning *GetPageResponse
func (c *ClientWithResponses) GetPageWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetPageParams, reqEditors ...RequestEditorFn) (*GetPageResponse, error) {
	rsp, err := c.GetPage(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// Delete3WithBodyWithResponse request with arbitrary body returning *Delete3Response
func (c *ClientWithResponses) Delete3WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Delete3Response, error) {
	rsp, err := c.Delete3WithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete3Response(rsp)
}

func (c *ClientWithResponses) Delete3WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body Delete3JSONRequestBody, reqEditors ...RequestEditorFn) (*Delete3Response, error) {
	rsp, err := c.Delete3(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete3Response(rsp)
}

// Get3WithResponse request returning *Get3Response
func (c *ClientWithResponses) Get3WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Get3Response, error) {
	rsp, err := c.Get3(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet3Response(rsp)
}

// UpdateWithBodyWithResponse request with arbitrary body returning *UpdateResponse
func (c *ClientWithResponses) UpdateWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateWithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResponse(rsp)
}

func (c *ClientWithResponses) UpdateWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.Update(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResponse(rsp)
}

// StreamRawDiff2WithResponse request returning *StreamRawDiff2Response
func (c *ClientWithResponses) StreamRawDiff2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamRawDiff2Params, reqEditors ...RequestEditorFn) (*StreamRawDiff2Response, error) {
	rsp, err := c.StreamRawDiff2(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRawDiff2Response(rsp)
}

// StreamPatch1WithResponse request returning *StreamPatch1Response
func (c *ClientWithResponses) StreamPatch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*StreamPatch1Response, error) {
	rsp, err := c.StreamPatch1(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamPatch1Response(rsp)
}

// GetActivitiesWithResponse request returning *GetActivitiesResponse
func (c *ClientWithResponses) GetActivitiesWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetActivitiesParams, reqEditors ...RequestEditorFn) (*GetActivitiesResponse, error) {
	rsp, err := c.GetActivities(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitiesResponse(rsp)
}

// WithdrawApprovalWithResponse request returning *WithdrawApprovalResponse
func (c *ClientWithResponses) WithdrawApprovalWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*WithdrawApprovalResponse, error) {
	rsp, err := c.WithdrawApproval(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawApprovalResponse(rsp)
}

// ApproveWithResponse request returning *ApproveResponse
func (c *ClientWithResponses) ApproveWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*ApproveResponse, error) {
	rsp, err := c.Approve(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveResponse(rsp)
}

// CancelAutoMergeWithResponse request returning *CancelAutoMergeResponse
func (c *ClientWithResponses) CancelAutoMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CancelAutoMergeResponse, error) {
	rsp, err := c.CancelAutoMerge(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelAutoMergeResponse(rsp)
}

// GetAutoMergeRequestWithResponse request returning *GetAutoMergeRequestResponse
func (c *ClientWithResponses) GetAutoMergeRequestWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetAutoMergeRequestResponse, error) {
	rsp, err := c.GetAutoMergeRequest(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoMergeRequestResponse(rsp)
}

// TryAutoMergeWithResponse request returning *TryAutoMergeResponse
func (c *ClientWithResponses) TryAutoMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*TryAutoMergeResponse, error) {
	rsp, err := c.TryAutoMerge(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTryAutoMergeResponse(rsp)
}

// GetComments1WithResponse request returning *GetComments1Response
func (c *ClientWithResponses) GetComments1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments1Params, reqEditors ...RequestEditorFn) (*GetComments1Response, error) {
	rsp, err := c.GetComments1(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComments1Response(rsp)
}

// CreateComment1WithBodyWithResponse request with arbitrary body returning *CreateComment1Response
func (c *ClientWithResponses) CreateComment1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComment1Response, error) {
	rsp, err := c.CreateComment1WithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComment1Response(rsp)
}

func (c *ClientWithResponses) CreateComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComment1Response, error) {
	rsp, err := c.CreateComment1(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComment1Response(rsp)
}

// DeleteComment1WithResponse request returning *DeleteComment1Response
func (c *ClientWithResponses) DeleteComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment1Params, reqEditors ...RequestEditorFn) (*DeleteComment1Response, error) {
	rsp, err := c.DeleteComment1(ctx, projectKey, repositorySlug, pullRequestId, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComment1Response(rsp)
}

// GetComment1WithResponse request returning *GetComment1Response
func (c *ClientWithResponses) GetComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*GetComment1Response, error) {
	rsp, err := c.GetComment1(ctx, projectKey, repositorySlug, pullRequestId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComment1Response(rsp)
}

// UpdateComment1WithBodyWithResponse request with arbitrary body returning *UpdateComment1Response
func (c *ClientWithResponses) UpdateComment1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComment1Response, error) {
	rsp, err := c.UpdateComment1WithBody(ctx, projectKey, repositorySlug, pullRequestId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComment1Response(rsp)
}

func (c *ClientWithResponses) UpdateComment1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComment1Response, error) {
	rsp, err := c.UpdateComment1(ctx, projectKey, repositorySlug, pullRequestId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComment1Response(rsp)
}

// StreamChanges1WithResponse request returning *StreamChanges1Response
func (c *ClientWithResponses) StreamChanges1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *StreamChanges1Params, reqEditors ...RequestEditorFn) (*StreamChanges1Response, error) {
	rsp, err := c.StreamChanges1(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamChanges1Response(rsp)
}

// GetComments2WithResponse request returning *GetComments2Response
func (c *ClientWithResponses) GetComments2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetComments2Params, reqEditors ...RequestEditorFn) (*GetComments2Response, error) {
	rsp, err := c.GetComments2(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComments2Response(rsp)
}

// CreateComment2WithBodyWithResponse request with arbitrary body returning *CreateComment2Response
func (c *ClientWithResponses) CreateComment2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComment2Response, error) {
	rsp, err := c.CreateComment2WithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComment2Response(rsp)
}

func (c *ClientWithResponses) CreateComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body CreateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComment2Response, error) {
	rsp, err := c.CreateComment2(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComment2Response(rsp)
}

// DeleteComment2WithResponse request returning *DeleteComment2Response
func (c *ClientWithResponses) DeleteComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, params *DeleteComment2Params, reqEditors ...RequestEditorFn) (*DeleteComment2Response, error) {
	rsp, err := c.DeleteComment2(ctx, projectKey, repositorySlug, pullRequestId, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComment2Response(rsp)
}

// GetComment2WithResponse request returning *GetComment2Response
func (c *ClientWithResponses) GetComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, reqEditors ...RequestEditorFn) (*GetComment2Response, error) {
	rsp, err := c.GetComment2(ctx, projectKey, repositorySlug, pullRequestId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComment2Response(rsp)
}

// UpdateComment2WithBodyWithResponse request with arbitrary body returning *UpdateComment2Response
func (c *ClientWithResponses) UpdateComment2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComment2Response, error) {
	rsp, err := c.UpdateComment2WithBody(ctx, projectKey, repositorySlug, pullRequestId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComment2Response(rsp)
}

func (c *ClientWithResponses) UpdateComment2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body UpdateComment2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComment2Response, error) {
	rsp, err := c.UpdateComment2(ctx, projectKey, repositorySlug, pullRequestId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComment2Response(rsp)
}

// ApplySuggestionWithBodyWithResponse request with arbitrary body returning *ApplySuggestionResponse
func (c *ClientWithResponses) ApplySuggestionWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplySuggestionResponse, error) {
	rsp, err := c.ApplySuggestionWithBody(ctx, projectKey, repositorySlug, pullRequestId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplySuggestionResponse(rsp)
}

func (c *ClientWithResponses) ApplySuggestionWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, body ApplySuggestionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySuggestionResponse, error) {
	rsp, err := c.ApplySuggestion(ctx, projectKey, repositorySlug, pullRequestId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplySuggestionResponse(rsp)
}

// GetCommitMessageSuggestionWithResponse request returning *GetCommitMessageSuggestionResponse
func (c *ClientWithResponses) GetCommitMessageSuggestionWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetCommitMessageSuggestionResponse, error) {
	rsp, err := c.GetCommitMessageSuggestion(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitMessageSuggestionResponse(rsp)
}

// GetCommits1WithResponse request returning *GetCommits1Response
func (c *ClientWithResponses) GetCommits1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetCommits1Params, reqEditors ...RequestEditorFn) (*GetCommits1Response, error) {
	rsp, err := c.GetCommits1(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommits1Response(rsp)
}

// DeclineWithBodyWithResponse request with arbitrary body returning *DeclineResponse
func (c *ClientWithResponses) DeclineWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineResponse, error) {
	rsp, err := c.DeclineWithBody(ctx, projectKey, repositorySlug, pullRequestId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineResponse(rsp)
}

func (c *ClientWithResponses) DeclineWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *DeclineParams, body DeclineJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineResponse, error) {
	rsp, err := c.Decline(ctx, projectKey, repositorySlug, pullRequestId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineResponse(rsp)
}

// GetDiffStatsSummary2WithResponse request returning *GetDiffStatsSummary2Response
func (c *ClientWithResponses) GetDiffStatsSummary2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *GetDiffStatsSummary2Params, reqEditors ...RequestEditorFn) (*GetDiffStatsSummary2Response, error) {
	rsp, err := c.GetDiffStatsSummary2(ctx, projectKey, repositorySlug, pullRequestId, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiffStatsSummary2Response(rsp)
}

// StreamDiff2WithResponse request returning *StreamDiff2Response
func (c *ClientWithResponses) StreamDiff2WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, path string, params *StreamDiff2Params, reqEditors ...RequestEditorFn) (*StreamDiff2Response, error) {
	rsp, err := c.StreamDiff2(ctx, projectKey, repositorySlug, pullRequestId, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamDiff2Response(rsp)
}

// CanMergeWithResponse request returning *CanMergeResponse
func (c *ClientWithResponses) CanMergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CanMergeResponse, error) {
	rsp, err := c.CanMerge(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCanMergeResponse(rsp)
}

// MergeWithBodyWithResponse request with arbitrary body returning *MergeResponse
func (c *ClientWithResponses) MergeWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeResponse, error) {
	rsp, err := c.MergeWithBody(ctx, projectKey, repositorySlug, pullRequestId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeResponse(rsp)
}

func (c *ClientWithResponses) MergeWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *MergeParams, body MergeJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeResponse, error) {
	rsp, err := c.Merge(ctx, projectKey, repositorySlug, pullRequestId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeResponse(rsp)
}

// GetMergeBase1WithResponse request returning *GetMergeBase1Response
func (c *ClientWithResponses) GetMergeBase1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetMergeBase1Response, error) {
	rsp, err := c.GetMergeBase1(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMergeBase1Response(rsp)
}

// UnassignParticipantRole1WithResponse request returning *UnassignParticipantRole1Response
func (c *ClientWithResponses) UnassignParticipantRole1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *UnassignParticipantRole1Params, reqEditors ...RequestEditorFn) (*UnassignParticipantRole1Response, error) {
	rsp, err := c.UnassignParticipantRole1(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignParticipantRole1Response(rsp)
}

// ListParticipantsWithResponse request returning *ListParticipantsResponse
func (c *ClientWithResponses) ListParticipantsWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ListParticipantsParams, reqEditors ...RequestEditorFn) (*ListParticipantsResponse, error) {
	rsp, err := c.ListParticipants(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListParticipantsResponse(rsp)
}

// AssignParticipantRoleWithBodyWithResponse request with arbitrary body returning *AssignParticipantRoleResponse
func (c *ClientWithResponses) AssignParticipantRoleWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignParticipantRoleResponse, error) {
	rsp, err := c.AssignParticipantRoleWithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignParticipantRoleResponse(rsp)
}

func (c *ClientWithResponses) AssignParticipantRoleWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body AssignParticipantRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignParticipantRoleResponse, error) {
	rsp, err := c.AssignParticipantRole(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignParticipantRoleResponse(rsp)
}

// UnassignParticipantRoleWithResponse request returning *UnassignParticipantRoleResponse
func (c *ClientWithResponses) UnassignParticipantRoleWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, reqEditors ...RequestEditorFn) (*UnassignParticipantRoleResponse, error) {
	rsp, err := c.UnassignParticipantRole(ctx, projectKey, repositorySlug, pullRequestId, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignParticipantRoleResponse(rsp)
}

// UpdateStatusWithBodyWithResponse request with arbitrary body returning *UpdateStatusResponse
func (c *ClientWithResponses) UpdateStatusWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error) {
	rsp, err := c.UpdateStatusWithBody(ctx, projectKey, repositorySlug, pullRequestId, userSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateStatusWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, userSlug string, params *UpdateStatusParams, body UpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStatusResponse, error) {
	rsp, err := c.UpdateStatus(ctx, projectKey, repositorySlug, pullRequestId, userSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStatusResponse(rsp)
}

// ReopenWithBodyWithResponse request with arbitrary body returning *ReopenResponse
func (c *ClientWithResponses) ReopenWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReopenResponse, error) {
	rsp, err := c.ReopenWithBody(ctx, projectKey, repositorySlug, pullRequestId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReopenResponse(rsp)
}

func (c *ClientWithResponses) ReopenWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *ReopenParams, body ReopenJSONRequestBody, reqEditors ...RequestEditorFn) (*ReopenResponse, error) {
	rsp, err := c.Reopen(ctx, projectKey, repositorySlug, pullRequestId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReopenResponse(rsp)
}

// DiscardReviewWithResponse request returning *DiscardReviewResponse
func (c *ClientWithResponses) DiscardReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*DiscardReviewResponse, error) {
	rsp, err := c.DiscardReview(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscardReviewResponse(rsp)
}

// GetReviewWithResponse request returning *GetReviewResponse
func (c *ClientWithResponses) GetReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *GetReviewParams, reqEditors ...RequestEditorFn) (*GetReviewResponse, error) {
	rsp, err := c.GetReview(ctx, projectKey, repositorySlug, pullRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewResponse(rsp)
}

// FinishReviewWithBodyWithResponse request with arbitrary body returning *FinishReviewResponse
func (c *ClientWithResponses) FinishReviewWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FinishReviewResponse, error) {
	rsp, err := c.FinishReviewWithBody(ctx, projectKey, repositorySlug, pullRequestId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFinishReviewResponse(rsp)
}

func (c *ClientWithResponses) FinishReviewWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, params *FinishReviewParams, body FinishReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*FinishReviewResponse, error) {
	rsp, err := c.FinishReview(ctx, projectKey, repositorySlug, pullRequestId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFinishReviewResponse(rsp)
}

// Unwatch1WithResponse request returning *Unwatch1Response
func (c *ClientWithResponses) Unwatch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Unwatch1Response, error) {
	rsp, err := c.Unwatch1(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnwatch1Response(rsp)
}

// Watch1WithResponse request returning *Watch1Response
func (c *ClientWithResponses) Watch1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*Watch1Response, error) {
	rsp, err := c.Watch1(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatch1Response(rsp)
}

// StreamRawWithResponse request returning *StreamRawResponse
func (c *ClientWithResponses) StreamRawWithResponse(ctx context.Context, projectKey string, repositorySlug string, path string, params *StreamRawParams, reqEditors ...RequestEditorFn) (*StreamRawResponse, error) {
	rsp, err := c.StreamRaw(ctx, projectKey, repositorySlug, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRawResponse(rsp)
}

// StreamReadmeWithResponse request returning *StreamReadmeResponse
func (c *ClientWithResponses) StreamReadmeWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *StreamReadmeParams, reqEditors ...RequestEditorFn) (*StreamReadmeResponse, error) {
	rsp, err := c.StreamReadme(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamReadmeResponse(rsp)
}

// RetryCreateRepositoryWithResponse request returning *RetryCreateRepositoryResponse
func (c *ClientWithResponses) RetryCreateRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*RetryCreateRepositoryResponse, error) {
	rsp, err := c.RetryCreateRepository(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryCreateRepositoryResponse(rsp)
}

// GetRefChangeActivityWithResponse request returning *GetRefChangeActivityResponse
func (c *ClientWithResponses) GetRefChangeActivityWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRefChangeActivityParams, reqEditors ...RequestEditorFn) (*GetRefChangeActivityResponse, error) {
	rsp, err := c.GetRefChangeActivity(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefChangeActivityResponse(rsp)
}

// FindBranchesWithResponse request returning *FindBranchesResponse
func (c *ClientWithResponses) FindBranchesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *FindBranchesParams, reqEditors ...RequestEditorFn) (*FindBranchesResponse, error) {
	rsp, err := c.FindBranches(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBranchesResponse(rsp)
}

// GetRelatedRepositoriesWithResponse request returning *GetRelatedRepositoriesResponse
func (c *ClientWithResponses) GetRelatedRepositoriesWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRelatedRepositoriesParams, reqEditors ...RequestEditorFn) (*GetRelatedRepositoriesResponse, error) {
	rsp, err := c.GetRelatedRepositories(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRelatedRepositoriesResponse(rsp)
}

// Search2WithResponse request returning *Search2Response
func (c *ClientWithResponses) Search2WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *Search2Params, reqEditors ...RequestEditorFn) (*Search2Response, error) {
	rsp, err := c.Search2(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch2Response(rsp)
}

// CreateAllowlistRule1WithBodyWithResponse request with arbitrary body returning *CreateAllowlistRule1Response
func (c *ClientWithResponses) CreateAllowlistRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistRule1Response, error) {
	rsp, err := c.CreateAllowlistRule1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllowlistRule1Response(rsp)
}

// DeleteAllowlistRule1WithResponse request returning *DeleteAllowlistRule1Response
func (c *ClientWithResponses) DeleteAllowlistRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteAllowlistRule1Response, error) {
	rsp, err := c.DeleteAllowlistRule1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowlistRule1Response(rsp)
}

// GetAllowlistRule1WithResponse request returning *GetAllowlistRule1Response
func (c *ClientWithResponses) GetAllowlistRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetAllowlistRule1Response, error) {
	rsp, err := c.GetAllowlistRule1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllowlistRule1Response(rsp)
}

// EditAllowlistRule1WithBodyWithResponse request with arbitrary body returning *EditAllowlistRule1Response
func (c *ClientWithResponses) EditAllowlistRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAllowlistRule1Response, error) {
	rsp, err := c.EditAllowlistRule1WithBody(ctx, projectKey, repositorySlug, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAllowlistRule1Response(rsp)
}

// Search3WithResponse request returning *Search3Response
func (c *ClientWithResponses) Search3WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *Search3Params, reqEditors ...RequestEditorFn) (*Search3Response, error) {
	rsp, err := c.Search3(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch3Response(rsp)
}

// CreateRule1WithBodyWithResponse request with arbitrary body returning *CreateRule1Response
func (c *ClientWithResponses) CreateRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRule1Response, error) {
	rsp, err := c.CreateRule1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRule1Response(rsp)
}

// DeleteRule1WithResponse request returning *DeleteRule1Response
func (c *ClientWithResponses) DeleteRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteRule1Response, error) {
	rsp, err := c.DeleteRule1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRule1Response(rsp)
}

// GetRule1WithResponse request returning *GetRule1Response
func (c *ClientWithResponses) GetRule1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetRule1Response, error) {
	rsp, err := c.GetRule1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRule1Response(rsp)
}

// EditRule1WithBodyWithResponse request with arbitrary body returning *EditRule1Response
func (c *ClientWithResponses) EditRule1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRule1Response, error) {
	rsp, err := c.EditRule1WithBody(ctx, projectKey, repositorySlug, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditRule1Response(rsp)
}

// DeleteAutoDeclineSettings1WithResponse request returning *DeleteAutoDeclineSettings1Response
func (c *ClientWithResponses) DeleteAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteAutoDeclineSettings1Response, error) {
	rsp, err := c.DeleteAutoDeclineSettings1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAutoDeclineSettings1Response(rsp)
}

// GetAutoDeclineSettings1WithResponse request returning *GetAutoDeclineSettings1Response
func (c *ClientWithResponses) GetAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetAutoDeclineSettings1Response, error) {
	rsp, err := c.GetAutoDeclineSettings1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoDeclineSettings1Response(rsp)
}

// SetAutoDeclineSettings1WithBodyWithResponse request with arbitrary body returning *SetAutoDeclineSettings1Response
func (c *ClientWithResponses) SetAutoDeclineSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettings1Response, error) {
	rsp, err := c.SetAutoDeclineSettings1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoDeclineSettings1Response(rsp)
}

func (c *ClientWithResponses) SetAutoDeclineSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetAutoDeclineSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettings1Response, error) {
	rsp, err := c.SetAutoDeclineSettings1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoDeclineSettings1Response(rsp)
}

// Delete5WithResponse request returning *Delete5Response
func (c *ClientWithResponses) Delete5WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Delete5Response, error) {
	rsp, err := c.Delete5(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete5Response(rsp)
}

// Get5WithResponse request returning *Get5Response
func (c *ClientWithResponses) Get5WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Get5Response, error) {
	rsp, err := c.Get5(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet5Response(rsp)
}

// Set1WithBodyWithResponse request with arbitrary body returning *Set1Response
func (c *ClientWithResponses) Set1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Set1Response, error) {
	rsp, err := c.Set1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet1Response(rsp)
}

func (c *ClientWithResponses) Set1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Set1JSONRequestBody, reqEditors ...RequestEditorFn) (*Set1Response, error) {
	rsp, err := c.Set1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSet1Response(rsp)
}

// GetRepositoryHooks1WithResponse request returning *GetRepositoryHooks1Response
func (c *ClientWithResponses) GetRepositoryHooks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRepositoryHooks1Params, reqEditors ...RequestEditorFn) (*GetRepositoryHooks1Response, error) {
	rsp, err := c.GetRepositoryHooks1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryHooks1Response(rsp)
}

// DeleteRepositoryHookWithResponse request returning *DeleteRepositoryHookResponse
func (c *ClientWithResponses) DeleteRepositoryHookWithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*DeleteRepositoryHookResponse, error) {
	rsp, err := c.DeleteRepositoryHook(ctx, projectKey, repositorySlug, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryHookResponse(rsp)
}

// GetRepositoryHook1WithResponse request returning *GetRepositoryHook1Response
func (c *ClientWithResponses) GetRepositoryHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*GetRepositoryHook1Response, error) {
	rsp, err := c.GetRepositoryHook1(ctx, projectKey, repositorySlug, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryHook1Response(rsp)
}

// DisableHook1WithResponse request returning *DisableHook1Response
func (c *ClientWithResponses) DisableHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*DisableHook1Response, error) {
	rsp, err := c.DisableHook1(ctx, projectKey, repositorySlug, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableHook1Response(rsp)
}

// EnableHook1WithResponse request returning *EnableHook1Response
func (c *ClientWithResponses) EnableHook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, params *EnableHook1Params, reqEditors ...RequestEditorFn) (*EnableHook1Response, error) {
	rsp, err := c.EnableHook1(ctx, projectKey, repositorySlug, hookKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableHook1Response(rsp)
}

// GetSettings1WithResponse request returning *GetSettings1Response
func (c *ClientWithResponses) GetSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, reqEditors ...RequestEditorFn) (*GetSettings1Response, error) {
	rsp, err := c.GetSettings1(ctx, projectKey, repositorySlug, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettings1Response(rsp)
}

// SetSettings1WithBodyWithResponse request with arbitrary body returning *SetSettings1Response
func (c *ClientWithResponses) SetSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettings1Response, error) {
	rsp, err := c.SetSettings1WithBody(ctx, projectKey, repositorySlug, hookKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettings1Response(rsp)
}

func (c *ClientWithResponses) SetSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, hookKey string, body SetSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettings1Response, error) {
	rsp, err := c.SetSettings1(ctx, projectKey, repositorySlug, hookKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettings1Response(rsp)
}

// GetPullRequestSettings1WithResponse request returning *GetPullRequestSettings1Response
func (c *ClientWithResponses) GetPullRequestSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetPullRequestSettings1Response, error) {
	rsp, err := c.GetPullRequestSettings1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestSettings1Response(rsp)
}

// UpdatePullRequestSettings1WithBodyWithResponse request with arbitrary body returning *UpdatePullRequestSettings1Response
func (c *ClientWithResponses) UpdatePullRequestSettings1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettings1Response, error) {
	rsp, err := c.UpdatePullRequestSettings1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestSettings1Response(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestSettings1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body UpdatePullRequestSettings1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettings1Response, error) {
	rsp, err := c.UpdatePullRequestSettings1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestSettings1Response(rsp)
}

// GetReviewerGroups1WithResponse request returning *GetReviewerGroups1Response
func (c *ClientWithResponses) GetReviewerGroups1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewerGroups1Params, reqEditors ...RequestEditorFn) (*GetReviewerGroups1Response, error) {
	rsp, err := c.GetReviewerGroups1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewerGroups1Response(rsp)
}

// Create2WithBodyWithResponse request with arbitrary body returning *Create2Response
func (c *ClientWithResponses) Create2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create2Response, error) {
	rsp, err := c.Create2WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate2Response(rsp)
}

func (c *ClientWithResponses) Create2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*Create2Response, error) {
	rsp, err := c.Create2(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate2Response(rsp)
}

// Delete7WithResponse request returning *Delete7Response
func (c *ClientWithResponses) Delete7WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*Delete7Response, error) {
	rsp, err := c.Delete7(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete7Response(rsp)
}

// GetReviewerGroup1WithResponse request returning *GetReviewerGroup1Response
func (c *ClientWithResponses) GetReviewerGroup1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetReviewerGroup1Response, error) {
	rsp, err := c.GetReviewerGroup1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewerGroup1Response(rsp)
}

// Update2WithBodyWithResponse request with arbitrary body returning *Update2Response
func (c *ClientWithResponses) Update2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Update2Response, error) {
	rsp, err := c.Update2WithBody(ctx, projectKey, repositorySlug, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdate2Response(rsp)
}

func (c *ClientWithResponses) Update2WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, body Update2JSONRequestBody, reqEditors ...RequestEditorFn) (*Update2Response, error) {
	rsp, err := c.Update2(ctx, projectKey, repositorySlug, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdate2Response(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// CreateTagForRepositoryWithBodyWithResponse request with arbitrary body returning *CreateTagForRepositoryResponse
func (c *ClientWithResponses) CreateTagForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagForRepositoryResponse, error) {
	rsp, err := c.CreateTagForRepositoryWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagForRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateTagForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateTagForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagForRepositoryResponse, error) {
	rsp, err := c.CreateTagForRepository(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagForRepositoryResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, projectKey, repositorySlug, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// Unwatch2WithResponse request returning *Unwatch2Response
func (c *ClientWithResponses) Unwatch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*Unwatch2Response, error) {
	rsp, err := c.Unwatch2(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnwatch2Response(rsp)
}

// Watch2WithBodyWithResponse request with arbitrary body returning *Watch2Response
func (c *ClientWithResponses) Watch2WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Watch2Response, error) {
	rsp, err := c.Watch2WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatch2Response(rsp)
}

func (c *ClientWithResponses) Watch2WithResponse(ctx context.Context, projectKey string, repositorySlug string, body Watch2JSONRequestBody, reqEditors ...RequestEditorFn) (*Watch2Response, error) {
	rsp, err := c.Watch2(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatch2Response(rsp)
}

// FindWebhooks1WithResponse request returning *FindWebhooks1Response
func (c *ClientWithResponses) FindWebhooks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *FindWebhooks1Params, reqEditors ...RequestEditorFn) (*FindWebhooks1Response, error) {
	rsp, err := c.FindWebhooks1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWebhooks1Response(rsp)
}

// CreateWebhook1WithBodyWithResponse request with arbitrary body returning *CreateWebhook1Response
func (c *ClientWithResponses) CreateWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhook1Response, error) {
	rsp, err := c.CreateWebhook1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhook1Response(rsp)
}

func (c *ClientWithResponses) CreateWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhook1Response, error) {
	rsp, err := c.CreateWebhook1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhook1Response(rsp)
}

// SearchWebhooksWithResponse request returning *SearchWebhooksResponse
func (c *ClientWithResponses) SearchWebhooksWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *SearchWebhooksParams, reqEditors ...RequestEditorFn) (*SearchWebhooksResponse, error) {
	rsp, err := c.SearchWebhooks(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWebhooksResponse(rsp)
}

// TestWebhook1WithBodyWithResponse request with arbitrary body returning *TestWebhook1Response
func (c *ClientWithResponses) TestWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhook1Response, error) {
	rsp, err := c.TestWebhook1WithBody(ctx, projectKey, repositorySlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhook1Response(rsp)
}

func (c *ClientWithResponses) TestWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *TestWebhook1Params, body TestWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhook1Response, error) {
	rsp, err := c.TestWebhook1(ctx, projectKey, repositorySlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhook1Response(rsp)
}

// DeleteWebhook1WithResponse request returning *DeleteWebhook1Response
func (c *ClientWithResponses) DeleteWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhook1Response, error) {
	rsp, err := c.DeleteWebhook1(ctx, projectKey, repositorySlug, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhook1Response(rsp)
}

// GetWebhook1WithResponse request returning *GetWebhook1Response
func (c *ClientWithResponses) GetWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetWebhook1Params, reqEditors ...RequestEditorFn) (*GetWebhook1Response, error) {
	rsp, err := c.GetWebhook1(ctx, projectKey, repositorySlug, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhook1Response(rsp)
}

// UpdateWebhook1WithBodyWithResponse request with arbitrary body returning *UpdateWebhook1Response
func (c *ClientWithResponses) UpdateWebhook1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhook1Response, error) {
	rsp, err := c.UpdateWebhook1WithBody(ctx, projectKey, repositorySlug, webhookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhook1Response(rsp)
}

func (c *ClientWithResponses) UpdateWebhook1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, body UpdateWebhook1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhook1Response, error) {
	rsp, err := c.UpdateWebhook1(ctx, projectKey, repositorySlug, webhookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhook1Response(rsp)
}

// GetLatestInvocation1WithResponse request returning *GetLatestInvocation1Response
func (c *ClientWithResponses) GetLatestInvocation1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetLatestInvocation1Params, reqEditors ...RequestEditorFn) (*GetLatestInvocation1Response, error) {
	rsp, err := c.GetLatestInvocation1(ctx, projectKey, repositorySlug, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestInvocation1Response(rsp)
}

// GetStatistics1WithResponse request returning *GetStatistics1Response
func (c *ClientWithResponses) GetStatistics1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, params *GetStatistics1Params, reqEditors ...RequestEditorFn) (*GetStatistics1Response, error) {
	rsp, err := c.GetStatistics1(ctx, projectKey, repositorySlug, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatistics1Response(rsp)
}

// GetStatisticsSummary1WithResponse request returning *GetStatisticsSummary1Response
func (c *ClientWithResponses) GetStatisticsSummary1WithResponse(ctx context.Context, projectKey string, repositorySlug string, webhookId string, reqEditors ...RequestEditorFn) (*GetStatisticsSummary1Response, error) {
	rsp, err := c.GetStatisticsSummary1(ctx, projectKey, repositorySlug, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsSummary1Response(rsp)
}

// SearchAllowlistRuleWithResponse request returning *SearchAllowlistRuleResponse
func (c *ClientWithResponses) SearchAllowlistRuleWithResponse(ctx context.Context, projectKey string, params *SearchAllowlistRuleParams, reqEditors ...RequestEditorFn) (*SearchAllowlistRuleResponse, error) {
	rsp, err := c.SearchAllowlistRule(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAllowlistRuleResponse(rsp)
}

// CreateAllowlistRuleWithBodyWithResponse request with arbitrary body returning *CreateAllowlistRuleResponse
func (c *ClientWithResponses) CreateAllowlistRuleWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistRuleResponse, error) {
	rsp, err := c.CreateAllowlistRuleWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllowlistRuleResponse(rsp)
}

// DeleteAllowlistRuleWithResponse request returning *DeleteAllowlistRuleResponse
func (c *ClientWithResponses) DeleteAllowlistRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteAllowlistRuleResponse, error) {
	rsp, err := c.DeleteAllowlistRule(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowlistRuleResponse(rsp)
}

// GetAllowlistRuleWithResponse request returning *GetAllowlistRuleResponse
func (c *ClientWithResponses) GetAllowlistRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetAllowlistRuleResponse, error) {
	rsp, err := c.GetAllowlistRule(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllowlistRuleResponse(rsp)
}

// EditAllowlistRuleWithBodyWithResponse request with arbitrary body returning *EditAllowlistRuleResponse
func (c *ClientWithResponses) EditAllowlistRuleWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAllowlistRuleResponse, error) {
	rsp, err := c.EditAllowlistRuleWithBody(ctx, projectKey, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAllowlistRuleResponse(rsp)
}

// Search1WithResponse request returning *Search1Response
func (c *ClientWithResponses) Search1WithResponse(ctx context.Context, projectKey string, params *Search1Params, reqEditors ...RequestEditorFn) (*Search1Response, error) {
	rsp, err := c.Search1(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch1Response(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleWithResponse request returning *GetRuleResponse
func (c *ClientWithResponses) GetRuleWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetRuleResponse, error) {
	rsp, err := c.GetRule(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleResponse(rsp)
}

// EditRuleWithBodyWithResponse request with arbitrary body returning *EditRuleResponse
func (c *ClientWithResponses) EditRuleWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRuleResponse, error) {
	rsp, err := c.EditRuleWithBody(ctx, projectKey, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditRuleResponse(rsp)
}

// Delete9WithResponse request returning *Delete9Response
func (c *ClientWithResponses) Delete9WithResponse(ctx context.Context, projectKey string, params *Delete9Params, reqEditors ...RequestEditorFn) (*Delete9Response, error) {
	rsp, err := c.Delete9(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete9Response(rsp)
}

// Get7WithResponse request returning *Get7Response
func (c *ClientWithResponses) Get7WithResponse(ctx context.Context, projectKey string, params *Get7Params, reqEditors ...RequestEditorFn) (*Get7Response, error) {
	rsp, err := c.Get7(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet7Response(rsp)
}

// Create3WithBodyWithResponse request with arbitrary body returning *Create3Response
func (c *ClientWithResponses) Create3WithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create3Response, error) {
	rsp, err := c.Create3WithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate3Response(rsp)
}

func (c *ClientWithResponses) Create3WithResponse(ctx context.Context, projectKey string, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*Create3Response, error) {
	rsp, err := c.Create3(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate3Response(rsp)
}

// GetAllWithResponse request returning *GetAllResponse
func (c *ClientWithResponses) GetAllWithResponse(ctx context.Context, projectKey string, params *GetAllParams, reqEditors ...RequestEditorFn) (*GetAllResponse, error) {
	rsp, err := c.GetAll(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllResponse(rsp)
}

// DeleteAutoDeclineSettingsWithResponse request returning *DeleteAutoDeclineSettingsResponse
func (c *ClientWithResponses) DeleteAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteAutoDeclineSettingsResponse, error) {
	rsp, err := c.DeleteAutoDeclineSettings(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAutoDeclineSettingsResponse(rsp)
}

// GetAutoDeclineSettingsWithResponse request returning *GetAutoDeclineSettingsResponse
func (c *ClientWithResponses) GetAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetAutoDeclineSettingsResponse, error) {
	rsp, err := c.GetAutoDeclineSettings(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoDeclineSettingsResponse(rsp)
}

// SetAutoDeclineSettingsWithBodyWithResponse request with arbitrary body returning *SetAutoDeclineSettingsResponse
func (c *ClientWithResponses) SetAutoDeclineSettingsWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettingsResponse, error) {
	rsp, err := c.SetAutoDeclineSettingsWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoDeclineSettingsResponse(rsp)
}

func (c *ClientWithResponses) SetAutoDeclineSettingsWithResponse(ctx context.Context, projectKey string, body SetAutoDeclineSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoDeclineSettingsResponse, error) {
	rsp, err := c.SetAutoDeclineSettings(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoDeclineSettingsResponse(rsp)
}

// Delete4WithResponse request returning *Delete4Response
func (c *ClientWithResponses) Delete4WithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*Delete4Response, error) {
	rsp, err := c.Delete4(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete4Response(rsp)
}

// Get4WithResponse request returning *Get4Response
func (c *ClientWithResponses) Get4WithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*Get4Response, error) {
	rsp, err := c.Get4(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGet4Response(rsp)
}

// SetWithBodyWithResponse request with arbitrary body returning *SetResponse
func (c *ClientWithResponses) SetWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetResponse, error) {
	rsp, err := c.SetWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetResponse(rsp)
}

func (c *ClientWithResponses) SetWithResponse(ctx context.Context, projectKey string, body SetJSONRequestBody, reqEditors ...RequestEditorFn) (*SetResponse, error) {
	rsp, err := c.Set(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetResponse(rsp)
}

// GetRepositoryHooksWithResponse request returning *GetRepositoryHooksResponse
func (c *ClientWithResponses) GetRepositoryHooksWithResponse(ctx context.Context, projectKey string, params *GetRepositoryHooksParams, reqEditors ...RequestEditorFn) (*GetRepositoryHooksResponse, error) {
	rsp, err := c.GetRepositoryHooks(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryHooksResponse(rsp)
}

// GetRepositoryHookWithResponse request returning *GetRepositoryHookResponse
func (c *ClientWithResponses) GetRepositoryHookWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*GetRepositoryHookResponse, error) {
	rsp, err := c.GetRepositoryHook(ctx, projectKey, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryHookResponse(rsp)
}

// DisableHookWithResponse request returning *DisableHookResponse
func (c *ClientWithResponses) DisableHookWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*DisableHookResponse, error) {
	rsp, err := c.DisableHook(ctx, projectKey, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableHookResponse(rsp)
}

// EnableHookWithResponse request returning *EnableHookResponse
func (c *ClientWithResponses) EnableHookWithResponse(ctx context.Context, projectKey string, hookKey string, params *EnableHookParams, reqEditors ...RequestEditorFn) (*EnableHookResponse, error) {
	rsp, err := c.EnableHook(ctx, projectKey, hookKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableHookResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, projectKey string, hookKey string, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, projectKey, hookKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// SetSettingsWithBodyWithResponse request with arbitrary body returning *SetSettingsResponse
func (c *ClientWithResponses) SetSettingsWithBodyWithResponse(ctx context.Context, projectKey string, hookKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSettingsResponse, error) {
	rsp, err := c.SetSettingsWithBody(ctx, projectKey, hookKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettingsResponse(rsp)
}

func (c *ClientWithResponses) SetSettingsWithResponse(ctx context.Context, projectKey string, hookKey string, body SetSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSettingsResponse, error) {
	rsp, err := c.SetSettings(ctx, projectKey, hookKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSettingsResponse(rsp)
}

// GetPullRequestSettingsWithResponse request returning *GetPullRequestSettingsResponse
func (c *ClientWithResponses) GetPullRequestSettingsWithResponse(ctx context.Context, projectKey string, scmId string, reqEditors ...RequestEditorFn) (*GetPullRequestSettingsResponse, error) {
	rsp, err := c.GetPullRequestSettings(ctx, projectKey, scmId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestSettingsResponse(rsp)
}

// UpdatePullRequestSettingsWithBodyWithResponse request with arbitrary body returning *UpdatePullRequestSettingsResponse
func (c *ClientWithResponses) UpdatePullRequestSettingsWithBodyWithResponse(ctx context.Context, projectKey string, scmId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettingsResponse, error) {
	rsp, err := c.UpdatePullRequestSettingsWithBody(ctx, projectKey, scmId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestSettingsWithResponse(ctx context.Context, projectKey string, scmId string, body UpdatePullRequestSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestSettingsResponse, error) {
	rsp, err := c.UpdatePullRequestSettings(ctx, projectKey, scmId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestSettingsResponse(rsp)
}

// GetReviewerGroupsWithResponse request returning *GetReviewerGroupsResponse
func (c *ClientWithResponses) GetReviewerGroupsWithResponse(ctx context.Context, projectKey string, params *GetReviewerGroupsParams, reqEditors ...RequestEditorFn) (*GetReviewerGroupsResponse, error) {
	rsp, err := c.GetReviewerGroups(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewerGroupsResponse(rsp)
}

// Create1WithBodyWithResponse request with arbitrary body returning *Create1Response
func (c *ClientWithResponses) Create1WithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create1Response, error) {
	rsp, err := c.Create1WithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate1Response(rsp)
}

func (c *ClientWithResponses) Create1WithResponse(ctx context.Context, projectKey string, body Create1JSONRequestBody, reqEditors ...RequestEditorFn) (*Create1Response, error) {
	rsp, err := c.Create1(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate1Response(rsp)
}

// Delete6WithResponse request returning *Delete6Response
func (c *ClientWithResponses) Delete6WithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*Delete6Response, error) {
	rsp, err := c.Delete6(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelete6Response(rsp)
}

// GetReviewerGroupWithResponse request returning *GetReviewerGroupResponse
func (c *ClientWithResponses) GetReviewerGroupWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetReviewerGroupResponse, error) {
	rsp, err := c.GetReviewerGroup(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewerGroupResponse(rsp)
}

// Update1WithBodyWithResponse request with arbitrary body returning *Update1Response
func (c *ClientWithResponses) Update1WithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Update1Response, error) {
	rsp, err := c.Update1WithBody(ctx, projectKey, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdate1Response(rsp)
}

func (c *ClientWithResponses) Update1WithResponse(ctx context.Context, projectKey string, id string, body Update1JSONRequestBody, reqEditors ...RequestEditorFn) (*Update1Response, error) {
	rsp, err := c.Update1(ctx, projectKey, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdate1Response(rsp)
}

// FindWebhooksWithResponse request returning *FindWebhooksResponse
func (c *ClientWithResponses) FindWebhooksWithResponse(ctx context.Context, projectKey string, params *FindWebhooksParams, reqEditors ...RequestEditorFn) (*FindWebhooksResponse, error) {
	rsp, err := c.FindWebhooks(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWebhooksResponse(rsp)
}

// CreateWebhookWithBodyWithResponse request with arbitrary body returning *CreateWebhookResponse
func (c *ClientWithResponses) CreateWebhookWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhookWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookWithResponse(ctx context.Context, projectKey string, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhook(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

// TestWebhookWithBodyWithResponse request with arbitrary body returning *TestWebhookResponse
func (c *ClientWithResponses) TestWebhookWithBodyWithResponse(ctx context.Context, projectKey string, params *TestWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error) {
	rsp, err := c.TestWebhookWithBody(ctx, projectKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhookResponse(rsp)
}

func (c *ClientWithResponses) TestWebhookWithResponse(ctx context.Context, projectKey string, params *TestWebhookParams, body TestWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*TestWebhookResponse, error) {
	rsp, err := c.TestWebhook(ctx, projectKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestWebhookResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, projectKey, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, projectKey, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// UpdateWebhookWithBodyWithResponse request with arbitrary body returning *UpdateWebhookResponse
func (c *ClientWithResponses) UpdateWebhookWithBodyWithResponse(ctx context.Context, projectKey string, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithBody(ctx, projectKey, webhookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithResponse(ctx context.Context, projectKey string, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhook(ctx, projectKey, webhookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

// GetLatestInvocationWithResponse request returning *GetLatestInvocationResponse
func (c *ClientWithResponses) GetLatestInvocationWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetLatestInvocationParams, reqEditors ...RequestEditorFn) (*GetLatestInvocationResponse, error) {
	rsp, err := c.GetLatestInvocation(ctx, projectKey, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestInvocationResponse(rsp)
}

// GetStatisticsWithResponse request returning *GetStatisticsResponse
func (c *ClientWithResponses) GetStatisticsWithResponse(ctx context.Context, projectKey string, webhookId string, params *GetStatisticsParams, reqEditors ...RequestEditorFn) (*GetStatisticsResponse, error) {
	rsp, err := c.GetStatistics(ctx, projectKey, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsResponse(rsp)
}

// GetStatisticsSummaryWithResponse request returning *GetStatisticsSummaryResponse
func (c *ClientWithResponses) GetStatisticsSummaryWithResponse(ctx context.Context, projectKey string, webhookId string, reqEditors ...RequestEditorFn) (*GetStatisticsSummaryResponse, error) {
	rsp, err := c.GetStatisticsSummary(ctx, projectKey, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsSummaryResponse(rsp)
}

// GetRepositories1WithResponse request returning *GetRepositories1Response
func (c *ClientWithResponses) GetRepositories1WithResponse(ctx context.Context, params *GetRepositories1Params, reqEditors ...RequestEditorFn) (*GetRepositories1Response, error) {
	rsp, err := c.GetRepositories1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositories1Response(rsp)
}

// FindExemptReposByScopeWithResponse request returning *FindExemptReposByScopeResponse
func (c *ClientWithResponses) FindExemptReposByScopeWithResponse(ctx context.Context, params *FindExemptReposByScopeParams, reqEditors ...RequestEditorFn) (*FindExemptReposByScopeResponse, error) {
	rsp, err := c.FindExemptReposByScope(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindExemptReposByScopeResponse(rsp)
}

// BulkAddExemptRepositoriesWithBodyWithResponse request with arbitrary body returning *BulkAddExemptRepositoriesResponse
func (c *ClientWithResponses) BulkAddExemptRepositoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddExemptRepositoriesResponse, error) {
	rsp, err := c.BulkAddExemptRepositoriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddExemptRepositoriesResponse(rsp)
}

// Search4WithResponse request returning *Search4Response
func (c *ClientWithResponses) Search4WithResponse(ctx context.Context, params *Search4Params, reqEditors ...RequestEditorFn) (*Search4Response, error) {
	rsp, err := c.Search4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearch4Response(rsp)
}

// CreateRule2WithBodyWithResponse request with arbitrary body returning *CreateRule2Response
func (c *ClientWithResponses) CreateRule2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRule2Response, error) {
	rsp, err := c.CreateRule2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRule2Response(rsp)
}

// DeleteRule2WithResponse request returning *DeleteRule2Response
func (c *ClientWithResponses) DeleteRule2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRule2Response, error) {
	rsp, err := c.DeleteRule2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRule2Response(rsp)
}

// GetRule2WithResponse request returning *GetRule2Response
func (c *ClientWithResponses) GetRule2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRule2Response, error) {
	rsp, err := c.GetRule2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRule2Response(rsp)
}

// EditRule2WithBodyWithResponse request with arbitrary body returning *EditRule2Response
func (c *ClientWithResponses) EditRule2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditRule2Response, error) {
	rsp, err := c.EditRule2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditRule2Response(rsp)
}

// GetAllCertificatesWithResponse request returning *GetAllCertificatesResponse
func (c *ClientWithResponses) GetAllCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCertificatesResponse, error) {
	rsp, err := c.GetAllCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCertificatesResponse(rsp)
}

// CreateCertificateWithBodyWithResponse request with arbitrary body returning *CreateCertificateResponse
func (c *ClientWithResponses) CreateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertificateResponse, error) {
	rsp, err := c.CreateCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertificateResponse(rsp)
}

// UpdateCertificateRevocationListEntriesWithResponse request returning *UpdateCertificateRevocationListEntriesResponse
func (c *ClientWithResponses) UpdateCertificateRevocationListEntriesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UpdateCertificateRevocationListEntriesResponse, error) {
	rsp, err := c.UpdateCertificateRevocationListEntries(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCertificateRevocationListEntriesResponse(rsp)
}

// DeleteCertificateWithResponse request returning *DeleteCertificateResponse
func (c *ClientWithResponses) DeleteCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCertificateResponse, error) {
	rsp, err := c.DeleteCertificate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCertificateResponse(rsp)
}

// GetSystemSigningConfigurationWithResponse request returning *GetSystemSigningConfigurationResponse
func (c *ClientWithResponses) GetSystemSigningConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSigningConfigurationResponse, error) {
	rsp, err := c.GetSystemSigningConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSigningConfigurationResponse(rsp)
}

// UpdateSystemSigningConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateSystemSigningConfigurationResponse
func (c *ClientWithResponses) UpdateSystemSigningConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSystemSigningConfigurationResponse, error) {
	rsp, err := c.UpdateSystemSigningConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemSigningConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSystemSigningConfigurationWithResponse(ctx context.Context, body UpdateSystemSigningConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSystemSigningConfigurationResponse, error) {
	rsp, err := c.UpdateSystemSigningConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSystemSigningConfigurationResponse(rsp)
}

// GetUsers2WithResponse request returning *GetUsers2Response
func (c *ClientWithResponses) GetUsers2WithResponse(ctx context.Context, params *GetUsers2Params, reqEditors ...RequestEditorFn) (*GetUsers2Response, error) {
	rsp, err := c.GetUsers2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsers2Response(rsp)
}

// UpdateUserDetails1WithBodyWithResponse request with arbitrary body returning *UpdateUserDetails1Response
func (c *ClientWithResponses) UpdateUserDetails1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDetails1Response, error) {
	rsp, err := c.UpdateUserDetails1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDetails1Response(rsp)
}

func (c *ClientWithResponses) UpdateUserDetails1WithResponse(ctx context.Context, body UpdateUserDetails1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDetails1Response, error) {
	rsp, err := c.UpdateUserDetails1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDetails1Response(rsp)
}

// UpdateUserPassword1WithBodyWithResponse request with arbitrary body returning *UpdateUserPassword1Response
func (c *ClientWithResponses) UpdateUserPassword1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPassword1Response, error) {
	rsp, err := c.UpdateUserPassword1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPassword1Response(rsp)
}

func (c *ClientWithResponses) UpdateUserPassword1WithResponse(ctx context.Context, body UpdateUserPassword1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPassword1Response, error) {
	rsp, err := c.UpdateUserPassword1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPassword1Response(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// DeleteAvatarWithResponse request returning *DeleteAvatarResponse
func (c *ClientWithResponses) DeleteAvatarWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*DeleteAvatarResponse, error) {
	rsp, err := c.DeleteAvatar(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAvatarResponse(rsp)
}

// UploadAvatar1WithBodyWithResponse request with arbitrary body returning *UploadAvatar1Response
func (c *ClientWithResponses) UploadAvatar1WithBodyWithResponse(ctx context.Context, userSlug string, params *UploadAvatar1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAvatar1Response, error) {
	rsp, err := c.UploadAvatar1WithBody(ctx, userSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAvatar1Response(rsp)
}

// GetUserSettingsWithResponse request returning *GetUserSettingsResponse
func (c *ClientWithResponses) GetUserSettingsWithResponse(ctx context.Context, userSlug string, reqEditors ...RequestEditorFn) (*GetUserSettingsResponse, error) {
	rsp, err := c.GetUserSettings(ctx, userSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSettingsResponse(rsp)
}

// UpdateSettingsWithBodyWithResponse request with arbitrary body returning *UpdateSettingsResponse
func (c *ClientWithResponses) UpdateSettingsWithBodyWithResponse(ctx context.Context, userSlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error) {
	rsp, err := c.UpdateSettingsWithBody(ctx, userSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsWithResponse(ctx context.Context, userSlug string, body UpdateSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsResponse, error) {
	rsp, err := c.UpdateSettings(ctx, userSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsResponse(rsp)
}

// DismissRetentionConfigReviewNotificationWithResponse request returning *DismissRetentionConfigReviewNotificationResponse
func (c *ClientWithResponses) DismissRetentionConfigReviewNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DismissRetentionConfigReviewNotificationResponse, error) {
	rsp, err := c.DismissRetentionConfigReviewNotification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDismissRetentionConfigReviewNotificationResponse(rsp)
}

// GetRestrictions1WithResponse request returning *GetRestrictions1Response
func (c *ClientWithResponses) GetRestrictions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetRestrictions1Params, reqEditors ...RequestEditorFn) (*GetRestrictions1Response, error) {
	rsp, err := c.GetRestrictions1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestrictions1Response(rsp)
}

// CreateRestrictions1WithBodyWithResponse request with arbitrary body returning *CreateRestrictions1Response
func (c *ClientWithResponses) CreateRestrictions1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestrictions1Response, error) {
	rsp, err := c.CreateRestrictions1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestrictions1Response(rsp)
}

func (c *ClientWithResponses) CreateRestrictions1WithApplicationVndAtlBitbucketBulkPlusJSONBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateRestrictions1ApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestrictions1Response, error) {
	rsp, err := c.CreateRestrictions1WithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestrictions1Response(rsp)
}

// DeleteRestriction1WithResponse request returning *DeleteRestriction1Response
func (c *ClientWithResponses) DeleteRestriction1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*DeleteRestriction1Response, error) {
	rsp, err := c.DeleteRestriction1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRestriction1Response(rsp)
}

// GetRestriction1WithResponse request returning *GetRestriction1Response
func (c *ClientWithResponses) GetRestriction1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, reqEditors ...RequestEditorFn) (*GetRestriction1Response, error) {
	rsp, err := c.GetRestriction1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestriction1Response(rsp)
}

// GetRestrictionsWithResponse request returning *GetRestrictionsResponse
func (c *ClientWithResponses) GetRestrictionsWithResponse(ctx context.Context, projectKey string, params *GetRestrictionsParams, reqEditors ...RequestEditorFn) (*GetRestrictionsResponse, error) {
	rsp, err := c.GetRestrictions(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestrictionsResponse(rsp)
}

// CreateRestrictionsWithBodyWithResponse request with arbitrary body returning *CreateRestrictionsResponse
func (c *ClientWithResponses) CreateRestrictionsWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRestrictionsResponse, error) {
	rsp, err := c.CreateRestrictionsWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) CreateRestrictionsWithApplicationVndAtlBitbucketBulkPlusJSONBodyWithResponse(ctx context.Context, projectKey string, body CreateRestrictionsApplicationVndAtlBitbucketBulkPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRestrictionsResponse, error) {
	rsp, err := c.CreateRestrictionsWithApplicationVndAtlBitbucketBulkPlusJSONBody(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRestrictionsResponse(rsp)
}

// DeleteRestrictionWithResponse request returning *DeleteRestrictionResponse
func (c *ClientWithResponses) DeleteRestrictionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeleteRestrictionResponse, error) {
	rsp, err := c.DeleteRestriction(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRestrictionResponse(rsp)
}

// GetRestrictionWithResponse request returning *GetRestrictionResponse
func (c *ClientWithResponses) GetRestrictionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*GetRestrictionResponse, error) {
	rsp, err := c.GetRestriction(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRestrictionResponse(rsp)
}

// DeleteBranchWithBodyWithResponse request with arbitrary body returning *DeleteBranchResponse
func (c *ClientWithResponses) DeleteBranchWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranchWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

func (c *ClientWithResponses) DeleteBranchWithResponse(ctx context.Context, projectKey string, repositorySlug string, body DeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranch(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

// CreateBranchWithBodyWithResponse request with arbitrary body returning *CreateBranchResponse
func (c *ClientWithResponses) CreateBranchWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranchWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranch(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

// FindByCommitWithResponse request returning *FindByCommitResponse
func (c *ClientWithResponses) FindByCommitWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *FindByCommitParams, reqEditors ...RequestEditorFn) (*FindByCommitResponse, error) {
	rsp, err := c.FindByCommit(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindByCommitResponse(rsp)
}

// GetMultipleBuildStatusStatsWithBodyWithResponse request with arbitrary body returning *GetMultipleBuildStatusStatsResponse
func (c *ClientWithResponses) GetMultipleBuildStatusStatsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMultipleBuildStatusStatsResponse, error) {
	rsp, err := c.GetMultipleBuildStatusStatsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleBuildStatusStatsResponse(rsp)
}

func (c *ClientWithResponses) GetMultipleBuildStatusStatsWithResponse(ctx context.Context, body GetMultipleBuildStatusStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMultipleBuildStatusStatsResponse, error) {
	rsp, err := c.GetMultipleBuildStatusStats(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleBuildStatusStatsResponse(rsp)
}

// GetBuildStatusStatsWithResponse request returning *GetBuildStatusStatsResponse
func (c *ClientWithResponses) GetBuildStatusStatsWithResponse(ctx context.Context, commitId string, params *GetBuildStatusStatsParams, reqEditors ...RequestEditorFn) (*GetBuildStatusStatsResponse, error) {
	rsp, err := c.GetBuildStatusStats(ctx, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildStatusStatsResponse(rsp)
}

// GetBuildStatusWithResponse request returning *GetBuildStatusResponse
func (c *ClientWithResponses) GetBuildStatusWithResponse(ctx context.Context, commitId string, params *GetBuildStatusParams, reqEditors ...RequestEditorFn) (*GetBuildStatusResponse, error) {
	rsp, err := c.GetBuildStatus(ctx, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildStatusResponse(rsp)
}

// AddBuildStatusWithBodyWithResponse request with arbitrary body returning *AddBuildStatusResponse
func (c *ClientWithResponses) AddBuildStatusWithBodyWithResponse(ctx context.Context, commitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuildStatusResponse, error) {
	rsp, err := c.AddBuildStatusWithBody(ctx, commitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuildStatusResponse(rsp)
}

func (c *ClientWithResponses) AddBuildStatusWithResponse(ctx context.Context, commitId string, body AddBuildStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuildStatusResponse, error) {
	rsp, err := c.AddBuildStatus(ctx, commitId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuildStatusResponse(rsp)
}

// UnReactWithResponse request returning *UnReactResponse
func (c *ClientWithResponses) UnReactWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*UnReactResponse, error) {
	rsp, err := c.UnReact(ctx, projectKey, repositorySlug, commitId, commentId, emoticon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnReactResponse(rsp)
}

// ReactWithResponse request returning *ReactResponse
func (c *ClientWithResponses) ReactWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*ReactResponse, error) {
	rsp, err := c.React(ctx, projectKey, repositorySlug, commitId, commentId, emoticon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactResponse(rsp)
}

// UnReact1WithResponse request returning *UnReact1Response
func (c *ClientWithResponses) UnReact1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*UnReact1Response, error) {
	rsp, err := c.UnReact1(ctx, projectKey, repositorySlug, pullRequestId, commentId, emoticon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnReact1Response(rsp)
}

// React1WithResponse request returning *React1Response
func (c *ClientWithResponses) React1WithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, commentId string, emoticon string, reqEditors ...RequestEditorFn) (*React1Response, error) {
	rsp, err := c.React1(ctx, projectKey, repositorySlug, pullRequestId, commentId, emoticon, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReact1Response(rsp)
}

// CreatePullRequestConditionWithBodyWithResponse request with arbitrary body returning *CreatePullRequestConditionResponse
func (c *ClientWithResponses) CreatePullRequestConditionWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestConditionResponse, error) {
	rsp, err := c.CreatePullRequestConditionWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestConditionResponse(rsp)
}

func (c *ClientWithResponses) CreatePullRequestConditionWithResponse(ctx context.Context, projectKey string, body CreatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestConditionResponse, error) {
	rsp, err := c.CreatePullRequestCondition(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestConditionResponse(rsp)
}

// DeletePullRequestConditionWithResponse request returning *DeletePullRequestConditionResponse
func (c *ClientWithResponses) DeletePullRequestConditionWithResponse(ctx context.Context, projectKey string, id string, reqEditors ...RequestEditorFn) (*DeletePullRequestConditionResponse, error) {
	rsp, err := c.DeletePullRequestCondition(ctx, projectKey, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePullRequestConditionResponse(rsp)
}

// UpdatePullRequestConditionWithBodyWithResponse request with arbitrary body returning *UpdatePullRequestConditionResponse
func (c *ClientWithResponses) UpdatePullRequestConditionWithBodyWithResponse(ctx context.Context, projectKey string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestConditionResponse, error) {
	rsp, err := c.UpdatePullRequestConditionWithBody(ctx, projectKey, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestConditionResponse(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestConditionWithResponse(ctx context.Context, projectKey string, id string, body UpdatePullRequestConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestConditionResponse, error) {
	rsp, err := c.UpdatePullRequestCondition(ctx, projectKey, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestConditionResponse(rsp)
}

// GetPullRequestConditionsWithResponse request returning *GetPullRequestConditionsResponse
func (c *ClientWithResponses) GetPullRequestConditionsWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetPullRequestConditionsResponse, error) {
	rsp, err := c.GetPullRequestConditions(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestConditionsResponse(rsp)
}

// CreatePullRequestCondition1WithBodyWithResponse request with arbitrary body returning *CreatePullRequestCondition1Response
func (c *ClientWithResponses) CreatePullRequestCondition1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePullRequestCondition1Response, error) {
	rsp, err := c.CreatePullRequestCondition1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestCondition1Response(rsp)
}

func (c *ClientWithResponses) CreatePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePullRequestCondition1Response, error) {
	rsp, err := c.CreatePullRequestCondition1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePullRequestCondition1Response(rsp)
}

// DeletePullRequestCondition1WithResponse request returning *DeletePullRequestCondition1Response
func (c *ClientWithResponses) DeletePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id int32, reqEditors ...RequestEditorFn) (*DeletePullRequestCondition1Response, error) {
	rsp, err := c.DeletePullRequestCondition1(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePullRequestCondition1Response(rsp)
}

// UpdatePullRequestCondition1WithBodyWithResponse request with arbitrary body returning *UpdatePullRequestCondition1Response
func (c *ClientWithResponses) UpdatePullRequestCondition1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePullRequestCondition1Response, error) {
	rsp, err := c.UpdatePullRequestCondition1WithBody(ctx, projectKey, repositorySlug, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestCondition1Response(rsp)
}

func (c *ClientWithResponses) UpdatePullRequestCondition1WithResponse(ctx context.Context, projectKey string, repositorySlug string, id string, body UpdatePullRequestCondition1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePullRequestCondition1Response, error) {
	rsp, err := c.UpdatePullRequestCondition1(ctx, projectKey, repositorySlug, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePullRequestCondition1Response(rsp)
}

// GetPullRequestConditions1WithResponse request returning *GetPullRequestConditions1Response
func (c *ClientWithResponses) GetPullRequestConditions1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetPullRequestConditions1Response, error) {
	rsp, err := c.GetPullRequestConditions1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestConditions1Response(rsp)
}

// GetReviewersWithResponse request returning *GetReviewersResponse
func (c *ClientWithResponses) GetReviewersWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetReviewersParams, reqEditors ...RequestEditorFn) (*GetReviewersResponse, error) {
	rsp, err := c.GetReviewers(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReviewersResponse(rsp)
}

// DeleteAllDefaultTasks1WithResponse request returning *DeleteAllDefaultTasks1Response
func (c *ClientWithResponses) DeleteAllDefaultTasks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*DeleteAllDefaultTasks1Response, error) {
	rsp, err := c.DeleteAllDefaultTasks1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllDefaultTasks1Response(rsp)
}

// GetDefaultTasks1WithResponse request returning *GetDefaultTasks1Response
func (c *ClientWithResponses) GetDefaultTasks1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetDefaultTasks1Params, reqEditors ...RequestEditorFn) (*GetDefaultTasks1Response, error) {
	rsp, err := c.GetDefaultTasks1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultTasks1Response(rsp)
}

// AddDefaultTask1WithBodyWithResponse request with arbitrary body returning *AddDefaultTask1Response
func (c *ClientWithResponses) AddDefaultTask1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultTask1Response, error) {
	rsp, err := c.AddDefaultTask1WithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultTask1Response(rsp)
}

func (c *ClientWithResponses) AddDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultTask1Response, error) {
	rsp, err := c.AddDefaultTask1(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultTask1Response(rsp)
}

// DeleteDefaultTask1WithResponse request returning *DeleteDefaultTask1Response
func (c *ClientWithResponses) DeleteDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, reqEditors ...RequestEditorFn) (*DeleteDefaultTask1Response, error) {
	rsp, err := c.DeleteDefaultTask1(ctx, projectKey, repositorySlug, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDefaultTask1Response(rsp)
}

// UpdateDefaultTask1WithBodyWithResponse request with arbitrary body returning *UpdateDefaultTask1Response
func (c *ClientWithResponses) UpdateDefaultTask1WithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDefaultTask1Response, error) {
	rsp, err := c.UpdateDefaultTask1WithBody(ctx, projectKey, repositorySlug, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDefaultTask1Response(rsp)
}

func (c *ClientWithResponses) UpdateDefaultTask1WithResponse(ctx context.Context, projectKey string, repositorySlug string, taskId string, body UpdateDefaultTask1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDefaultTask1Response, error) {
	rsp, err := c.UpdateDefaultTask1(ctx, projectKey, repositorySlug, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDefaultTask1Response(rsp)
}

// DeleteAllDefaultTasksWithResponse request returning *DeleteAllDefaultTasksResponse
func (c *ClientWithResponses) DeleteAllDefaultTasksWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*DeleteAllDefaultTasksResponse, error) {
	rsp, err := c.DeleteAllDefaultTasks(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllDefaultTasksResponse(rsp)
}

// GetDefaultTasksWithResponse request returning *GetDefaultTasksResponse
func (c *ClientWithResponses) GetDefaultTasksWithResponse(ctx context.Context, projectKey string, params *GetDefaultTasksParams, reqEditors ...RequestEditorFn) (*GetDefaultTasksResponse, error) {
	rsp, err := c.GetDefaultTasks(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultTasksResponse(rsp)
}

// AddDefaultTaskWithBodyWithResponse request with arbitrary body returning *AddDefaultTaskResponse
func (c *ClientWithResponses) AddDefaultTaskWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultTaskResponse, error) {
	rsp, err := c.AddDefaultTaskWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultTaskResponse(rsp)
}

func (c *ClientWithResponses) AddDefaultTaskWithResponse(ctx context.Context, projectKey string, body AddDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultTaskResponse, error) {
	rsp, err := c.AddDefaultTask(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultTaskResponse(rsp)
}

// DeleteDefaultTaskWithResponse request returning *DeleteDefaultTaskResponse
func (c *ClientWithResponses) DeleteDefaultTaskWithResponse(ctx context.Context, projectKey string, taskId string, reqEditors ...RequestEditorFn) (*DeleteDefaultTaskResponse, error) {
	rsp, err := c.DeleteDefaultTask(ctx, projectKey, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDefaultTaskResponse(rsp)
}

// UpdateDefaultTaskWithBodyWithResponse request with arbitrary body returning *UpdateDefaultTaskResponse
func (c *ClientWithResponses) UpdateDefaultTaskWithBodyWithResponse(ctx context.Context, projectKey string, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDefaultTaskResponse, error) {
	rsp, err := c.UpdateDefaultTaskWithBody(ctx, projectKey, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDefaultTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateDefaultTaskWithResponse(ctx context.Context, projectKey string, taskId string, body UpdateDefaultTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDefaultTaskResponse, error) {
	rsp, err := c.UpdateDefaultTask(ctx, projectKey, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDefaultTaskResponse(rsp)
}

// CanRebaseWithResponse request returning *CanRebaseResponse
func (c *ClientWithResponses) CanRebaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*CanRebaseResponse, error) {
	rsp, err := c.CanRebase(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCanRebaseResponse(rsp)
}

// RebaseWithBodyWithResponse request with arbitrary body returning *RebaseResponse
func (c *ClientWithResponses) RebaseWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebaseResponse, error) {
	rsp, err := c.RebaseWithBody(ctx, projectKey, repositorySlug, pullRequestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebaseResponse(rsp)
}

func (c *ClientWithResponses) RebaseWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, body RebaseJSONRequestBody, reqEditors ...RequestEditorFn) (*RebaseResponse, error) {
	rsp, err := c.Rebase(ctx, projectKey, repositorySlug, pullRequestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebaseResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, projectKey string, repositorySlug string, name string, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, projectKey, repositorySlug, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// DeleteForUserWithResponse request returning *DeleteForUserResponse
func (c *ClientWithResponses) DeleteForUserWithResponse(ctx context.Context, params *DeleteForUserParams, reqEditors ...RequestEditorFn) (*DeleteForUserResponse, error) {
	rsp, err := c.DeleteForUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteForUserResponse(rsp)
}

// GetKeysForUserWithResponse request returning *GetKeysForUserResponse
func (c *ClientWithResponses) GetKeysForUserWithResponse(ctx context.Context, params *GetKeysForUserParams, reqEditors ...RequestEditorFn) (*GetKeysForUserResponse, error) {
	rsp, err := c.GetKeysForUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeysForUserResponse(rsp)
}

// AddKeyWithBodyWithResponse request with arbitrary body returning *AddKeyResponse
func (c *ClientWithResponses) AddKeyWithBodyWithResponse(ctx context.Context, params *AddKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddKeyResponse, error) {
	rsp, err := c.AddKeyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyResponse(rsp)
}

func (c *ClientWithResponses) AddKeyWithResponse(ctx context.Context, params *AddKeyParams, body AddKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddKeyResponse, error) {
	rsp, err := c.AddKey(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKeyResponse(rsp)
}

// DeleteKeyWithResponse request returning *DeleteKeyResponse
func (c *ClientWithResponses) DeleteKeyWithResponse(ctx context.Context, fingerprintOrId string, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error) {
	rsp, err := c.DeleteKey(ctx, fingerprintOrId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyResponse(rsp)
}

// GetAnnotations1WithResponse request returning *GetAnnotations1Response
func (c *ClientWithResponses) GetAnnotations1WithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetAnnotations1Params, reqEditors ...RequestEditorFn) (*GetAnnotations1Response, error) {
	rsp, err := c.GetAnnotations1(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnnotations1Response(rsp)
}

// GetReportsWithResponse request returning *GetReportsResponse
func (c *ClientWithResponses) GetReportsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, params *GetReportsParams, reqEditors ...RequestEditorFn) (*GetReportsResponse, error) {
	rsp, err := c.GetReports(ctx, projectKey, repositorySlug, commitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportsResponse(rsp)
}

// DeleteACodeInsightsReportWithResponse request returning *DeleteACodeInsightsReportResponse
func (c *ClientWithResponses) DeleteACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*DeleteACodeInsightsReportResponse, error) {
	rsp, err := c.DeleteACodeInsightsReport(ctx, projectKey, repositorySlug, commitId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACodeInsightsReportResponse(rsp)
}

// GetACodeInsightsReportWithResponse request returning *GetACodeInsightsReportResponse
func (c *ClientWithResponses) GetACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*GetACodeInsightsReportResponse, error) {
	rsp, err := c.GetACodeInsightsReport(ctx, projectKey, repositorySlug, commitId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACodeInsightsReportResponse(rsp)
}

// SetACodeInsightsReportWithBodyWithResponse request with arbitrary body returning *SetACodeInsightsReportResponse
func (c *ClientWithResponses) SetACodeInsightsReportWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetACodeInsightsReportResponse, error) {
	rsp, err := c.SetACodeInsightsReportWithBody(ctx, projectKey, repositorySlug, commitId, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetACodeInsightsReportResponse(rsp)
}

func (c *ClientWithResponses) SetACodeInsightsReportWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body SetACodeInsightsReportJSONRequestBody, reqEditors ...RequestEditorFn) (*SetACodeInsightsReportResponse, error) {
	rsp, err := c.SetACodeInsightsReport(ctx, projectKey, repositorySlug, commitId, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetACodeInsightsReportResponse(rsp)
}

// DeleteAnnotationsWithResponse request returning *DeleteAnnotationsResponse
func (c *ClientWithResponses) DeleteAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, params *DeleteAnnotationsParams, reqEditors ...RequestEditorFn) (*DeleteAnnotationsResponse, error) {
	rsp, err := c.DeleteAnnotations(ctx, projectKey, repositorySlug, commitId, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAnnotationsResponse(rsp)
}

// GetAnnotationsWithResponse request returning *GetAnnotationsResponse
func (c *ClientWithResponses) GetAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, reqEditors ...RequestEditorFn) (*GetAnnotationsResponse, error) {
	rsp, err := c.GetAnnotations(ctx, projectKey, repositorySlug, commitId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnnotationsResponse(rsp)
}

// AddAnnotationsWithBodyWithResponse request with arbitrary body returning *AddAnnotationsResponse
func (c *ClientWithResponses) AddAnnotationsWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAnnotationsResponse, error) {
	rsp, err := c.AddAnnotationsWithBody(ctx, projectKey, repositorySlug, commitId, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAnnotationsResponse(rsp)
}

func (c *ClientWithResponses) AddAnnotationsWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, body AddAnnotationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAnnotationsResponse, error) {
	rsp, err := c.AddAnnotations(ctx, projectKey, repositorySlug, commitId, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAnnotationsResponse(rsp)
}

// SetAnnotationWithBodyWithResponse request with arbitrary body returning *SetAnnotationResponse
func (c *ClientWithResponses) SetAnnotationWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAnnotationResponse, error) {
	rsp, err := c.SetAnnotationWithBody(ctx, projectKey, repositorySlug, commitId, key, externalId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAnnotationResponse(rsp)
}

func (c *ClientWithResponses) SetAnnotationWithResponse(ctx context.Context, projectKey string, repositorySlug string, commitId string, key string, externalId string, body SetAnnotationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAnnotationResponse, error) {
	rsp, err := c.SetAnnotation(ctx, projectKey, repositorySlug, commitId, key, externalId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAnnotationResponse(rsp)
}

// CreateIssueWithBodyWithResponse request with arbitrary body returning *CreateIssueResponse
func (c *ClientWithResponses) CreateIssueWithBodyWithResponse(ctx context.Context, commentId string, params *CreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIssueResponse, error) {
	rsp, err := c.CreateIssueWithBody(ctx, commentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIssueResponse(rsp)
}

func (c *ClientWithResponses) CreateIssueWithResponse(ctx context.Context, commentId string, params *CreateIssueParams, body CreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIssueResponse, error) {
	rsp, err := c.CreateIssue(ctx, commentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIssueResponse(rsp)
}

// GetCommitsByIssueKeyWithResponse request returning *GetCommitsByIssueKeyResponse
func (c *ClientWithResponses) GetCommitsByIssueKeyWithResponse(ctx context.Context, issueKey string, params *GetCommitsByIssueKeyParams, reqEditors ...RequestEditorFn) (*GetCommitsByIssueKeyResponse, error) {
	rsp, err := c.GetCommitsByIssueKey(ctx, issueKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitsByIssueKeyResponse(rsp)
}

// GetEnhancedEntityLinkForProjectWithResponse request returning *GetEnhancedEntityLinkForProjectResponse
func (c *ClientWithResponses) GetEnhancedEntityLinkForProjectWithResponse(ctx context.Context, projectKey string, reqEditors ...RequestEditorFn) (*GetEnhancedEntityLinkForProjectResponse, error) {
	rsp, err := c.GetEnhancedEntityLinkForProject(ctx, projectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnhancedEntityLinkForProjectResponse(rsp)
}

// GetIssueKeysForPullRequestWithResponse request returning *GetIssueKeysForPullRequestResponse
func (c *ClientWithResponses) GetIssueKeysForPullRequestWithResponse(ctx context.Context, projectKey string, repositorySlug string, pullRequestId string, reqEditors ...RequestEditorFn) (*GetIssueKeysForPullRequestResponse, error) {
	rsp, err := c.GetIssueKeysForPullRequest(ctx, projectKey, repositorySlug, pullRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIssueKeysForPullRequestResponse(rsp)
}

// GetForRepository1WithResponse request returning *GetForRepository1Response
func (c *ClientWithResponses) GetForRepository1WithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetForRepository1Params, reqEditors ...RequestEditorFn) (*GetForRepository1Response, error) {
	rsp, err := c.GetForRepository1(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForRepository1Response(rsp)
}

// AddForRepositoryWithBodyWithResponse request with arbitrary body returning *AddForRepositoryResponse
func (c *ClientWithResponses) AddForRepositoryWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddForRepositoryResponse, error) {
	rsp, err := c.AddForRepositoryWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddForRepositoryResponse(rsp)
}

func (c *ClientWithResponses) AddForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, body AddForRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddForRepositoryResponse, error) {
	rsp, err := c.AddForRepository(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddForRepositoryResponse(rsp)
}

// RevokeForRepositoryWithResponse request returning *RevokeForRepositoryResponse
func (c *ClientWithResponses) RevokeForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*RevokeForRepositoryResponse, error) {
	rsp, err := c.RevokeForRepository(ctx, projectKey, repositorySlug, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeForRepositoryResponse(rsp)
}

// GetForRepositoryWithResponse request returning *GetForRepositoryResponse
func (c *ClientWithResponses) GetForRepositoryWithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, reqEditors ...RequestEditorFn) (*GetForRepositoryResponse, error) {
	rsp, err := c.GetForRepository(ctx, projectKey, repositorySlug, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForRepositoryResponse(rsp)
}

// UpdatePermission1WithResponse request returning *UpdatePermission1Response
func (c *ClientWithResponses) UpdatePermission1WithResponse(ctx context.Context, projectKey string, repositorySlug string, keyId string, permission string, reqEditors ...RequestEditorFn) (*UpdatePermission1Response, error) {
	rsp, err := c.UpdatePermission1(ctx, projectKey, repositorySlug, keyId, permission, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermission1Response(rsp)
}

// GetSshKeysForProjectWithResponse request returning *GetSshKeysForProjectResponse
func (c *ClientWithResponses) GetSshKeysForProjectWithResponse(ctx context.Context, projectKey string, params *GetSshKeysForProjectParams, reqEditors ...RequestEditorFn) (*GetSshKeysForProjectResponse, error) {
	rsp, err := c.GetSshKeysForProject(ctx, projectKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshKeysForProjectResponse(rsp)
}

// AddForProjectWithBodyWithResponse request with arbitrary body returning *AddForProjectResponse
func (c *ClientWithResponses) AddForProjectWithBodyWithResponse(ctx context.Context, projectKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddForProjectResponse, error) {
	rsp, err := c.AddForProjectWithBody(ctx, projectKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddForProjectResponse(rsp)
}

func (c *ClientWithResponses) AddForProjectWithResponse(ctx context.Context, projectKey string, body AddForProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AddForProjectResponse, error) {
	rsp, err := c.AddForProject(ctx, projectKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddForProjectResponse(rsp)
}

// RevokeForProjectWithResponse request returning *RevokeForProjectResponse
func (c *ClientWithResponses) RevokeForProjectWithResponse(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*RevokeForProjectResponse, error) {
	rsp, err := c.RevokeForProject(ctx, projectKey, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeForProjectResponse(rsp)
}

// GetForProjectWithResponse request returning *GetForProjectResponse
func (c *ClientWithResponses) GetForProjectWithResponse(ctx context.Context, projectKey string, keyId string, reqEditors ...RequestEditorFn) (*GetForProjectResponse, error) {
	rsp, err := c.GetForProject(ctx, projectKey, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForProjectResponse(rsp)
}

// UpdatePermissionWithResponse request returning *UpdatePermissionResponse
func (c *ClientWithResponses) UpdatePermissionWithResponse(ctx context.Context, projectKey string, keyId string, permission string, reqEditors ...RequestEditorFn) (*UpdatePermissionResponse, error) {
	rsp, err := c.UpdatePermission(ctx, projectKey, keyId, permission, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermissionResponse(rsp)
}

// RevokeManyWithBodyWithResponse request with arbitrary body returning *RevokeManyResponse
func (c *ClientWithResponses) RevokeManyWithBodyWithResponse(ctx context.Context, keyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeManyResponse, error) {
	rsp, err := c.RevokeManyWithBody(ctx, keyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeManyResponse(rsp)
}

func (c *ClientWithResponses) RevokeManyWithResponse(ctx context.Context, keyId string, body RevokeManyJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeManyResponse, error) {
	rsp, err := c.RevokeMany(ctx, keyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeManyResponse(rsp)
}

// GetForProjectsWithResponse request returning *GetForProjectsResponse
func (c *ClientWithResponses) GetForProjectsWithResponse(ctx context.Context, keyId int32, reqEditors ...RequestEditorFn) (*GetForProjectsResponse, error) {
	rsp, err := c.GetForProjects(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForProjectsResponse(rsp)
}

// GetForRepositoriesWithResponse request returning *GetForRepositoriesResponse
func (c *ClientWithResponses) GetForRepositoriesWithResponse(ctx context.Context, keyId string, params *GetForRepositoriesParams, reqEditors ...RequestEditorFn) (*GetForRepositoriesResponse, error) {
	rsp, err := c.GetForRepositories(ctx, keyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetForRepositoriesResponse(rsp)
}

// DeletePreferredMirrorIdWithResponse request returning *DeletePreferredMirrorIdResponse
func (c *ClientWithResponses) DeletePreferredMirrorIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeletePreferredMirrorIdResponse, error) {
	rsp, err := c.DeletePreferredMirrorId(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePreferredMirrorIdResponse(rsp)
}

// GetPreferredMirrorIdWithResponse request returning *GetPreferredMirrorIdResponse
func (c *ClientWithResponses) GetPreferredMirrorIdWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPreferredMirrorIdResponse, error) {
	rsp, err := c.GetPreferredMirrorId(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreferredMirrorIdResponse(rsp)
}

// SetPreferredMirrorIdWithBodyWithResponse request with arbitrary body returning *SetPreferredMirrorIdResponse
func (c *ClientWithResponses) SetPreferredMirrorIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPreferredMirrorIdResponse, error) {
	rsp, err := c.SetPreferredMirrorIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPreferredMirrorIdResponse(rsp)
}

func (c *ClientWithResponses) SetPreferredMirrorIdWithResponse(ctx context.Context, body SetPreferredMirrorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPreferredMirrorIdResponse, error) {
	rsp, err := c.SetPreferredMirrorId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPreferredMirrorIdResponse(rsp)
}

// AnalyticsSettingsWithResponse request returning *AnalyticsSettingsResponse
func (c *ClientWithResponses) AnalyticsSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AnalyticsSettingsResponse, error) {
	rsp, err := c.AnalyticsSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyticsSettingsResponse(rsp)
}

// AuthenticateWithBodyWithResponse request with arbitrary body returning *AuthenticateResponse
func (c *ClientWithResponses) AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error) {
	rsp, err := c.AuthenticateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateResponse, error) {
	rsp, err := c.Authenticate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateResponse(rsp)
}

// GetFarmNodesWithResponse request returning *GetFarmNodesResponse
func (c *ClientWithResponses) GetFarmNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFarmNodesResponse, error) {
	rsp, err := c.GetFarmNodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFarmNodesResponse(rsp)
}

// GetMirroredRepositoryWithResponse request returning *GetMirroredRepositoryResponse
func (c *ClientWithResponses) GetMirroredRepositoryWithResponse(ctx context.Context, externalRepositoryId string, reqEditors ...RequestEditorFn) (*GetMirroredRepositoryResponse, error) {
	rsp, err := c.GetMirroredRepository(ctx, externalRepositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirroredRepositoryResponse(rsp)
}

// ListMirrorsWithResponse request returning *ListMirrorsResponse
func (c *ClientWithResponses) ListMirrorsWithResponse(ctx context.Context, params *ListMirrorsParams, reqEditors ...RequestEditorFn) (*ListMirrorsResponse, error) {
	rsp, err := c.ListMirrors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMirrorsResponse(rsp)
}

// RemoveWithResponse request returning *RemoveResponse
func (c *ClientWithResponses) RemoveWithResponse(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*RemoveResponse, error) {
	rsp, err := c.Remove(ctx, mirrorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveResponse(rsp)
}

// GetMirrorWithResponse request returning *GetMirrorResponse
func (c *ClientWithResponses) GetMirrorWithResponse(ctx context.Context, mirrorId string, reqEditors ...RequestEditorFn) (*GetMirrorResponse, error) {
	rsp, err := c.GetMirror(ctx, mirrorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirrorResponse(rsp)
}

// UpgradeWithBodyWithResponse request with arbitrary body returning *UpgradeResponse
func (c *ClientWithResponses) UpgradeWithBodyWithResponse(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeResponse, error) {
	rsp, err := c.UpgradeWithBody(ctx, mirrorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeResponse(rsp)
}

func (c *ClientWithResponses) UpgradeWithResponse(ctx context.Context, mirrorId string, body UpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeResponse, error) {
	rsp, err := c.Upgrade(ctx, mirrorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeResponse(rsp)
}

// PublishEventWithBodyWithResponse request with arbitrary body returning *PublishEventResponse
func (c *ClientWithResponses) PublishEventWithBodyWithResponse(ctx context.Context, mirrorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishEventResponse, error) {
	rsp, err := c.PublishEventWithBody(ctx, mirrorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishEventResponse(rsp)
}

func (c *ClientWithResponses) PublishEventWithResponse(ctx context.Context, mirrorId string, body PublishEventJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishEventResponse, error) {
	rsp, err := c.PublishEvent(ctx, mirrorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishEventResponse(rsp)
}

// GetSynchronizationProgressWithResponse request returning *GetSynchronizationProgressResponse
func (c *ClientWithResponses) GetSynchronizationProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSynchronizationProgressResponse, error) {
	rsp, err := c.GetSynchronizationProgress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSynchronizationProgressResponse(rsp)
}

// GetProjectByIdWithResponse request returning *GetProjectByIdResponse
func (c *ClientWithResponses) GetProjectByIdWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectByIdResponse, error) {
	rsp, err := c.GetProjectById(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectByIdResponse(rsp)
}

// GetAllReposForProjectWithResponse request returning *GetAllReposForProjectResponse
func (c *ClientWithResponses) GetAllReposForProjectWithResponse(ctx context.Context, projectId string, params *GetAllReposForProjectParams, reqEditors ...RequestEditorFn) (*GetAllReposForProjectResponse, error) {
	rsp, err := c.GetAllReposForProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllReposForProjectResponse(rsp)
}

// GetAllContentHashesWithResponse request returning *GetAllContentHashesResponse
func (c *ClientWithResponses) GetAllContentHashesWithResponse(ctx context.Context, params *GetAllContentHashesParams, reqEditors ...RequestEditorFn) (*GetAllContentHashesResponse, error) {
	rsp, err := c.GetAllContentHashes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllContentHashesResponse(rsp)
}

// GetContentHashByIdWithResponse request returning *GetContentHashByIdResponse
func (c *ClientWithResponses) GetContentHashByIdWithResponse(ctx context.Context, repoId string, params *GetContentHashByIdParams, reqEditors ...RequestEditorFn) (*GetContentHashByIdResponse, error) {
	rsp, err := c.GetContentHashById(ctx, repoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentHashByIdResponse(rsp)
}

// GetRepositoryMirrorsWithResponse request returning *GetRepositoryMirrorsResponse
func (c *ClientWithResponses) GetRepositoryMirrorsWithResponse(ctx context.Context, repoId string, params *GetRepositoryMirrorsParams, reqEditors ...RequestEditorFn) (*GetRepositoryMirrorsResponse, error) {
	rsp, err := c.GetRepositoryMirrors(ctx, repoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryMirrorsResponse(rsp)
}

// ListRequestsWithResponse request returning *ListRequestsResponse
func (c *ClientWithResponses) ListRequestsWithResponse(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*ListRequestsResponse, error) {
	rsp, err := c.ListRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestsResponse(rsp)
}

// RegisterWithBodyWithResponse request with arbitrary body returning *RegisterResponse
func (c *ClientWithResponses) RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.RegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.Register(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

// DeleteMirroringRequestWithResponse request returning *DeleteMirroringRequestResponse
func (c *ClientWithResponses) DeleteMirroringRequestWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*DeleteMirroringRequestResponse, error) {
	rsp, err := c.DeleteMirroringRequest(ctx, mirroringRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMirroringRequestResponse(rsp)
}

// GetMirroringRequestWithResponse request returning *GetMirroringRequestResponse
func (c *ClientWithResponses) GetMirroringRequestWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*GetMirroringRequestResponse, error) {
	rsp, err := c.GetMirroringRequest(ctx, mirroringRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirroringRequestResponse(rsp)
}

// AcceptWithResponse request returning *AcceptResponse
func (c *ClientWithResponses) AcceptWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*AcceptResponse, error) {
	rsp, err := c.Accept(ctx, mirroringRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptResponse(rsp)
}

// RejectWithResponse request returning *RejectResponse
func (c *ClientWithResponses) RejectWithResponse(ctx context.Context, mirroringRequestId string, reqEditors ...RequestEditorFn) (*RejectResponse, error) {
	rsp, err := c.Reject(ctx, mirroringRequestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectResponse(rsp)
}

// GetOutOfSyncRepositoriesWithResponse request returning *GetOutOfSyncRepositoriesResponse
func (c *ClientWithResponses) GetOutOfSyncRepositoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutOfSyncRepositoriesResponse, error) {
	rsp, err := c.GetOutOfSyncRepositories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutOfSyncRepositoriesResponse(rsp)
}

// GetRepositoryLockOwnerWithResponse request returning *GetRepositoryLockOwnerResponse
func (c *ClientWithResponses) GetRepositoryLockOwnerWithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepositoryLockOwnerResponse, error) {
	rsp, err := c.GetRepositoryLockOwner(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryLockOwnerResponse(rsp)
}

// GetRepoSyncStatus1WithResponse request returning *GetRepoSyncStatus1Response
func (c *ClientWithResponses) GetRepoSyncStatus1WithResponse(ctx context.Context, projectKey string, repositorySlug string, reqEditors ...RequestEditorFn) (*GetRepoSyncStatus1Response, error) {
	rsp, err := c.GetRepoSyncStatus1(ctx, projectKey, repositorySlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepoSyncStatus1Response(rsp)
}

// GetRefChangesQueueWithResponse request returning *GetRefChangesQueueResponse
func (c *ClientWithResponses) GetRefChangesQueueWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefChangesQueueResponse, error) {
	rsp, err := c.GetRefChangesQueue(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefChangesQueueResponse(rsp)
}

// GetRefChangesQueueCountWithResponse request returning *GetRefChangesQueueCountResponse
func (c *ClientWithResponses) GetRefChangesQueueCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRefChangesQueueCountResponse, error) {
	rsp, err := c.GetRefChangesQueueCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefChangesQueueCountResponse(rsp)
}

// GetRepositoryLockOwnersWithResponse request returning *GetRepositoryLockOwnersResponse
func (c *ClientWithResponses) GetRepositoryLockOwnersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryLockOwnersResponse, error) {
	rsp, err := c.GetRepositoryLockOwners(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryLockOwnersResponse(rsp)
}

// GetRepoSyncStatusWithResponse request returning *GetRepoSyncStatusResponse
func (c *ClientWithResponses) GetRepoSyncStatusWithResponse(ctx context.Context, params *GetRepoSyncStatusParams, reqEditors ...RequestEditorFn) (*GetRepoSyncStatusResponse, error) {
	rsp, err := c.GetRepoSyncStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepoSyncStatusResponse(rsp)
}

// GetMirrorSettingsWithResponse request returning *GetMirrorSettingsResponse
func (c *ClientWithResponses) GetMirrorSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirrorSettingsResponse, error) {
	rsp, err := c.GetMirrorSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirrorSettingsResponse(rsp)
}

// SetMirrorSettingsWithBodyWithResponse request with arbitrary body returning *SetMirrorSettingsResponse
func (c *ClientWithResponses) SetMirrorSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMirrorSettingsResponse, error) {
	rsp, err := c.SetMirrorSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMirrorSettingsResponse(rsp)
}

func (c *ClientWithResponses) SetMirrorSettingsWithResponse(ctx context.Context, body SetMirrorSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMirrorSettingsResponse, error) {
	rsp, err := c.SetMirrorSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMirrorSettingsResponse(rsp)
}

// GetMirrorModeWithResponse request returning *GetMirrorModeResponse
func (c *ClientWithResponses) GetMirrorModeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirrorModeResponse, error) {
	rsp, err := c.GetMirrorMode(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirrorModeResponse(rsp)
}

// SetMirrorModeWithBodyWithResponse request with arbitrary body returning *SetMirrorModeResponse
func (c *ClientWithResponses) SetMirrorModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMirrorModeResponse, error) {
	rsp, err := c.SetMirrorModeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMirrorModeResponse(rsp)
}

func (c *ClientWithResponses) SetMirrorModeWithResponse(ctx context.Context, body SetMirrorModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMirrorModeResponse, error) {
	rsp, err := c.SetMirrorMode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMirrorModeResponse(rsp)
}

// GetMirroredProjectsWithResponse request returning *GetMirroredProjectsResponse
func (c *ClientWithResponses) GetMirroredProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMirroredProjectsResponse, error) {
	rsp, err := c.GetMirroredProjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMirroredProjectsResponse(rsp)
}

// StartMirroringProjectsWithBodyWithResponse request with arbitrary body returning *StartMirroringProjectsResponse
func (c *ClientWithResponses) StartMirroringProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartMirroringProjectsResponse, error) {
	rsp, err := c.StartMirroringProjectsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartMirroringProjectsResponse(rsp)
}

func (c *ClientWithResponses) StartMirroringProjectsWithResponse(ctx context.Context, body StartMirroringProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*StartMirroringProjectsResponse, error) {
	rsp, err := c.StartMirroringProjects(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartMirroringProjectsResponse(rsp)
}

// StopMirroringProjectWithResponse request returning *StopMirroringProjectResponse
func (c *ClientWithResponses) StopMirroringProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*StopMirroringProjectResponse, error) {
	rsp, err := c.StopMirroringProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopMirroringProjectResponse(rsp)
}

// StartMirroringProjectWithResponse request returning *StartMirroringProjectResponse
func (c *ClientWithResponses) StartMirroringProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*StartMirroringProjectResponse, error) {
	rsp, err := c.StartMirroringProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartMirroringProjectResponse(rsp)
}

// GetUpstreamServerWithResponse request returning *GetUpstreamServerResponse
func (c *ClientWithResponses) GetUpstreamServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpstreamServerResponse, error) {
	rsp, err := c.GetUpstreamServer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpstreamServerResponse(rsp)
}

// EndRollingUpgradeWithResponse request returning *EndRollingUpgradeResponse
func (c *ClientWithResponses) EndRollingUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EndRollingUpgradeResponse, error) {
	rsp, err := c.EndRollingUpgrade(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndRollingUpgradeResponse(rsp)
}

// StartRollingUpgradeWithResponse request returning *StartRollingUpgradeResponse
func (c *ClientWithResponses) StartRollingUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StartRollingUpgradeResponse, error) {
	rsp, err := c.StartRollingUpgrade(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRollingUpgradeResponse(rsp)
}

// GetRepositoryArchivePolicyWithResponse request returning *GetRepositoryArchivePolicyResponse
func (c *ClientWithResponses) GetRepositoryArchivePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryArchivePolicyResponse, error) {
	rsp, err := c.GetRepositoryArchivePolicy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryArchivePolicyResponse(rsp)
}

// SetRepositoryArchivePolicyWithBodyWithResponse request with arbitrary body returning *SetRepositoryArchivePolicyResponse
func (c *ClientWithResponses) SetRepositoryArchivePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryArchivePolicyResponse, error) {
	rsp, err := c.SetRepositoryArchivePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryArchivePolicyResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryArchivePolicyWithResponse(ctx context.Context, body SetRepositoryArchivePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryArchivePolicyResponse, error) {
	rsp, err := c.SetRepositoryArchivePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryArchivePolicyResponse(rsp)
}

// GetRepositoryDeletePolicyWithResponse request returning *GetRepositoryDeletePolicyResponse
func (c *ClientWithResponses) GetRepositoryDeletePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoryDeletePolicyResponse, error) {
	rsp, err := c.GetRepositoryDeletePolicy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryDeletePolicyResponse(rsp)
}

// SetRepositoryDeletePolicyWithBodyWithResponse request with arbitrary body returning *SetRepositoryDeletePolicyResponse
func (c *ClientWithResponses) SetRepositoryDeletePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryDeletePolicyResponse, error) {
	rsp, err := c.SetRepositoryDeletePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryDeletePolicyResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryDeletePolicyWithResponse(ctx context.Context, body SetRepositoryDeletePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryDeletePolicyResponse, error) {
	rsp, err := c.SetRepositoryDeletePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryDeletePolicyResponse(rsp)
}

// CreateRequiredBuildsMergeCheckWithBodyWithResponse request with arbitrary body returning *CreateRequiredBuildsMergeCheckResponse
func (c *ClientWithResponses) CreateRequiredBuildsMergeCheckWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequiredBuildsMergeCheckResponse, error) {
	rsp, err := c.CreateRequiredBuildsMergeCheckWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequiredBuildsMergeCheckResponse(rsp)
}

// DeleteRequiredBuildsMergeCheckWithResponse request returning *DeleteRequiredBuildsMergeCheckResponse
func (c *ClientWithResponses) DeleteRequiredBuildsMergeCheckWithResponse(ctx context.Context, projectKey string, repositorySlug string, id int64, reqEditors ...RequestEditorFn) (*DeleteRequiredBuildsMergeCheckResponse, error) {
	rsp, err := c.DeleteRequiredBuildsMergeCheck(ctx, projectKey, repositorySlug, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRequiredBuildsMergeCheckResponse(rsp)
}

// UpdateRequiredBuildsMergeCheckWithBodyWithResponse request with arbitrary body returning *UpdateRequiredBuildsMergeCheckResponse
func (c *ClientWithResponses) UpdateRequiredBuildsMergeCheckWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequiredBuildsMergeCheckResponse, error) {
	rsp, err := c.UpdateRequiredBuildsMergeCheckWithBody(ctx, projectKey, repositorySlug, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequiredBuildsMergeCheckResponse(rsp)
}

// GetPageOfRequiredBuildsMergeChecksWithResponse request returning *GetPageOfRequiredBuildsMergeChecksResponse
func (c *ClientWithResponses) GetPageOfRequiredBuildsMergeChecksWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetPageOfRequiredBuildsMergeChecksParams, reqEditors ...RequestEditorFn) (*GetPageOfRequiredBuildsMergeChecksResponse, error) {
	rsp, err := c.GetPageOfRequiredBuildsMergeChecks(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPageOfRequiredBuildsMergeChecksResponse(rsp)
}

// DeleteSshKeysWithResponse request returning *DeleteSshKeysResponse
func (c *ClientWithResponses) DeleteSshKeysWithResponse(ctx context.Context, params *DeleteSshKeysParams, reqEditors ...RequestEditorFn) (*DeleteSshKeysResponse, error) {
	rsp, err := c.DeleteSshKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshKeysResponse(rsp)
}

// GetSshKeysWithResponse request returning *GetSshKeysResponse
func (c *ClientWithResponses) GetSshKeysWithResponse(ctx context.Context, params *GetSshKeysParams, reqEditors ...RequestEditorFn) (*GetSshKeysResponse, error) {
	rsp, err := c.GetSshKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshKeysResponse(rsp)
}

// AddSshKeyWithBodyWithResponse request with arbitrary body returning *AddSshKeyResponse
func (c *ClientWithResponses) AddSshKeyWithBodyWithResponse(ctx context.Context, params *AddSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error) {
	rsp, err := c.AddSshKeyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSshKeyResponse(rsp)
}

func (c *ClientWithResponses) AddSshKeyWithResponse(ctx context.Context, params *AddSshKeyParams, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error) {
	rsp, err := c.AddSshKey(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSshKeyResponse(rsp)
}

// DeleteSshKeyWithResponse request returning *DeleteSshKeyResponse
func (c *ClientWithResponses) DeleteSshKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error) {
	rsp, err := c.DeleteSshKey(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshKeyResponse(rsp)
}

// GetSshKeyWithResponse request returning *GetSshKeyResponse
func (c *ClientWithResponses) GetSshKeyWithResponse(ctx context.Context, keyId string, reqEditors ...RequestEditorFn) (*GetSshKeyResponse, error) {
	rsp, err := c.GetSshKey(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshKeyResponse(rsp)
}

// SshSettingsWithResponse request returning *SshSettingsResponse
func (c *ClientWithResponses) SshSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SshSettingsResponse, error) {
	rsp, err := c.SshSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSshSettingsResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, projectKey string, repositorySlug string, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, projectKey, repositorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// SetEnabledWithBodyWithResponse request with arbitrary body returning *SetEnabledResponse
func (c *ClientWithResponses) SetEnabledWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEnabledResponse, error) {
	rsp, err := c.SetEnabledWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetEnabledWithResponse(ctx context.Context, projectKey string, repositorySlug string, body SetEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEnabledResponse, error) {
	rsp, err := c.SetEnabled(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEnabledResponse(rsp)
}

// SynchronizeWithBodyWithResponse request with arbitrary body returning *SynchronizeResponse
func (c *ClientWithResponses) SynchronizeWithBodyWithResponse(ctx context.Context, projectKey string, repositorySlug string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SynchronizeResponse, error) {
	rsp, err := c.SynchronizeWithBody(ctx, projectKey, repositorySlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSynchronizeResponse(rsp)
}

func (c *ClientWithResponses) SynchronizeWithResponse(ctx context.Context, projectKey string, repositorySlug string, body SynchronizeJSONRequestBody, reqEditors ...RequestEditorFn) (*SynchronizeResponse, error) {
	rsp, err := c.Synchronize(ctx, projectKey, repositorySlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSynchronizeResponse(rsp)
}

// ParseGetAllAccessTokensResponse parses an HTTP response from a GetAllAccessTokensWithResponse call
func ParseGetAllAccessTokensResponse(rsp *http.Response) (*GetAllAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestAccessToken `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAccessTokenResponse parses an HTTP response from a CreateAccessTokenWithResponse call
func ParseCreateAccessTokenResponse(rsp *http.Response) (*CreateAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRawAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAllAccessTokens1Response parses an HTTP response from a GetAllAccessTokens1WithResponse call
func ParseGetAllAccessTokens1Response(rsp *http.Response) (*GetAllAccessTokens1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessTokens1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestAccessToken `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAccessToken1Response parses an HTTP response from a CreateAccessToken1WithResponse call
func ParseCreateAccessToken1Response(rsp *http.Response) (*CreateAccessToken1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessToken1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRawAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteById1Response parses an HTTP response from a DeleteById1WithResponse call
func ParseDeleteById1Response(rsp *http.Response) (*DeleteById1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteById1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetById1Response parses an HTTP response from a GetById1WithResponse call
func ParseGetById1Response(rsp *http.Response) (*GetById1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetById1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAccessToken1Response parses an HTTP response from a UpdateAccessToken1WithResponse call
func ParseUpdateAccessToken1Response(rsp *http.Response) (*UpdateAccessToken1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessToken1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteByIdResponse parses an HTTP response from a DeleteByIdWithResponse call
func ParseDeleteByIdResponse(rsp *http.Response) (*DeleteByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetByIdResponse parses an HTTP response from a GetByIdWithResponse call
func ParseGetByIdResponse(rsp *http.Response) (*GetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAccessTokenResponse parses an HTTP response from a UpdateAccessTokenWithResponse call
func ParseUpdateAccessTokenResponse(rsp *http.Response) (*UpdateAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllAccessTokens2Response parses an HTTP response from a GetAllAccessTokens2WithResponse call
func ParseGetAllAccessTokens2Response(rsp *http.Response) (*GetAllAccessTokens2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAccessTokens2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestAccessToken `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAccessToken2Response parses an HTTP response from a CreateAccessToken2WithResponse call
func ParseCreateAccessToken2Response(rsp *http.Response) (*CreateAccessToken2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessToken2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRawAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteById2Response parses an HTTP response from a DeleteById2WithResponse call
func ParseDeleteById2Response(rsp *http.Response) (*DeleteById2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteById2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetById2Response parses an HTTP response from a GetById2WithResponse call
func ParseGetById2Response(rsp *http.Response) (*GetById2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetById2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAccessToken2Response parses an HTTP response from a UpdateAccessToken2WithResponse call
func ParseUpdateAccessToken2Response(rsp *http.Response) (*UpdateAccessToken2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessToken2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGlobalSettingsResponse parses an HTTP response from a GetGlobalSettingsWithResponse call
func ParseGetGlobalSettingsResponse(rsp *http.Response) (*GetGlobalSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshKeySettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateGlobalSettingsResponse parses an HTTP response from a UpdateGlobalSettingsWithResponse call
func ParseUpdateGlobalSettingsResponse(rsp *http.Response) (*UpdateGlobalSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGlobalSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSupportedKeyTypesResponse parses an HTTP response from a GetSupportedKeyTypesWithResponse call
func ParseGetSupportedKeyTypesResponse(rsp *http.Response) (*GetSupportedKeyTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportedKeyTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteBannerResponse parses an HTTP response from a DeleteBannerWithResponse call
func ParseDeleteBannerResponse(rsp *http.Response) (*DeleteBannerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetBannerResponse parses an HTTP response from a GetBannerWithResponse call
func ParseGetBannerResponse(rsp *http.Response) (*GetBannerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAnnouncementBanner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetBannerResponse parses an HTTP response from a SetBannerWithResponse call
func ParseSetBannerResponse(rsp *http.Response) (*SetBannerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetInformationResponse parses an HTTP response from a GetInformationWithResponse call
func ParseGetInformationResponse(rsp *http.Response) (*GetInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestClusterInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseClearDefaultBranchResponse parses an HTTP response from a ClearDefaultBranchWithResponse call
func ParseClearDefaultBranchResponse(rsp *http.Response) (*ClearDefaultBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearDefaultBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDefaultBranchResponse parses an HTTP response from a GetDefaultBranchWithResponse call
func ParseGetDefaultBranchResponse(rsp *http.Response) (*GetDefaultBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetDefaultBranchResponse parses an HTTP response from a SetDefaultBranchWithResponse call
func ParseSetDefaultBranchResponse(rsp *http.Response) (*SetDefaultBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetControlPlanePublicKeyResponse parses an HTTP response from a GetControlPlanePublicKeyWithResponse call
func ParseGetControlPlanePublicKeyResponse(rsp *http.Response) (*GetControlPlanePublicKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetControlPlanePublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseConnectivityResponse parses an HTTP response from a ConnectivityWithResponse call
func ParseConnectivityResponse(rsp *http.Response) (*ConnectivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshConnectivityReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllRegisteredMeshNodesResponse parses an HTTP response from a GetAllRegisteredMeshNodesWithResponse call
func ParseGetAllRegisteredMeshNodesResponse(rsp *http.Response) (*GetAllRegisteredMeshNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRegisteredMeshNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRegisterNewMeshNodeResponse parses an HTTP response from a RegisterNewMeshNodeWithResponse call
func ParseRegisterNewMeshNodeResponse(rsp *http.Response) (*RegisterNewMeshNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterNewMeshNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDelete2Response parses an HTTP response from a Delete2WithResponse call
func ParseDelete2Response(rsp *http.Response) (*Delete2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRegisteredMeshNodeByIdResponse parses an HTTP response from a GetRegisteredMeshNodeByIdWithResponse call
func ParseGetRegisteredMeshNodeByIdResponse(rsp *http.Response) (*GetRegisteredMeshNodeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegisteredMeshNodeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateMeshNodeResponse parses an HTTP response from a UpdateMeshNodeWithResponse call
func ParseUpdateMeshNodeResponse(rsp *http.Response) (*UpdateMeshNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMeshNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSupportZipsResponse parses an HTTP response from a GetSupportZipsWithResponse call
func ParseGetSupportZipsResponse(rsp *http.Response) (*GetSupportZipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportZipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSupportZipResponse parses an HTTP response from a GetSupportZipWithResponse call
func ParseGetSupportZipResponse(rsp *http.Response) (*GetSupportZipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportZipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetGroups1Response parses an HTTP response from a GetGroups1WithResponse call
func ParseGetGroups1Response(rsp *http.Response) (*GetGroups1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroups1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestDetailedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAddUserToGroupResponse parses an HTTP response from a AddUserToGroupWithResponse call
func ParseAddUserToGroupResponse(rsp *http.Response) (*AddUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddUsersToGroupResponse parses an HTTP response from a AddUsersToGroupWithResponse call
func ParseAddUsersToGroupResponse(rsp *http.Response) (*AddUsersToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUsersToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindUsersInGroupResponse parses an HTTP response from a FindUsersInGroupWithResponse call
func ParseFindUsersInGroupResponse(rsp *http.Response) (*FindUsersInGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUsersInGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestDetailedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindUsersNotInGroupResponse parses an HTTP response from a FindUsersNotInGroupWithResponse call
func ParseFindUsersNotInGroupResponse(rsp *http.Response) (*FindUsersNotInGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUsersNotInGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestDetailedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromGroupResponse parses an HTTP response from a RemoveUserFromGroupWithResponse call
func ParseRemoveUserFromGroupResponse(rsp *http.Response) (*RemoveUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet2Response parses an HTTP response from a Get2WithResponse call
func ParseGet2Response(rsp *http.Response) (*Get2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBitbucketLicense
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLicenseResponse parses an HTTP response from a UpdateLicenseWithResponse call
func ParseUpdateLicenseResponse(rsp *http.Response) (*UpdateLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBitbucketLicense
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteMailConfigResponse parses an HTTP response from a DeleteMailConfigWithResponse call
func ParseDeleteMailConfigResponse(rsp *http.Response) (*DeleteMailConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetMailConfigResponse parses an HTTP response from a GetMailConfigWithResponse call
func ParseGetMailConfigResponse(rsp *http.Response) (*GetMailConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMailConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetMailConfigResponse parses an HTTP response from a SetMailConfigWithResponse call
func ParseSetMailConfigResponse(rsp *http.Response) (*SetMailConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMailConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMailConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseClearSenderAddressResponse parses an HTTP response from a ClearSenderAddressWithResponse call
func ParseClearSenderAddressResponse(rsp *http.Response) (*ClearSenderAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearSenderAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSenderAddressResponse parses an HTTP response from a GetSenderAddressWithResponse call
func ParseGetSenderAddressResponse(rsp *http.Response) (*GetSenderAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSenderAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetSenderAddressResponse parses an HTTP response from a SetSenderAddressWithResponse call
func ParseSetSenderAddressResponse(rsp *http.Response) (*SetSenderAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSenderAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRevokePermissionsForGroupResponse parses an HTTP response from a RevokePermissionsForGroupWithResponse call
func ParseRevokePermissionsForGroupResponse(rsp *http.Response) (*RevokePermissionsForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithAnyPermissionResponse parses an HTTP response from a GetGroupsWithAnyPermissionWithResponse call
func ParseGetGroupsWithAnyPermissionResponse(rsp *http.Response) (*GetGroupsWithAnyPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithAnyPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestPermittedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetPermissionForGroupsResponse parses an HTTP response from a SetPermissionForGroupsWithResponse call
func ParseSetPermissionForGroupsResponse(rsp *http.Response) (*SetPermissionForGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithoutAnyPermissionResponse parses an HTTP response from a GetGroupsWithoutAnyPermissionWithResponse call
func ParseGetGroupsWithoutAnyPermissionResponse(rsp *http.Response) (*GetGroupsWithoutAnyPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithoutAnyPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestDetailedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRevokePermissionsForUserResponse parses an HTTP response from a RevokePermissionsForUserWithResponse call
func ParseRevokePermissionsForUserResponse(rsp *http.Response) (*RevokePermissionsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsersWithAnyPermissionResponse parses an HTTP response from a GetUsersWithAnyPermissionWithResponse call
func ParseGetUsersWithAnyPermissionResponse(rsp *http.Response) (*GetUsersWithAnyPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithAnyPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestPermittedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetPermissionForUsersResponse parses an HTTP response from a SetPermissionForUsersWithResponse call
func ParseSetPermissionForUsersResponse(rsp *http.Response) (*SetPermissionForUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsersWithoutAnyPermissionResponse parses an HTTP response from a GetUsersWithoutAnyPermissionWithResponse call
func ParseGetUsersWithoutAnyPermissionResponse(rsp *http.Response) (*GetUsersWithoutAnyPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithoutAnyPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                  `json:"isLastPage,omitempty"`
			Limit         *float32               `json:"limit,omitempty"`
			NextPageStart *int32                 `json:"nextPageStart,omitempty"`
			Size          *float32               `json:"size,omitempty"`
			Start         *int32                 `json:"start,omitempty"`
			Values        *[]RestApplicationUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetMergeConfigResponse parses an HTTP response from a GetMergeConfigWithResponse call
func ParseGetMergeConfigResponse(rsp *http.Response) (*GetMergeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMergeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestMergeConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetMergeConfigResponse parses an HTTP response from a SetMergeConfigWithResponse call
func ParseSetMergeConfigResponse(rsp *http.Response) (*SetMergeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMergeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestMergeConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetHistoryResponse parses an HTTP response from a GetHistoryWithResponse call
func ParseGetHistoryResponse(rsp *http.Response) (*GetHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                         `json:"isLastPage,omitempty"`
			Limit         *float32                      `json:"limit,omitempty"`
			NextPageStart *int32                        `json:"nextPageStart,omitempty"`
			Size          *float32                      `json:"size,omitempty"`
			Start         *int32                        `json:"start,omitempty"`
			Values        *[]RestAggregateRejectCounter `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSettings2Response parses an HTTP response from a GetSettings2WithResponse call
func ParseGetSettings2Response(rsp *http.Response) (*GetSettings2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettings2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRateLimitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetSettings2Response parses an HTTP response from a SetSettings2WithResponse call
func ParseSetSettings2Response(rsp *http.Response) (*SetSettings2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSettings2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRateLimitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllRateLimitSettingsResponse parses an HTTP response from a GetAllRateLimitSettingsWithResponse call
func ParseGetAllRateLimitSettingsResponse(rsp *http.Response) (*GetAllRateLimitSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRateLimitSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                        `json:"isLastPage,omitempty"`
			Limit         *float32                     `json:"limit,omitempty"`
			NextPageStart *int32                       `json:"nextPageStart,omitempty"`
			Size          *float32                     `json:"size,omitempty"`
			Start         *int32                       `json:"start,omitempty"`
			Values        *[]RestUserRateLimitSettings `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSet2Response parses an HTTP response from a Set2WithResponse call
func ParseSet2Response(rsp *http.Response) (*Set2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Set2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserRateLimitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDelete8Response parses an HTTP response from a Delete8WithResponse call
func ParseDelete8Response(rsp *http.Response) (*Delete8Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet6Response parses an HTTP response from a Get6WithResponse call
func ParseGet6Response(rsp *http.Response) (*Get6Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserRateLimitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSet3Response parses an HTTP response from a Set3WithResponse call
func ParseSet3Response(rsp *http.Response) (*Set3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Set3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserRateLimitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserDirectoriesResponse parses an HTTP response from a GetUserDirectoriesWithResponse call
func ParseGetUserDirectoriesResponse(rsp *http.Response) (*GetUserDirectoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDirectoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserDirectory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsers1Response parses an HTTP response from a GetUsers1WithResponse call
func ParseGetUsers1Response(rsp *http.Response) (*GetUsers1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsers1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestDetailedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUpdateUserDetailsResponse parses an HTTP response from a UpdateUserDetailsWithResponse call
func ParseUpdateUserDetailsResponse(rsp *http.Response) (*UpdateUserDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddGroupToUserResponse parses an HTTP response from a AddGroupToUserWithResponse call
func ParseAddGroupToUserResponse(rsp *http.Response) (*AddGroupToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGroupToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddUserToGroupsResponse parses an HTTP response from a AddUserToGroupsWithResponse call
func ParseAddUserToGroupsResponse(rsp *http.Response) (*AddUserToGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearUserCaptchaChallengeResponse parses an HTTP response from a ClearUserCaptchaChallengeWithResponse call
func ParseClearUserCaptchaChallengeResponse(rsp *http.Response) (*ClearUserCaptchaChallengeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearUserCaptchaChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateUserPasswordResponse parses an HTTP response from a UpdateUserPasswordWithResponse call
func ParseUpdateUserPasswordResponse(rsp *http.Response) (*UpdateUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseValidateErasableResponse parses an HTTP response from a ValidateErasableWithResponse call
func ParseValidateErasableResponse(rsp *http.Response) (*ValidateErasableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateErasableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseEraseUserResponse parses an HTTP response from a EraseUserWithResponse call
func ParseEraseUserResponse(rsp *http.Response) (*EraseUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EraseUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestErasedUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseFindGroupsForUserResponse parses an HTTP response from a FindGroupsForUserWithResponse call
func ParseFindGroupsForUserResponse(rsp *http.Response) (*FindGroupsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGroupsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestDetailedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOtherGroupsForUserResponse parses an HTTP response from a FindOtherGroupsForUserWithResponse call
func ParseFindOtherGroupsForUserResponse(rsp *http.Response) (*FindOtherGroupsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOtherGroupsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestDetailedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRemoveGroupFromUserResponse parses an HTTP response from a RemoveGroupFromUserWithResponse call
func ParseRemoveGroupFromUserResponse(rsp *http.Response) (*RemoveGroupFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveGroupFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRenameUserResponse parses an HTTP response from a RenameUserWithResponse call
func ParseRenameUserResponse(rsp *http.Response) (*RenameUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApplicationPropertiesResponse parses an HTTP response from a GetApplicationPropertiesWithResponse call
func ParseGetApplicationPropertiesResponse(rsp *http.Response) (*GetApplicationPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestApplicationProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCapabilitiesResponse parses an HTTP response from a GetCapabilitiesWithResponse call
func ParseGetCapabilitiesResponse(rsp *http.Response) (*GetCapabilitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBuildCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPullRequestSuggestionsResponse parses an HTTP response from a GetPullRequestSuggestionsWithResponse call
func ParseGetPullRequestSuggestionsResponse(rsp *http.Response) (*GetPullRequestSuggestionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestSuggestionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                        `json:"isLastPage,omitempty"`
			Limit         *float32                     `json:"limit,omitempty"`
			NextPageStart *int32                       `json:"nextPageStart,omitempty"`
			Size          *float32                     `json:"size,omitempty"`
			Start         *int32                       `json:"start,omitempty"`
			Values        *[]RestPullRequestSuggestion `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPullRequests1Response parses an HTTP response from a GetPullRequests1WithResponse call
func ParseGetPullRequests1Response(rsp *http.Response) (*GetPullRequests1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequests1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestPullRequest `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCapabilities1Response parses an HTTP response from a GetCapabilities1WithResponse call
func ParseGetCapabilities1Response(rsp *http.Response) (*GetCapabilities1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCapabilities1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool     `json:"isLastPage,omitempty"`
			Limit         *float32  `json:"limit,omitempty"`
			NextPageStart *int32    `json:"nextPageStart,omitempty"`
			Size          *float32  `json:"size,omitempty"`
			Start         *int32    `json:"start,omitempty"`
			Values        *[]string `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateHookScriptResponse parses an HTTP response from a CreateHookScriptWithResponse call
func ParseCreateHookScriptResponse(rsp *http.Response) (*CreateHookScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHookScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestHookScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteHookScriptResponse parses an HTTP response from a DeleteHookScriptWithResponse call
func ParseDeleteHookScriptResponse(rsp *http.Response) (*DeleteHookScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHookScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetHookScriptResponse parses an HTTP response from a GetHookScriptWithResponse call
func ParseGetHookScriptResponse(rsp *http.Response) (*GetHookScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHookScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestHookScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateHookScriptResponse parses an HTTP response from a UpdateHookScriptWithResponse call
func ParseUpdateHookScriptResponse(rsp *http.Response) (*UpdateHookScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateHookScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestHookScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReadResponse parses an HTTP response from a ReadWithResponse call
func ParseReadResponse(rsp *http.Response) (*ReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAvatarResponse parses an HTTP response from a GetAvatarWithResponse call
func ParseGetAvatarResponse(rsp *http.Response) (*GetAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPullRequests2Response parses an HTTP response from a GetPullRequests2WithResponse call
func ParseGetPullRequests2Response(rsp *http.Response) (*GetPullRequests2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequests2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPullRequestCountResponse parses an HTTP response from a GetPullRequestCountWithResponse call
func ParseGetPullRequestCountResponse(rsp *http.Response) (*GetPullRequestCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLabelsResponse parses an HTTP response from a GetLabelsWithResponse call
func ParseGetLabelsResponse(rsp *http.Response) (*GetLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool        `json:"isLastPage,omitempty"`
			Limit         *float32     `json:"limit,omitempty"`
			NextPageStart *int32       `json:"nextPageStart,omitempty"`
			Size          *float32     `json:"size,omitempty"`
			Start         *int32       `json:"start,omitempty"`
			Values        *[]RestLabel `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLabelResponse parses an HTTP response from a GetLabelWithResponse call
func ParseGetLabelResponse(rsp *http.Response) (*GetLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestLabel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLabelablesResponse parses an HTTP response from a GetLabelablesWithResponse call
func ParseGetLabelablesResponse(rsp *http.Response) (*GetLabelablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabelablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool            `json:"isLastPage,omitempty"`
			Limit         *float32         `json:"limit,omitempty"`
			NextPageStart *int32           `json:"nextPageStart,omitempty"`
			Size          *float32         `json:"size,omitempty"`
			Start         *int32           `json:"start,omitempty"`
			Values        *[]RestLabelable `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLevelResponse parses an HTTP response from a GetLevelWithResponse call
func ParseGetLevelResponse(rsp *http.Response) (*GetLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestLogLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetLevelResponse parses an HTTP response from a SetLevelWithResponse call
func ParseSetLevelResponse(rsp *http.Response) (*SetLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRootLevelResponse parses an HTTP response from a GetRootLevelWithResponse call
func ParseGetRootLevelResponse(rsp *http.Response) (*GetRootLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestLogLevel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetRootLevelResponse parses an HTTP response from a SetRootLevelWithResponse call
func ParseSetRootLevelResponse(rsp *http.Response) (*SetRootLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRootLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePreviewResponse parses an HTTP response from a PreviewWithResponse call
func ParsePreviewResponse(rsp *http.Response) (*PreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMarkup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseStartExportResponse parses an HTTP response from a StartExportWithResponse call
func ParseStartExportResponse(rsp *http.Response) (*StartExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePreviewExportResponse parses an HTTP response from a PreviewExportWithResponse call
func ParsePreviewExportResponse(rsp *http.Response) (*PreviewExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestScopesExample
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetExportJobResponse parses an HTTP response from a GetExportJobWithResponse call
func ParseGetExportJobResponse(rsp *http.Response) (*GetExportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelExportJobResponse parses an HTTP response from a CancelExportJobWithResponse call
func ParseCancelExportJobResponse(rsp *http.Response) (*CancelExportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelExportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetExportJobMessagesResponse parses an HTTP response from a GetExportJobMessagesWithResponse call
func ParseGetExportJobMessagesResponse(rsp *http.Response) (*GetExportJobMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportJobMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestJobMessage `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartImportResponse parses an HTTP response from a StartImportWithResponse call
func ParseStartImportResponse(rsp *http.Response) (*StartImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetImportJobResponse parses an HTTP response from a GetImportJobWithResponse call
func ParseGetImportJobResponse(rsp *http.Response) (*GetImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelImportJobResponse parses an HTTP response from a CancelImportJobWithResponse call
func ParseCancelImportJobResponse(rsp *http.Response) (*CancelImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetImportJobMessagesResponse parses an HTTP response from a GetImportJobMessagesWithResponse call
func ParseGetImportJobMessagesResponse(rsp *http.Response) (*GetImportJobMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportJobMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestJobMessage `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartMeshMigrationResponse parses an HTTP response from a StartMeshMigrationWithResponse call
func ParseStartMeshMigrationResponse(rsp *http.Response) (*StartMeshMigrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartMeshMigrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePreviewMeshMigrationResponse parses an HTTP response from a PreviewMeshMigrationWithResponse call
func ParsePreviewMeshMigrationResponse(rsp *http.Response) (*PreviewMeshMigrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewMeshMigrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExamplePreviewMigration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSearchMeshMigrationReposResponse parses an HTTP response from a SearchMeshMigrationReposWithResponse call
func ParseSearchMeshMigrationReposResponse(rsp *http.Response) (*SearchMeshMigrationReposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMeshMigrationReposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                      `json:"isLastPage,omitempty"`
			Limit         *float32                   `json:"limit,omitempty"`
			NextPageStart *int32                     `json:"nextPageStart,omitempty"`
			Size          *float32                   `json:"size,omitempty"`
			Start         *int32                     `json:"start,omitempty"`
			Values        *[]RestMigrationRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAllMeshMigrationSummariesResponse parses an HTTP response from a GetAllMeshMigrationSummariesWithResponse call
func ParseGetAllMeshMigrationSummariesResponse(rsp *http.Response) (*GetAllMeshMigrationSummariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllMeshMigrationSummariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                       `json:"isLastPage,omitempty"`
			Limit         *float32                    `json:"limit,omitempty"`
			NextPageStart *int32                      `json:"nextPageStart,omitempty"`
			Size          *float32                    `json:"size,omitempty"`
			Start         *int32                      `json:"start,omitempty"`
			Values        *[]RestMeshMigrationSummary `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetActiveMeshMigrationSummaryResponse parses an HTTP response from a GetActiveMeshMigrationSummaryWithResponse call
func ParseGetActiveMeshMigrationSummaryResponse(rsp *http.Response) (*GetActiveMeshMigrationSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveMeshMigrationSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshMigrationSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMeshMigrationJobResponse parses an HTTP response from a GetMeshMigrationJobWithResponse call
func ParseGetMeshMigrationJobResponse(rsp *http.Response) (*GetMeshMigrationJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeshMigrationJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelMeshMigrationJobResponse parses an HTTP response from a CancelMeshMigrationJobWithResponse call
func ParseCancelMeshMigrationJobResponse(rsp *http.Response) (*CancelMeshMigrationJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelMeshMigrationJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetMeshMigrationJobMessagesResponse parses an HTTP response from a GetMeshMigrationJobMessagesWithResponse call
func ParseGetMeshMigrationJobMessagesResponse(rsp *http.Response) (*GetMeshMigrationJobMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeshMigrationJobMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestJobMessage `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMeshMigrationJobSummaryResponse parses an HTTP response from a GetMeshMigrationJobSummaryWithResponse call
func ParseGetMeshMigrationJobSummaryResponse(rsp *http.Response) (*GetMeshMigrationJobSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeshMigrationJobSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMeshMigrationSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesRecentlyAccessedResponse parses an HTTP response from a GetRepositoriesRecentlyAccessedWithResponse call
func ParseGetRepositoriesRecentlyAccessedResponse(rsp *http.Response) (*GetRepositoriesRecentlyAccessedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesRecentlyAccessedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetProjectsResponse parses an HTTP response from a GetProjectsWithResponse call
func ParseGetProjectsResponse(rsp *http.Response) (*GetProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool          `json:"isLastPage,omitempty"`
			Limit         *float32       `json:"limit,omitempty"`
			NextPageStart *int32         `json:"nextPageStart,omitempty"`
			Size          *float32       `json:"size,omitempty"`
			Start         *int32         `json:"start,omitempty"`
			Values        *[]RestProject `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProjectAvatarResponse parses an HTTP response from a GetProjectAvatarWithResponse call
func ParseGetProjectAvatarResponse(rsp *http.Response) (*GetProjectAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadAvatarResponse parses an HTTP response from a UploadAvatarWithResponse call
func ParseUploadAvatarResponse(rsp *http.Response) (*UploadAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConfigurationsResponse parses an HTTP response from a GetConfigurationsWithResponse call
func ParseGetConfigurationsResponse(rsp *http.Response) (*GetConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                   `json:"isLastPage,omitempty"`
			Limit         *float32                `json:"limit,omitempty"`
			NextPageStart *int32                  `json:"nextPageStart,omitempty"`
			Size          *float32                `json:"size,omitempty"`
			Start         *int32                  `json:"start,omitempty"`
			Values        *[]RestHookScriptConfig `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRemoveConfigurationResponse parses an HTTP response from a RemoveConfigurationWithResponse call
func ParseRemoveConfigurationResponse(rsp *http.Response) (*RemoveConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetConfigurationResponse parses an HTTP response from a SetConfigurationWithResponse call
func ParseSetConfigurationResponse(rsp *http.Response) (*SetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestHookScriptConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRevokePermissionsResponse parses an HTTP response from a RevokePermissionsWithResponse call
func ParseRevokePermissionsResponse(rsp *http.Response) (*RevokePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRevokePermissionsForGroup1Response parses an HTTP response from a RevokePermissionsForGroup1WithResponse call
func ParseRevokePermissionsForGroup1Response(rsp *http.Response) (*RevokePermissionsForGroup1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForGroup1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithAnyPermission1Response parses an HTTP response from a GetGroupsWithAnyPermission1WithResponse call
func ParseGetGroupsWithAnyPermission1Response(rsp *http.Response) (*GetGroupsWithAnyPermission1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithAnyPermission1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestPermittedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPermissionForGroups1Response parses an HTTP response from a SetPermissionForGroups1WithResponse call
func ParseSetPermissionForGroups1Response(rsp *http.Response) (*SetPermissionForGroups1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForGroups1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithoutAnyPermission1Response parses an HTTP response from a GetGroupsWithoutAnyPermission1WithResponse call
func ParseGetGroupsWithoutAnyPermission1Response(rsp *http.Response) (*GetGroupsWithoutAnyPermission1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithoutAnyPermission1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestDetailedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchPermissionsResponse parses an HTTP response from a SearchPermissionsWithResponse call
func ParseSearchPermissionsResponse(rsp *http.Response) (*SearchPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsForUser1Response parses an HTTP response from a RevokePermissionsForUser1WithResponse call
func ParseRevokePermissionsForUser1Response(rsp *http.Response) (*RevokePermissionsForUser1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForUser1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsersWithAnyPermission1Response parses an HTTP response from a GetUsersWithAnyPermission1WithResponse call
func ParseGetUsersWithAnyPermission1Response(rsp *http.Response) (*GetUsersWithAnyPermission1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithAnyPermission1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestPermittedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPermissionForUsers1Response parses an HTTP response from a SetPermissionForUsers1WithResponse call
func ParseSetPermissionForUsers1Response(rsp *http.Response) (*SetPermissionForUsers1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForUsers1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersWithoutPermissionResponse parses an HTTP response from a GetUsersWithoutPermissionWithResponse call
func ParseGetUsersWithoutPermissionResponse(rsp *http.Response) (*GetUsersWithoutPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithoutPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                  `json:"isLastPage,omitempty"`
			Limit         *float32               `json:"limit,omitempty"`
			NextPageStart *int32                 `json:"nextPageStart,omitempty"`
			Size          *float32               `json:"size,omitempty"`
			Start         *int32                 `json:"start,omitempty"`
			Values        *[]RestApplicationUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHasAllUserPermissionResponse parses an HTTP response from a HasAllUserPermissionWithResponse call
func ParseHasAllUserPermissionResponse(rsp *http.Response) (*HasAllUserPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HasAllUserPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPermitted
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseModifyAllUserPermissionResponse parses an HTTP response from a ModifyAllUserPermissionWithResponse call
func ParseModifyAllUserPermissionResponse(rsp *http.Response) (*ModifyAllUserPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyAllUserPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesResponse parses an HTTP response from a GetRepositoriesWithResponse call
func ParseGetRepositoriesResponse(rsp *http.Response) (*GetRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseForkRepositoryResponse parses an HTTP response from a ForkRepositoryWithResponse call
func ParseForkRepositoryResponse(rsp *http.Response) (*ForkRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForkRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRepositoryResponse parses an HTTP response from a UpdateRepositoryWithResponse call
func ParseUpdateRepositoryResponse(rsp *http.Response) (*UpdateRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetArchiveResponse parses an HTTP response from a GetArchiveWithResponse call
func ParseGetArchiveResponse(rsp *http.Response) (*GetArchiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAttachmentResponse parses an HTTP response from a DeleteAttachmentWithResponse call
func ParseDeleteAttachmentResponse(rsp *http.Response) (*DeleteAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAttachmentResponse parses an HTTP response from a GetAttachmentWithResponse call
func ParseGetAttachmentResponse(rsp *http.Response) (*GetAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAttachmentMetadataResponse parses an HTTP response from a DeleteAttachmentMetadataWithResponse call
func ParseDeleteAttachmentMetadataResponse(rsp *http.Response) (*DeleteAttachmentMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttachmentMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAttachmentMetadataResponse parses an HTTP response from a GetAttachmentMetadataWithResponse call
func ParseGetAttachmentMetadataResponse(rsp *http.Response) (*GetAttachmentMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAttachmentMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSaveAttachmentMetadataResponse parses an HTTP response from a SaveAttachmentMetadataWithResponse call
func ParseSaveAttachmentMetadataResponse(rsp *http.Response) (*SaveAttachmentMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveAttachmentMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBranchesResponse parses an HTTP response from a GetBranchesWithResponse call
func ParseGetBranchesResponse(rsp *http.Response) (*GetBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestBranch `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateBranchForRepositoryResponse parses an HTTP response from a CreateBranchForRepositoryWithResponse call
func ParseCreateBranchForRepositoryResponse(rsp *http.Response) (*CreateBranchForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBranch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDefaultBranch1Response parses an HTTP response from a GetDefaultBranch1WithResponse call
func ParseGetDefaultBranch1Response(rsp *http.Response) (*GetDefaultBranch1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultBranch1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBranch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetDefaultBranch1Response parses an HTTP response from a SetDefaultBranch1WithResponse call
func ParseSetDefaultBranch1Response(rsp *http.Response) (*SetDefaultBranch1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultBranch1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetContentResponse parses an HTTP response from a GetContentWithResponse call
func ParseGetContentResponse(rsp *http.Response) (*GetContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetContent1Response parses an HTTP response from a GetContent1WithResponse call
func ParseGetContent1Response(rsp *http.Response) (*GetContent1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContent1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditFileResponse parses an HTTP response from a EditFileWithResponse call
func ParseEditFileResponse(rsp *http.Response) (*EditFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetChanges1Response parses an HTTP response from a GetChanges1WithResponse call
func ParseGetChanges1Response(rsp *http.Response) (*GetChanges1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChanges1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestChange `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCommitsResponse parses an HTTP response from a GetCommitsWithResponse call
func ParseGetCommitsResponse(rsp *http.Response) (*GetCommitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestCommit `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCommitResponse parses an HTTP response from a GetCommitWithResponse call
func ParseGetCommitResponse(rsp *http.Response) (*GetCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteResponse parses an HTTP response from a DeleteWithResponse call
func ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetResponse parses an HTTP response from a GetWithResponse call
func ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBuildStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddResponse parses an HTTP response from a AddWithResponse call
func ParseAddResponse(rsp *http.Response) (*AddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChangesResponse parses an HTTP response from a GetChangesWithResponse call
func ParseGetChangesResponse(rsp *http.Response) (*GetChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestChange `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCommentsResponse parses an HTTP response from a GetCommentsWithResponse call
func ParseGetCommentsResponse(rsp *http.Response) (*GetCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool          `json:"isLastPage,omitempty"`
			Limit         *float32       `json:"limit,omitempty"`
			NextPageStart *int32         `json:"nextPageStart,omitempty"`
			Size          *float32       `json:"size,omitempty"`
			Start         *int32         `json:"start,omitempty"`
			Values        *[]RestComment `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateCommentResponse parses an HTTP response from a CreateCommentWithResponse call
func ParseCreateCommentResponse(rsp *http.Response) (*CreateCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteCommentResponse parses an HTTP response from a DeleteCommentWithResponse call
func ParseDeleteCommentResponse(rsp *http.Response) (*DeleteCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetCommentResponse parses an HTTP response from a GetCommentWithResponse call
func ParseGetCommentResponse(rsp *http.Response) (*GetCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCommentResponse parses an HTTP response from a UpdateCommentWithResponse call
func ParseUpdateCommentResponse(rsp *http.Response) (*UpdateCommentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDelete1Response parses an HTTP response from a Delete1WithResponse call
func ParseDelete1Response(rsp *http.Response) (*Delete1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet1Response parses an HTTP response from a Get1WithResponse call
func ParseGet1Response(rsp *http.Response) (*Get1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDeployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateDeploymentResponse parses an HTTP response from a CreateOrUpdateDeploymentWithResponse call
func ParseCreateOrUpdateDeploymentResponse(rsp *http.Response) (*CreateOrUpdateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDeployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDiffStatsSummaryResponse parses an HTTP response from a GetDiffStatsSummaryWithResponse call
func ParseGetDiffStatsSummaryResponse(rsp *http.Response) (*GetDiffStatsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiffStatsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiffStatsSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamDiffResponse parses an HTTP response from a StreamDiffWithResponse call
func ParseStreamDiffResponse(rsp *http.Response) (*StreamDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMergeBaseResponse parses an HTTP response from a GetMergeBaseWithResponse call
func ParseGetMergeBaseResponse(rsp *http.Response) (*GetMergeBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMergeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPullRequestsResponse parses an HTTP response from a GetPullRequestsWithResponse call
func ParseGetPullRequestsResponse(rsp *http.Response) (*GetPullRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestPullRequest `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnwatchResponse parses an HTTP response from a UnwatchWithResponse call
func ParseUnwatchResponse(rsp *http.Response) (*UnwatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnwatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWatchResponse parses an HTTP response from a WatchWithResponse call
func ParseWatchResponse(rsp *http.Response) (*WatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamChangesResponse parses an HTTP response from a StreamChangesWithResponse call
func ParseStreamChangesResponse(rsp *http.Response) (*StreamChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestChange `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamCommitsResponse parses an HTTP response from a StreamCommitsWithResponse call
func ParseStreamCommitsResponse(rsp *http.Response) (*StreamCommitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestCommit `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDiffStatsSummary1Response parses an HTTP response from a GetDiffStatsSummary1WithResponse call
func ParseGetDiffStatsSummary1Response(rsp *http.Response) (*GetDiffStatsSummary1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiffStatsSummary1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamDiff1Response parses an HTTP response from a StreamDiff1WithResponse call
func ParseStreamDiff1Response(rsp *http.Response) (*StreamDiff1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamDiff1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamContributingResponse parses an HTTP response from a StreamContributingWithResponse call
func ParseStreamContributingResponse(rsp *http.Response) (*StreamContributingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamContributingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDefaultBranch2Response parses an HTTP response from a GetDefaultBranch2WithResponse call
func ParseGetDefaultBranch2Response(rsp *http.Response) (*GetDefaultBranch2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultBranch2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMinimalRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetDefaultBranch2Response parses an HTTP response from a SetDefaultBranch2WithResponse call
func ParseSetDefaultBranch2Response(rsp *http.Response) (*SetDefaultBranch2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultBranch2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamRawDiffResponse parses an HTTP response from a StreamRawDiffWithResponse call
func ParseStreamRawDiffResponse(rsp *http.Response) (*StreamRawDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRawDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamRawDiff1Response parses an HTTP response from a StreamRawDiff1WithResponse call
func ParseStreamRawDiff1Response(rsp *http.Response) (*StreamRawDiff1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRawDiff1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamFilesResponse parses an HTTP response from a StreamFilesWithResponse call
func ParseStreamFilesResponse(rsp *http.Response) (*StreamFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]FileListResource `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamFiles1Response parses an HTTP response from a StreamFiles1WithResponse call
func ParseStreamFiles1Response(rsp *http.Response) (*StreamFiles1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFiles1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]FileListResource `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetForkedRepositoriesResponse parses an HTTP response from a GetForkedRepositoriesWithResponse call
func ParseGetForkedRepositoriesResponse(rsp *http.Response) (*GetForkedRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForkedRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConfigurations1Response parses an HTTP response from a GetConfigurations1WithResponse call
func ParseGetConfigurations1Response(rsp *http.Response) (*GetConfigurations1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurations1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                   `json:"isLastPage,omitempty"`
			Limit         *float32                `json:"limit,omitempty"`
			NextPageStart *int32                  `json:"nextPageStart,omitempty"`
			Size          *float32                `json:"size,omitempty"`
			Start         *int32                  `json:"start,omitempty"`
			Values        *[]RestHookScriptConfig `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRemoveConfiguration1Response parses an HTTP response from a RemoveConfiguration1WithResponse call
func ParseRemoveConfiguration1Response(rsp *http.Response) (*RemoveConfiguration1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveConfiguration1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetConfiguration1Response parses an HTTP response from a SetConfiguration1WithResponse call
func ParseSetConfiguration1Response(rsp *http.Response) (*SetConfiguration1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetConfiguration1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestHookScriptConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAllLabelsForRepositoryResponse parses an HTTP response from a GetAllLabelsForRepositoryWithResponse call
func ParseGetAllLabelsForRepositoryResponse(rsp *http.Response) (*GetAllLabelsForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLabelsForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestLabel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddLabelResponse parses an HTTP response from a AddLabelWithResponse call
func ParseAddLabelResponse(rsp *http.Response) (*AddLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestLabel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRemoveLabelResponse parses an HTTP response from a RemoveLabelWithResponse call
func ParseRemoveLabelResponse(rsp *http.Response) (*RemoveLabelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamResponse parses an HTTP response from a StreamWithResponse call
func ParseStreamResponse(rsp *http.Response) (*StreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStream1Response parses an HTTP response from a Stream1WithResponse call
func ParseStream1Response(rsp *http.Response) (*Stream1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Stream1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamLicenseResponse parses an HTTP response from a StreamLicenseWithResponse call
func ParseStreamLicenseResponse(rsp *http.Response) (*StreamLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                  `json:"isLastPage,omitempty"`
			Limit         *float32               `json:"limit,omitempty"`
			NextPageStart *int32                 `json:"nextPageStart,omitempty"`
			Size          *float32               `json:"size,omitempty"`
			Start         *int32                 `json:"start,omitempty"`
			Values        *[]RestApplicationUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamPatchResponse parses an HTTP response from a StreamPatchWithResponse call
func ParseStreamPatchResponse(rsp *http.Response) (*StreamPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRevokePermissions1Response parses an HTTP response from a RevokePermissions1WithResponse call
func ParseRevokePermissions1Response(rsp *http.Response) (*RevokePermissions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRevokePermissionsForGroup2Response parses an HTTP response from a RevokePermissionsForGroup2WithResponse call
func ParseRevokePermissionsForGroup2Response(rsp *http.Response) (*RevokePermissionsForGroup2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForGroup2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithAnyPermission2Response parses an HTTP response from a GetGroupsWithAnyPermission2WithResponse call
func ParseGetGroupsWithAnyPermission2Response(rsp *http.Response) (*GetGroupsWithAnyPermission2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithAnyPermission2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestPermittedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPermissionForGroupResponse parses an HTTP response from a SetPermissionForGroupWithResponse call
func ParseSetPermissionForGroupResponse(rsp *http.Response) (*SetPermissionForGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGroupsWithoutAnyPermission2Response parses an HTTP response from a GetGroupsWithoutAnyPermission2WithResponse call
func ParseGetGroupsWithoutAnyPermission2Response(rsp *http.Response) (*GetGroupsWithoutAnyPermission2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsWithoutAnyPermission2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestDetailedGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchPermissions1Response parses an HTTP response from a SearchPermissions1WithResponse call
func ParseSearchPermissions1Response(rsp *http.Response) (*SearchPermissions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPermissions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsForUser2Response parses an HTTP response from a RevokePermissionsForUser2WithResponse call
func ParseRevokePermissionsForUser2Response(rsp *http.Response) (*RevokePermissionsForUser2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsForUser2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsersWithAnyPermission2Response parses an HTTP response from a GetUsersWithAnyPermission2WithResponse call
func ParseGetUsersWithAnyPermission2Response(rsp *http.Response) (*GetUsersWithAnyPermission2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithAnyPermission2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestPermittedUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPermissionForUserResponse parses an HTTP response from a SetPermissionForUserWithResponse call
func ParseSetPermissionForUserResponse(rsp *http.Response) (*SetPermissionForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPermissionForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersWithoutPermission1Response parses an HTTP response from a GetUsersWithoutPermission1WithResponse call
func ParseGetUsersWithoutPermission1Response(rsp *http.Response) (*GetUsersWithoutPermission1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithoutPermission1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                  `json:"isLastPage,omitempty"`
			Limit         *float32               `json:"limit,omitempty"`
			NextPageStart *int32                 `json:"nextPageStart,omitempty"`
			Size          *float32               `json:"size,omitempty"`
			Start         *int32                 `json:"start,omitempty"`
			Values        *[]RestApplicationUser `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPageResponse parses an HTTP response from a GetPageWithResponse call
func ParseGetPageResponse(rsp *http.Response) (*GetPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestPullRequest `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDelete3Response parses an HTTP response from a Delete3WithResponse call
func ParseDelete3Response(rsp *http.Response) (*Delete3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGet3Response parses an HTTP response from a Get3WithResponse call
func ParseGet3Response(rsp *http.Response) (*Get3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateResponse parses an HTTP response from a UpdateWithResponse call
func ParseUpdateResponse(rsp *http.Response) (*UpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseStreamRawDiff2Response parses an HTTP response from a StreamRawDiff2WithResponse call
func ParseStreamRawDiff2Response(rsp *http.Response) (*StreamRawDiff2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRawDiff2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamPatch1Response parses an HTTP response from a StreamPatch1WithResponse call
func ParseStreamPatch1Response(rsp *http.Response) (*StreamPatch1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamPatch1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetActivitiesResponse parses an HTTP response from a GetActivitiesWithResponse call
func ParseGetActivitiesResponse(rsp *http.Response) (*GetActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                      `json:"isLastPage,omitempty"`
			Limit         *float32                   `json:"limit,omitempty"`
			NextPageStart *int32                     `json:"nextPageStart,omitempty"`
			Size          *float32                   `json:"size,omitempty"`
			Start         *int32                     `json:"start,omitempty"`
			Values        *[]RestPullRequestActivity `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWithdrawApprovalResponse parses an HTTP response from a WithdrawApprovalWithResponse call
func ParseWithdrawApprovalResponse(rsp *http.Response) (*WithdrawApprovalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawApprovalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseApproveResponse parses an HTTP response from a ApproveWithResponse call
func ParseApproveResponse(rsp *http.Response) (*ApproveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCancelAutoMergeResponse parses an HTTP response from a CancelAutoMergeWithResponse call
func ParseCancelAutoMergeResponse(rsp *http.Response) (*CancelAutoMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelAutoMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAutoMergeRequestResponse parses an HTTP response from a GetAutoMergeRequestWithResponse call
func ParseGetAutoMergeRequestResponse(rsp *http.Response) (*GetAutoMergeRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoMergeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTryAutoMergeResponse parses an HTTP response from a TryAutoMergeWithResponse call
func ParseTryAutoMergeResponse(rsp *http.Response) (*TryAutoMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TryAutoMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeProcessingResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetComments1Response parses an HTTP response from a GetComments1WithResponse call
func ParseGetComments1Response(rsp *http.Response) (*GetComments1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComments1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool          `json:"isLastPage,omitempty"`
			Limit         *float32       `json:"limit,omitempty"`
			NextPageStart *int32         `json:"nextPageStart,omitempty"`
			Size          *float32       `json:"size,omitempty"`
			Start         *int32         `json:"start,omitempty"`
			Values        *[]RestComment `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateComment1Response parses an HTTP response from a CreateComment1WithResponse call
func ParseCreateComment1Response(rsp *http.Response) (*CreateComment1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComment1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteComment1Response parses an HTTP response from a DeleteComment1WithResponse call
func ParseDeleteComment1Response(rsp *http.Response) (*DeleteComment1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComment1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetComment1Response parses an HTTP response from a GetComment1WithResponse call
func ParseGetComment1Response(rsp *http.Response) (*GetComment1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComment1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateComment1Response parses an HTTP response from a UpdateComment1WithResponse call
func ParseUpdateComment1Response(rsp *http.Response) (*UpdateComment1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComment1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseStreamChanges1Response parses an HTTP response from a StreamChanges1WithResponse call
func ParseStreamChanges1Response(rsp *http.Response) (*StreamChanges1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamChanges1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetComments2Response parses an HTTP response from a GetComments2WithResponse call
func ParseGetComments2Response(rsp *http.Response) (*GetComments2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComments2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool          `json:"isLastPage,omitempty"`
			Limit         *float32       `json:"limit,omitempty"`
			NextPageStart *int32         `json:"nextPageStart,omitempty"`
			Size          *float32       `json:"size,omitempty"`
			Start         *int32         `json:"start,omitempty"`
			Values        *[]RestComment `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateComment2Response parses an HTTP response from a CreateComment2WithResponse call
func ParseCreateComment2Response(rsp *http.Response) (*CreateComment2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComment2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteComment2Response parses an HTTP response from a DeleteComment2WithResponse call
func ParseDeleteComment2Response(rsp *http.Response) (*DeleteComment2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComment2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetComment2Response parses an HTTP response from a GetComment2WithResponse call
func ParseGetComment2Response(rsp *http.Response) (*GetComment2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComment2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateComment2Response parses an HTTP response from a UpdateComment2WithResponse call
func ParseUpdateComment2Response(rsp *http.Response) (*UpdateComment2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComment2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseApplySuggestionResponse parses an HTTP response from a ApplySuggestionWithResponse call
func ParseApplySuggestionResponse(rsp *http.Response) (*ApplySuggestionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplySuggestionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetCommitMessageSuggestionResponse parses an HTTP response from a GetCommitMessageSuggestionWithResponse call
func ParseGetCommitMessageSuggestionResponse(rsp *http.Response) (*GetCommitMessageSuggestionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommitMessageSuggestionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommitMessageSuggestion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCommits1Response parses an HTTP response from a GetCommits1WithResponse call
func ParseGetCommits1Response(rsp *http.Response) (*GetCommits1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommits1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestCommit `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeclineResponse parses an HTTP response from a DeclineWithResponse call
func ParseDeclineResponse(rsp *http.Response) (*DeclineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetDiffStatsSummary2Response parses an HTTP response from a GetDiffStatsSummary2WithResponse call
func ParseGetDiffStatsSummary2Response(rsp *http.Response) (*GetDiffStatsSummary2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiffStatsSummary2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiffStatsSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamDiff2Response parses an HTTP response from a StreamDiff2WithResponse call
func ParseStreamDiff2Response(rsp *http.Response) (*StreamDiff2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamDiff2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDiff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCanMergeResponse parses an HTTP response from a CanMergeWithResponse call
func ParseCanMergeResponse(rsp *http.Response) (*CanMergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CanMergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestMergeability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseMergeResponse parses an HTTP response from a MergeWithResponse call
func ParseMergeResponse(rsp *http.Response) (*MergeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetMergeBase1Response parses an HTTP response from a GetMergeBase1WithResponse call
func ParseGetMergeBase1Response(rsp *http.Response) (*GetMergeBase1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMergeBase1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnassignParticipantRole1Response parses an HTTP response from a UnassignParticipantRole1WithResponse call
func ParseUnassignParticipantRole1Response(rsp *http.Response) (*UnassignParticipantRole1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignParticipantRole1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseListParticipantsResponse parses an HTTP response from a ListParticipantsWithResponse call
func ParseListParticipantsResponse(rsp *http.Response) (*ListParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                         `json:"isLastPage,omitempty"`
			Limit         *float32                      `json:"limit,omitempty"`
			NextPageStart *int32                        `json:"nextPageStart,omitempty"`
			Size          *float32                      `json:"size,omitempty"`
			Start         *int32                        `json:"start,omitempty"`
			Values        *[]RestPullRequestParticipant `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAssignParticipantRoleResponse parses an HTTP response from a AssignParticipantRoleWithResponse call
func ParseAssignParticipantRoleResponse(rsp *http.Response) (*AssignParticipantRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignParticipantRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUnassignParticipantRoleResponse parses an HTTP response from a UnassignParticipantRoleWithResponse call
func ParseUnassignParticipantRoleResponse(rsp *http.Response) (*UnassignParticipantRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignParticipantRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUpdateStatusResponse parses an HTTP response from a UpdateStatusWithResponse call
func ParseUpdateStatusResponse(rsp *http.Response) (*UpdateStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseReopenResponse parses an HTTP response from a ReopenWithResponse call
func ParseReopenResponse(rsp *http.Response) (*ReopenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReopenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDiscardReviewResponse parses an HTTP response from a DiscardReviewWithResponse call
func ParseDiscardReviewResponse(rsp *http.Response) (*DiscardReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscardReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReviewResponse parses an HTTP response from a GetReviewWithResponse call
func ParseGetReviewResponse(rsp *http.Response) (*GetReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool          `json:"isLastPage,omitempty"`
			Limit         *float32       `json:"limit,omitempty"`
			NextPageStart *int32         `json:"nextPageStart,omitempty"`
			Size          *float32       `json:"size,omitempty"`
			Start         *int32         `json:"start,omitempty"`
			Values        *[]RestComment `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFinishReviewResponse parses an HTTP response from a FinishReviewWithResponse call
func ParseFinishReviewResponse(rsp *http.Response) (*FinishReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FinishReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUnwatch1Response parses an HTTP response from a Unwatch1WithResponse call
func ParseUnwatch1Response(rsp *http.Response) (*Unwatch1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Unwatch1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWatch1Response parses an HTTP response from a Watch1WithResponse call
func ParseWatch1Response(rsp *http.Response) (*Watch1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Watch1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamRawResponse parses an HTTP response from a StreamRawWithResponse call
func ParseStreamRawResponse(rsp *http.Response) (*StreamRawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamReadmeResponse parses an HTTP response from a StreamReadmeWithResponse call
func ParseStreamReadmeResponse(rsp *http.Response) (*StreamReadmeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamReadmeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRetryCreateRepositoryResponse parses an HTTP response from a RetryCreateRepositoryWithResponse call
func ParseRetryCreateRepositoryResponse(rsp *http.Response) (*RetryCreateRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetryCreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRefChangeActivityResponse parses an HTTP response from a GetRefChangeActivityWithResponse call
func ParseGetRefChangeActivityResponse(rsp *http.Response) (*GetRefChangeActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefChangeActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                              `json:"isLastPage,omitempty"`
			Limit         *float32                           `json:"limit,omitempty"`
			NextPageStart *int32                             `json:"nextPageStart,omitempty"`
			Size          *float32                           `json:"size,omitempty"`
			Start         *int32                             `json:"start,omitempty"`
			Values        *[]RestRepositoryRefChangeActivity `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindBranchesResponse parses an HTTP response from a FindBranchesWithResponse call
func ParseFindBranchesResponse(rsp *http.Response) (*FindBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestMinimalRef `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRelatedRepositoriesResponse parses an HTTP response from a GetRelatedRepositoriesWithResponse call
func ParseGetRelatedRepositoriesResponse(rsp *http.Response) (*GetRelatedRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRelatedRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearch2Response parses an HTTP response from a Search2WithResponse call
func ParseSearch2Response(rsp *http.Response) (*Search2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                              `json:"isLastPage,omitempty"`
			Limit         *float32                           `json:"limit,omitempty"`
			NextPageStart *int32                             `json:"nextPageStart,omitempty"`
			Size          *float32                           `json:"size,omitempty"`
			Start         *int32                             `json:"start,omitempty"`
			Values        *[]RestSecretScanningAllowlistRule `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateAllowlistRule1Response parses an HTTP response from a CreateAllowlistRule1WithResponse call
func ParseCreateAllowlistRule1Response(rsp *http.Response) (*CreateAllowlistRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAllowlistRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAllowlistRule1Response parses an HTTP response from a DeleteAllowlistRule1WithResponse call
func ParseDeleteAllowlistRule1Response(rsp *http.Response) (*DeleteAllowlistRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllowlistRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllowlistRule1Response parses an HTTP response from a GetAllowlistRule1WithResponse call
func ParseGetAllowlistRule1Response(rsp *http.Response) (*GetAllowlistRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllowlistRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditAllowlistRule1Response parses an HTTP response from a EditAllowlistRule1WithResponse call
func ParseEditAllowlistRule1Response(rsp *http.Response) (*EditAllowlistRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAllowlistRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSearch3Response parses an HTTP response from a Search3WithResponse call
func ParseSearch3Response(rsp *http.Response) (*Search3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                     `json:"isLastPage,omitempty"`
			Limit         *float32                  `json:"limit,omitempty"`
			NextPageStart *int32                    `json:"nextPageStart,omitempty"`
			Size          *float32                  `json:"size,omitempty"`
			Start         *int32                    `json:"start,omitempty"`
			Values        *[]RestSecretScanningRule `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRule1Response parses an HTTP response from a CreateRule1WithResponse call
func ParseCreateRule1Response(rsp *http.Response) (*CreateRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRule1Response parses an HTTP response from a DeleteRule1WithResponse call
func ParseDeleteRule1Response(rsp *http.Response) (*DeleteRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRule1Response parses an HTTP response from a GetRule1WithResponse call
func ParseGetRule1Response(rsp *http.Response) (*GetRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditRule1Response parses an HTTP response from a EditRule1WithResponse call
func ParseEditRule1Response(rsp *http.Response) (*EditRule1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditRule1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAutoDeclineSettings1Response parses an HTTP response from a DeleteAutoDeclineSettings1WithResponse call
func ParseDeleteAutoDeclineSettings1Response(rsp *http.Response) (*DeleteAutoDeclineSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAutoDeclineSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAutoDeclineSettings1Response parses an HTTP response from a GetAutoDeclineSettings1WithResponse call
func ParseGetAutoDeclineSettings1Response(rsp *http.Response) (*GetAutoDeclineSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoDeclineSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoDeclineSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetAutoDeclineSettings1Response parses an HTTP response from a SetAutoDeclineSettings1WithResponse call
func ParseSetAutoDeclineSettings1Response(rsp *http.Response) (*SetAutoDeclineSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoDeclineSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoDeclineSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDelete5Response parses an HTTP response from a Delete5WithResponse call
func ParseDelete5Response(rsp *http.Response) (*Delete5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet5Response parses an HTTP response from a Get5WithResponse call
func ParseGet5Response(rsp *http.Response) (*Get5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeRestrictedSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSet1Response parses an HTTP response from a Set1WithResponse call
func ParseSet1Response(rsp *http.Response) (*Set1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Set1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeRestrictedSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoryHooks1Response parses an HTTP response from a GetRepositoryHooks1WithResponse call
func ParseGetRepositoryHooks1Response(rsp *http.Response) (*GetRepositoryHooks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryHooks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestRepositoryHook `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryHookResponse parses an HTTP response from a DeleteRepositoryHookWithResponse call
func ParseDeleteRepositoryHookResponse(rsp *http.Response) (*DeleteRepositoryHookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoryHook1Response parses an HTTP response from a GetRepositoryHook1WithResponse call
func ParseGetRepositoryHook1Response(rsp *http.Response) (*GetRepositoryHook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryHook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDisableHook1Response parses an HTTP response from a DisableHook1WithResponse call
func ParseDisableHook1Response(rsp *http.Response) (*DisableHook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableHook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEnableHook1Response parses an HTTP response from a EnableHook1WithResponse call
func ParseEnableHook1Response(rsp *http.Response) (*EnableHook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableHook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSettings1Response parses an HTTP response from a GetSettings1WithResponse call
func ParseGetSettings1Response(rsp *http.Response) (*GetSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetSettings1Response parses an HTTP response from a SetSettings1WithResponse call
func ParseSetSettings1Response(rsp *http.Response) (*SetSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPullRequestSettings1Response parses an HTTP response from a GetPullRequestSettings1WithResponse call
func ParseGetPullRequestSettings1Response(rsp *http.Response) (*GetPullRequestSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPullRequestSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestSettings1Response parses an HTTP response from a UpdatePullRequestSettings1WithResponse call
func ParseUpdatePullRequestSettings1Response(rsp *http.Response) (*UpdatePullRequestSettings1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestSettings1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPullRequestSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReviewerGroups1Response parses an HTTP response from a GetReviewerGroups1WithResponse call
func ParseGetReviewerGroups1Response(rsp *http.Response) (*GetReviewerGroups1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewerGroups1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestReviewerGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreate2Response parses an HTTP response from a Create2WithResponse call
func ParseCreate2Response(rsp *http.Response) (*Create2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDelete7Response parses an HTTP response from a Delete7WithResponse call
func ParseDelete7Response(rsp *http.Response) (*Delete7Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReviewerGroup1Response parses an HTTP response from a GetReviewerGroup1WithResponse call
func ParseGetReviewerGroup1Response(rsp *http.Response) (*GetReviewerGroup1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewerGroup1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdate2Response parses an HTTP response from a Update2WithResponse call
func ParseUpdate2Response(rsp *http.Response) (*Update2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Update2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestApplicationUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8404 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool      `json:"isLastPage,omitempty"`
			Limit         *float32   `json:"limit,omitempty"`
			NextPageStart *int32     `json:"nextPageStart,omitempty"`
			Size          *float32   `json:"size,omitempty"`
			Start         *int32     `json:"start,omitempty"`
			Values        *[]RestTag `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateTagForRepositoryResponse parses an HTTP response from a CreateTagForRepositoryWithResponse call
func ParseCreateTagForRepositoryResponse(rsp *http.Response) (*CreateTagForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnwatch2Response parses an HTTP response from a Unwatch2WithResponse call
func ParseUnwatch2Response(rsp *http.Response) (*Unwatch2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Unwatch2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWatch2Response parses an HTTP response from a Watch2WithResponse call
func ParseWatch2Response(rsp *http.Response) (*Watch2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Watch2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindWebhooks1Response parses an HTTP response from a FindWebhooks1WithResponse call
func ParseFindWebhooks1Response(rsp *http.Response) (*FindWebhooks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWebhooks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateWebhook1Response parses an HTTP response from a CreateWebhook1WithResponse call
func ParseCreateWebhook1Response(rsp *http.Response) (*CreateWebhook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchWebhooksResponse parses an HTTP response from a SearchWebhooksWithResponse call
func ParseSearchWebhooksResponse(rsp *http.Response) (*SearchWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTestWebhook1Response parses an HTTP response from a TestWebhook1WithResponse call
func ParseTestWebhook1Response(rsp *http.Response) (*TestWebhook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestWebhook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhookRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWebhook1Response parses an HTTP response from a DeleteWebhook1WithResponse call
func ParseDeleteWebhook1Response(rsp *http.Response) (*DeleteWebhook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWebhook1Response parses an HTTP response from a GetWebhook1WithResponse call
func ParseGetWebhook1Response(rsp *http.Response) (*GetWebhook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWebhook1Response parses an HTTP response from a UpdateWebhook1WithResponse call
func ParseUpdateWebhook1Response(rsp *http.Response) (*UpdateWebhook1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhook1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLatestInvocation1Response parses an HTTP response from a GetLatestInvocation1WithResponse call
func ParseGetLatestInvocation1Response(rsp *http.Response) (*GetLatestInvocation1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestInvocation1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedInvocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetStatistics1Response parses an HTTP response from a GetStatistics1WithResponse call
func ParseGetStatistics1Response(rsp *http.Response) (*GetStatistics1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatistics1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInvocationHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetStatisticsSummary1Response parses an HTTP response from a GetStatisticsSummary1WithResponse call
func ParseGetStatisticsSummary1Response(rsp *http.Response) (*GetStatisticsSummary1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsSummary1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInvocationHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchAllowlistRuleResponse parses an HTTP response from a SearchAllowlistRuleWithResponse call
func ParseSearchAllowlistRuleResponse(rsp *http.Response) (*SearchAllowlistRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAllowlistRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                              `json:"isLastPage,omitempty"`
			Limit         *float32                           `json:"limit,omitempty"`
			NextPageStart *int32                             `json:"nextPageStart,omitempty"`
			Size          *float32                           `json:"size,omitempty"`
			Start         *int32                             `json:"start,omitempty"`
			Values        *[]RestSecretScanningAllowlistRule `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateAllowlistRuleResponse parses an HTTP response from a CreateAllowlistRuleWithResponse call
func ParseCreateAllowlistRuleResponse(rsp *http.Response) (*CreateAllowlistRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAllowlistRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAllowlistRuleResponse parses an HTTP response from a DeleteAllowlistRuleWithResponse call
func ParseDeleteAllowlistRuleResponse(rsp *http.Response) (*DeleteAllowlistRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllowlistRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllowlistRuleResponse parses an HTTP response from a GetAllowlistRuleWithResponse call
func ParseGetAllowlistRuleResponse(rsp *http.Response) (*GetAllowlistRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllowlistRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditAllowlistRuleResponse parses an HTTP response from a EditAllowlistRuleWithResponse call
func ParseEditAllowlistRuleResponse(rsp *http.Response) (*EditAllowlistRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAllowlistRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningAllowlistRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSearch1Response parses an HTTP response from a Search1WithResponse call
func ParseSearch1Response(rsp *http.Response) (*Search1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                     `json:"isLastPage,omitempty"`
			Limit         *float32                  `json:"limit,omitempty"`
			NextPageStart *int32                    `json:"nextPageStart,omitempty"`
			Size          *float32                  `json:"size,omitempty"`
			Start         *int32                    `json:"start,omitempty"`
			Values        *[]RestSecretScanningRule `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRuleResponse parses an HTTP response from a GetRuleWithResponse call
func ParseGetRuleResponse(rsp *http.Response) (*GetRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditRuleResponse parses an HTTP response from a EditRuleWithResponse call
func ParseEditRuleResponse(rsp *http.Response) (*EditRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDelete9Response parses an HTTP response from a Delete9WithResponse call
func ParseDelete9Response(rsp *http.Response) (*Delete9Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete9Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet7Response parses an HTTP response from a Get7WithResponse call
func ParseGet7Response(rsp *http.Response) (*Get7Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestProjectSettingsRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreate3Response parses an HTTP response from a Create3WithResponse call
func ParseCreate3Response(rsp *http.Response) (*Create3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestProjectSettingsRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAllResponse parses an HTTP response from a GetAllWithResponse call
func ParseGetAllResponse(rsp *http.Response) (*GetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                             `json:"isLastPage,omitempty"`
			Limit         *float32                          `json:"limit,omitempty"`
			NextPageStart *int32                            `json:"nextPageStart,omitempty"`
			Size          *float32                          `json:"size,omitempty"`
			Start         *int32                            `json:"start,omitempty"`
			Values        *[]RestProjectSettingsRestriction `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAutoDeclineSettingsResponse parses an HTTP response from a DeleteAutoDeclineSettingsWithResponse call
func ParseDeleteAutoDeclineSettingsResponse(rsp *http.Response) (*DeleteAutoDeclineSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAutoDeclineSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAutoDeclineSettingsResponse parses an HTTP response from a GetAutoDeclineSettingsWithResponse call
func ParseGetAutoDeclineSettingsResponse(rsp *http.Response) (*GetAutoDeclineSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoDeclineSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoDeclineSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetAutoDeclineSettingsResponse parses an HTTP response from a SetAutoDeclineSettingsWithResponse call
func ParseSetAutoDeclineSettingsResponse(rsp *http.Response) (*SetAutoDeclineSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoDeclineSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoDeclineSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDelete4Response parses an HTTP response from a Delete4WithResponse call
func ParseDelete4Response(rsp *http.Response) (*Delete4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGet4Response parses an HTTP response from a Get4WithResponse call
func ParseGet4Response(rsp *http.Response) (*Get4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Get4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeRestrictedSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetResponse parses an HTTP response from a SetWithResponse call
func ParseSetResponse(rsp *http.Response) (*SetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAutoMergeRestrictedSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoryHooksResponse parses an HTTP response from a GetRepositoryHooksWithResponse call
func ParseGetRepositoryHooksResponse(rsp *http.Response) (*GetRepositoryHooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestRepositoryHook `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoryHookResponse parses an HTTP response from a GetRepositoryHookWithResponse call
func ParseGetRepositoryHookResponse(rsp *http.Response) (*GetRepositoryHookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDisableHookResponse parses an HTTP response from a DisableHookWithResponse call
func ParseDisableHookResponse(rsp *http.Response) (*DisableHookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEnableHookResponse parses an HTTP response from a EnableHookWithResponse call
func ParseEnableHookResponse(rsp *http.Response) (*EnableHookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetSettingsResponse parses an HTTP response from a SetSettingsWithResponse call
func ParseSetSettingsResponse(rsp *http.Response) (*SetSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPullRequestSettingsResponse parses an HTTP response from a GetPullRequestSettingsWithResponse call
func ParseGetPullRequestSettingsResponse(rsp *http.Response) (*GetPullRequestSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestSettingsResponse parses an HTTP response from a UpdatePullRequestSettingsWithResponse call
func ParseUpdatePullRequestSettingsResponse(rsp *http.Response) (*UpdatePullRequestSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReviewerGroupsResponse parses an HTTP response from a GetReviewerGroupsWithResponse call
func ParseGetReviewerGroupsResponse(rsp *http.Response) (*GetReviewerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestReviewerGroup `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreate1Response parses an HTTP response from a Create1WithResponse call
func ParseCreate1Response(rsp *http.Response) (*Create1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDelete6Response parses an HTTP response from a Delete6WithResponse call
func ParseDelete6Response(rsp *http.Response) (*Delete6Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Delete6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReviewerGroupResponse parses an HTTP response from a GetReviewerGroupWithResponse call
func ParseGetReviewerGroupResponse(rsp *http.Response) (*GetReviewerGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdate1Response parses an HTTP response from a Update1WithResponse call
func ParseUpdate1Response(rsp *http.Response) (*Update1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Update1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestReviewerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseFindWebhooksResponse parses an HTTP response from a FindWebhooksWithResponse call
func ParseFindWebhooksResponse(rsp *http.Response) (*FindWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateWebhookResponse parses an HTTP response from a CreateWebhookWithResponse call
func ParseCreateWebhookResponse(rsp *http.Response) (*CreateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTestWebhookResponse parses an HTTP response from a TestWebhookWithResponse call
func ParseTestWebhookResponse(rsp *http.Response) (*TestWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhookRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookResponse parses an HTTP response from a UpdateWebhookWithResponse call
func ParseUpdateWebhookResponse(rsp *http.Response) (*UpdateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLatestInvocationResponse parses an HTTP response from a GetLatestInvocationWithResponse call
func ParseGetLatestInvocationResponse(rsp *http.Response) (*GetLatestInvocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestInvocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDetailedInvocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetStatisticsResponse parses an HTTP response from a GetStatisticsWithResponse call
func ParseGetStatisticsResponse(rsp *http.Response) (*GetStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInvocationHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetStatisticsSummaryResponse parses an HTTP response from a GetStatisticsSummaryWithResponse call
func ParseGetStatisticsSummaryResponse(rsp *http.Response) (*GetStatisticsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInvocationHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositories1Response parses an HTTP response from a GetRepositories1WithResponse call
func ParseGetRepositories1Response(rsp *http.Response) (*GetRepositories1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositories1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFindExemptReposByScopeResponse parses an HTTP response from a FindExemptReposByScopeWithResponse call
func ParseFindExemptReposByScopeResponse(rsp *http.Response) (*FindExemptReposByScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindExemptReposByScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseBulkAddExemptRepositoriesResponse parses an HTTP response from a BulkAddExemptRepositoriesWithResponse call
func ParseBulkAddExemptRepositoriesResponse(rsp *http.Response) (*BulkAddExemptRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddExemptRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseSearch4Response parses an HTTP response from a Search4WithResponse call
func ParseSearch4Response(rsp *http.Response) (*Search4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Search4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                     `json:"isLastPage,omitempty"`
			Limit         *float32                  `json:"limit,omitempty"`
			NextPageStart *int32                    `json:"nextPageStart,omitempty"`
			Size          *float32                  `json:"size,omitempty"`
			Start         *int32                    `json:"start,omitempty"`
			Values        *[]RestSecretScanningRule `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRule2Response parses an HTTP response from a CreateRule2WithResponse call
func ParseCreateRule2Response(rsp *http.Response) (*CreateRule2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRule2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRule2Response parses an HTTP response from a DeleteRule2WithResponse call
func ParseDeleteRule2Response(rsp *http.Response) (*DeleteRule2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRule2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRule2Response parses an HTTP response from a GetRule2WithResponse call
func ParseGetRule2Response(rsp *http.Response) (*GetRule2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRule2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEditRule2Response parses an HTTP response from a EditRule2WithResponse call
func ParseEditRule2Response(rsp *http.Response) (*EditRule2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditRule2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSecretScanningRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllCertificatesResponse parses an HTTP response from a GetAllCertificatesWithResponse call
func ParseGetAllCertificatesResponse(rsp *http.Response) (*GetAllCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestX509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateCertificateResponse parses an HTTP response from a CreateCertificateWithResponse call
func ParseCreateCertificateResponse(rsp *http.Response) (*CreateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestX509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCertificateRevocationListEntriesResponse parses an HTTP response from a UpdateCertificateRevocationListEntriesWithResponse call
func ParseUpdateCertificateRevocationListEntriesResponse(rsp *http.Response) (*UpdateCertificateRevocationListEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCertificateRevocationListEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteCertificateResponse parses an HTTP response from a DeleteCertificateWithResponse call
func ParseDeleteCertificateResponse(rsp *http.Response) (*DeleteCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest RestX509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSystemSigningConfigurationResponse parses an HTTP response from a GetSystemSigningConfigurationWithResponse call
func ParseGetSystemSigningConfigurationResponse(rsp *http.Response) (*GetSystemSigningConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSigningConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSystemSigningConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateSystemSigningConfigurationResponse parses an HTTP response from a UpdateSystemSigningConfigurationWithResponse call
func ParseUpdateSystemSigningConfigurationResponse(rsp *http.Response) (*UpdateSystemSigningConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSystemSigningConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSystemSigningConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUsers2Response parses an HTTP response from a GetUsers2WithResponse call
func ParseGetUsers2Response(rsp *http.Response) (*GetUsers2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsers2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestApplicationUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUserDetails1Response parses an HTTP response from a UpdateUserDetails1WithResponse call
func ParseUpdateUserDetails1Response(rsp *http.Response) (*UpdateUserDetails1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserDetails1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestApplicationUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUserPassword1Response parses an HTTP response from a UpdateUserPassword1WithResponse call
func ParseUpdateUserPassword1Response(rsp *http.Response) (*UpdateUserPassword1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPassword1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestApplicationUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAvatarResponse parses an HTTP response from a DeleteAvatarWithResponse call
func ParseDeleteAvatarResponse(rsp *http.Response) (*DeleteAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestNamedLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadAvatar1Response parses an HTTP response from a UploadAvatar1WithResponse call
func ParseUploadAvatar1Response(rsp *http.Response) (*UploadAvatar1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAvatar1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserSettingsResponse parses an HTTP response from a GetUserSettingsWithResponse call
func ParseGetUserSettingsResponse(rsp *http.Response) (*GetUserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExampleSettingsMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSettingsResponse parses an HTTP response from a UpdateSettingsWithResponse call
func ParseUpdateSettingsResponse(rsp *http.Response) (*UpdateSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDismissRetentionConfigReviewNotificationResponse parses an HTTP response from a DismissRetentionConfigReviewNotificationWithResponse call
func ParseDismissRetentionConfigReviewNotificationResponse(rsp *http.Response) (*DismissRetentionConfigReviewNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DismissRetentionConfigReviewNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRestrictions1Response parses an HTTP response from a GetRestrictions1WithResponse call
func ParseGetRestrictions1Response(rsp *http.Response) (*GetRestrictions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestrictions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestRefRestriction `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateRestrictions1Response parses an HTTP response from a CreateRestrictions1WithResponse call
func ParseCreateRestrictions1Response(rsp *http.Response) (*CreateRestrictions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRestrictions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRestriction1Response parses an HTTP response from a DeleteRestriction1WithResponse call
func ParseDeleteRestriction1Response(rsp *http.Response) (*DeleteRestriction1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRestriction1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRestriction1Response parses an HTTP response from a GetRestriction1WithResponse call
func ParseGetRestriction1Response(rsp *http.Response) (*GetRestriction1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestriction1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRestrictionsResponse parses an HTTP response from a GetRestrictionsWithResponse call
func ParseGetRestrictionsResponse(rsp *http.Response) (*GetRestrictionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]RestRefRestriction `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateRestrictionsResponse parses an HTTP response from a CreateRestrictionsWithResponse call
func ParseCreateRestrictionsResponse(rsp *http.Response) (*CreateRestrictionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRestrictionResponse parses an HTTP response from a DeleteRestrictionWithResponse call
func ParseDeleteRestrictionResponse(rsp *http.Response) (*DeleteRestrictionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRestrictionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRestrictionResponse parses an HTTP response from a GetRestrictionWithResponse call
func ParseGetRestrictionResponse(rsp *http.Response) (*GetRestrictionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRestrictionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefRestriction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBranchResponse parses an HTTP response from a DeleteBranchWithResponse call
func ParseDeleteBranchResponse(rsp *http.Response) (*DeleteBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateBranchResponse parses an HTTP response from a CreateBranchWithResponse call
func ParseCreateBranchResponse(rsp *http.Response) (*CreateBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestBranch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseFindByCommitResponse parses an HTTP response from a FindByCommitWithResponse call
func ParseFindByCommitResponse(rsp *http.Response) (*FindByCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindByCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool             `json:"isLastPage,omitempty"`
			Limit         *float32          `json:"limit,omitempty"`
			NextPageStart *int32            `json:"nextPageStart,omitempty"`
			Size          *float32          `json:"size,omitempty"`
			Start         *int32            `json:"start,omitempty"`
			Values        *[]RestMinimalRef `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMultipleBuildStatusStatsResponse parses an HTTP response from a GetMultipleBuildStatusStatsWithResponse call
func ParseGetMultipleBuildStatusStatsResponse(rsp *http.Response) (*GetMultipleBuildStatusStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleBuildStatusStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMultipleBuildStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetBuildStatusStatsResponse parses an HTTP response from a GetBuildStatusStatsWithResponse call
func ParseGetBuildStatusStatsResponse(rsp *http.Response) (*GetBuildStatusStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildStatusStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestBuildStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetBuildStatusResponse parses an HTTP response from a GetBuildStatusWithResponse call
func ParseGetBuildStatusResponse(rsp *http.Response) (*GetBuildStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestBuildStatus `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddBuildStatusResponse parses an HTTP response from a AddBuildStatusWithResponse call
func ParseAddBuildStatusResponse(rsp *http.Response) (*AddBuildStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddBuildStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUnReactResponse parses an HTTP response from a UnReactWithResponse call
func ParseUnReactResponse(rsp *http.Response) (*UnReactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnReactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReactResponse parses an HTTP response from a ReactWithResponse call
func ParseReactResponse(rsp *http.Response) (*ReactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserReaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnReact1Response parses an HTTP response from a UnReact1WithResponse call
func ParseUnReact1Response(rsp *http.Response) (*UnReact1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnReact1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReact1Response parses an HTTP response from a React1WithResponse call
func ParseReact1Response(rsp *http.Response) (*React1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &React1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUserReaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePullRequestConditionResponse parses an HTTP response from a CreatePullRequestConditionWithResponse call
func ParseCreatePullRequestConditionResponse(rsp *http.Response) (*CreatePullRequestConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePullRequestConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeletePullRequestConditionResponse parses an HTTP response from a DeletePullRequestConditionWithResponse call
func ParseDeletePullRequestConditionResponse(rsp *http.Response) (*DeletePullRequestConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePullRequestConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestConditionResponse parses an HTTP response from a UpdatePullRequestConditionWithResponse call
func ParseUpdatePullRequestConditionResponse(rsp *http.Response) (*UpdatePullRequestConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPullRequestConditionsResponse parses an HTTP response from a GetPullRequestConditionsWithResponse call
func ParseGetPullRequestConditionsResponse(rsp *http.Response) (*GetPullRequestConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePullRequestCondition1Response parses an HTTP response from a CreatePullRequestCondition1WithResponse call
func ParseCreatePullRequestCondition1Response(rsp *http.Response) (*CreatePullRequestCondition1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePullRequestCondition1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeletePullRequestCondition1Response parses an HTTP response from a DeletePullRequestCondition1WithResponse call
func ParseDeletePullRequestCondition1Response(rsp *http.Response) (*DeletePullRequestCondition1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePullRequestCondition1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePullRequestCondition1Response parses an HTTP response from a UpdatePullRequestCondition1WithResponse call
func ParseUpdatePullRequestCondition1Response(rsp *http.Response) (*UpdatePullRequestCondition1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePullRequestCondition1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPullRequestConditions1Response parses an HTTP response from a GetPullRequestConditions1WithResponse call
func ParseGetPullRequestConditions1Response(rsp *http.Response) (*GetPullRequestConditions1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestConditions1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReviewersResponse parses an HTTP response from a GetReviewersWithResponse call
func ParseGetReviewersResponse(rsp *http.Response) (*GetReviewersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReviewersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestPullRequestCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAllDefaultTasks1Response parses an HTTP response from a DeleteAllDefaultTasks1WithResponse call
func ParseDeleteAllDefaultTasks1Response(rsp *http.Response) (*DeleteAllDefaultTasks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllDefaultTasks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDefaultTasks1Response parses an HTTP response from a GetDefaultTasks1WithResponse call
func ParseGetDefaultTasks1Response(rsp *http.Response) (*GetDefaultTasks1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultTasks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestDefaultTask `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddDefaultTask1Response parses an HTTP response from a AddDefaultTask1WithResponse call
func ParseAddDefaultTask1Response(rsp *http.Response) (*AddDefaultTask1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDefaultTask1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDefaultTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteDefaultTask1Response parses an HTTP response from a DeleteDefaultTask1WithResponse call
func ParseDeleteDefaultTask1Response(rsp *http.Response) (*DeleteDefaultTask1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDefaultTask1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDefaultTask1Response parses an HTTP response from a UpdateDefaultTask1WithResponse call
func ParseUpdateDefaultTask1Response(rsp *http.Response) (*UpdateDefaultTask1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDefaultTask1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDefaultTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAllDefaultTasksResponse parses an HTTP response from a DeleteAllDefaultTasksWithResponse call
func ParseDeleteAllDefaultTasksResponse(rsp *http.Response) (*DeleteAllDefaultTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllDefaultTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDefaultTasksResponse parses an HTTP response from a GetDefaultTasksWithResponse call
func ParseGetDefaultTasksResponse(rsp *http.Response) (*GetDefaultTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool              `json:"isLastPage,omitempty"`
			Limit         *float32           `json:"limit,omitempty"`
			NextPageStart *int32             `json:"nextPageStart,omitempty"`
			Size          *float32           `json:"size,omitempty"`
			Start         *int32             `json:"start,omitempty"`
			Values        *[]RestDefaultTask `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddDefaultTaskResponse parses an HTTP response from a AddDefaultTaskWithResponse call
func ParseAddDefaultTaskResponse(rsp *http.Response) (*AddDefaultTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDefaultTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDefaultTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteDefaultTaskResponse parses an HTTP response from a DeleteDefaultTaskWithResponse call
func ParseDeleteDefaultTaskResponse(rsp *http.Response) (*DeleteDefaultTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDefaultTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDefaultTaskResponse parses an HTTP response from a UpdateDefaultTaskWithResponse call
func ParseUpdateDefaultTaskResponse(rsp *http.Response) (*UpdateDefaultTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDefaultTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestDefaultTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCanRebaseResponse parses an HTTP response from a CanRebaseWithResponse call
func ParseCanRebaseResponse(rsp *http.Response) (*CanRebaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CanRebaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestRebaseability
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRebaseResponse parses an HTTP response from a RebaseWithResponse call
func ParseRebaseResponse(rsp *http.Response) (*RebaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestPullRequestRebaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteForUserResponse parses an HTTP response from a DeleteForUserWithResponse call
func ParseDeleteForUserResponse(rsp *http.Response) (*DeleteForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKeysForUserResponse parses an HTTP response from a GetKeysForUserWithResponse call
func ParseGetKeysForUserResponse(rsp *http.Response) (*GetKeysForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestGpgKey `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddKeyResponse parses an HTTP response from a AddKeyWithResponse call
func ParseAddKeyResponse(rsp *http.Response) (*AddKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestGpgKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeyResponse parses an HTTP response from a DeleteKeyWithResponse call
func ParseDeleteKeyResponse(rsp *http.Response) (*DeleteKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAnnotations1Response parses an HTTP response from a GetAnnotations1WithResponse call
func ParseGetAnnotations1Response(rsp *http.Response) (*GetAnnotations1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnnotations1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInsightAnnotationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReportsResponse parses an HTTP response from a GetReportsWithResponse call
func ParseGetReportsResponse(rsp *http.Response) (*GetReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                `json:"isLastPage,omitempty"`
			Limit         *float32             `json:"limit,omitempty"`
			NextPageStart *int32               `json:"nextPageStart,omitempty"`
			Size          *float32             `json:"size,omitempty"`
			Start         *int32               `json:"start,omitempty"`
			Values        *[]RestInsightReport `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteACodeInsightsReportResponse parses an HTTP response from a DeleteACodeInsightsReportWithResponse call
func ParseDeleteACodeInsightsReportResponse(rsp *http.Response) (*DeleteACodeInsightsReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACodeInsightsReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetACodeInsightsReportResponse parses an HTTP response from a GetACodeInsightsReportWithResponse call
func ParseGetACodeInsightsReportResponse(rsp *http.Response) (*GetACodeInsightsReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACodeInsightsReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInsightReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetACodeInsightsReportResponse parses an HTTP response from a SetACodeInsightsReportWithResponse call
func ParseSetACodeInsightsReportResponse(rsp *http.Response) (*SetACodeInsightsReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetACodeInsightsReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInsightReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteAnnotationsResponse parses an HTTP response from a DeleteAnnotationsWithResponse call
func ParseDeleteAnnotationsResponse(rsp *http.Response) (*DeleteAnnotationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAnnotationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAnnotationsResponse parses an HTTP response from a GetAnnotationsWithResponse call
func ParseGetAnnotationsResponse(rsp *http.Response) (*GetAnnotationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnnotationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestInsightAnnotationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddAnnotationsResponse parses an HTTP response from a AddAnnotationsWithResponse call
func ParseAddAnnotationsResponse(rsp *http.Response) (*AddAnnotationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAnnotationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetAnnotationResponse parses an HTTP response from a SetAnnotationWithResponse call
func ParseSetAnnotationResponse(rsp *http.Response) (*SetAnnotationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAnnotationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateIssueResponse parses an HTTP response from a CreateIssueWithResponse call
func ParseCreateIssueResponse(rsp *http.Response) (*CreateIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestCommentJiraIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCommitsByIssueKeyResponse parses an HTTP response from a GetCommitsByIssueKeyWithResponse call
func ParseGetCommitsByIssueKeyResponse(rsp *http.Response) (*GetCommitsByIssueKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommitsByIssueKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool            `json:"isLastPage,omitempty"`
			Limit         *float32         `json:"limit,omitempty"`
			NextPageStart *int32           `json:"nextPageStart,omitempty"`
			Size          *float32         `json:"size,omitempty"`
			Start         *int32           `json:"start,omitempty"`
			Values        *[]RestChangeset `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEnhancedEntityLinkForProjectResponse parses an HTTP response from a GetEnhancedEntityLinkForProjectWithResponse call
func ParseGetEnhancedEntityLinkForProjectResponse(rsp *http.Response) (*GetEnhancedEntityLinkForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnhancedEntityLinkForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestEnhancedEntityLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIssueKeysForPullRequestResponse parses an HTTP response from a GetIssueKeysForPullRequestWithResponse call
func ParseGetIssueKeysForPullRequestResponse(rsp *http.Response) (*GetIssueKeysForPullRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIssueKeysForPullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestJiraIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	}

	return response, nil
}

// ParseGetForRepository1Response parses an HTTP response from a GetForRepository1WithResponse call
func ParseGetForRepository1Response(rsp *http.Response) (*GetForRepository1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForRepository1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestSshAccessKey `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddForRepositoryResponse parses an HTTP response from a AddForRepositoryWithResponse call
func ParseAddForRepositoryResponse(rsp *http.Response) (*AddForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRevokeForRepositoryResponse parses an HTTP response from a RevokeForRepositoryWithResponse call
func ParseRevokeForRepositoryResponse(rsp *http.Response) (*RevokeForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetForRepositoryResponse parses an HTTP response from a GetForRepositoryWithResponse call
func ParseGetForRepositoryResponse(rsp *http.Response) (*GetForRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePermission1Response parses an HTTP response from a UpdatePermission1WithResponse call
func ParseUpdatePermission1Response(rsp *http.Response) (*UpdatePermission1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePermission1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSshKeysForProjectResponse parses an HTTP response from a GetSshKeysForProjectWithResponse call
func ParseGetSshKeysForProjectResponse(rsp *http.Response) (*GetSshKeysForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshKeysForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestSshAccessKey `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddForProjectResponse parses an HTTP response from a AddForProjectWithResponse call
func ParseAddForProjectResponse(rsp *http.Response) (*AddForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRevokeForProjectResponse parses an HTTP response from a RevokeForProjectWithResponse call
func ParseRevokeForProjectResponse(rsp *http.Response) (*RevokeForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetForProjectResponse parses an HTTP response from a GetForProjectWithResponse call
func ParseGetForProjectResponse(rsp *http.Response) (*GetForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePermissionResponse parses an HTTP response from a UpdatePermissionWithResponse call
func ParseUpdatePermissionResponse(rsp *http.Response) (*UpdatePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshAccessKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRevokeManyResponse parses an HTTP response from a RevokeManyWithResponse call
func ParseRevokeManyResponse(rsp *http.Response) (*RevokeManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetForProjectsResponse parses an HTTP response from a GetForProjectsWithResponse call
func ParseGetForProjectsResponse(rsp *http.Response) (*GetForProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetForRepositoriesResponse parses an HTTP response from a GetForRepositoriesWithResponse call
func ParseGetForRepositoriesResponse(rsp *http.Response) (*GetForRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePreferredMirrorIdResponse parses an HTTP response from a DeletePreferredMirrorIdWithResponse call
func ParseDeletePreferredMirrorIdResponse(rsp *http.Response) (*DeletePreferredMirrorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePreferredMirrorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPreferredMirrorIdResponse parses an HTTP response from a GetPreferredMirrorIdWithResponse call
func ParseGetPreferredMirrorIdResponse(rsp *http.Response) (*GetPreferredMirrorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreferredMirrorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPreferredMirrorIdResponse parses an HTTP response from a SetPreferredMirrorIdWithResponse call
func ParseSetPreferredMirrorIdResponse(rsp *http.Response) (*SetPreferredMirrorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPreferredMirrorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAnalyticsSettingsResponse parses an HTTP response from a AnalyticsSettingsWithResponse call
func ParseAnalyticsSettingsResponse(rsp *http.Response) (*AnalyticsSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyticsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestAnalyticsSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticateResponse parses an HTTP response from a AuthenticateWithResponse call
func ParseAuthenticateResponse(rsp *http.Response) (*AuthenticateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestApplicationUserWithPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFarmNodesResponse parses an HTTP response from a GetFarmNodesWithResponse call
func ParseGetFarmNodesResponse(rsp *http.Response) (*GetFarmNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFarmNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestClusterNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8404 = &dest

	}

	return response, nil
}

// ParseGetMirroredRepositoryResponse parses an HTTP response from a GetMirroredRepositoryWithResponse call
func ParseGetMirroredRepositoryResponse(rsp *http.Response) (*GetMirroredRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirroredRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirroredRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListMirrorsResponse parses an HTTP response from a ListMirrorsWithResponse call
func ParseListMirrorsResponse(rsp *http.Response) (*ListMirrorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMirrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool               `json:"isLastPage,omitempty"`
			Limit         *float32            `json:"limit,omitempty"`
			NextPageStart *int32              `json:"nextPageStart,omitempty"`
			Size          *float32            `json:"size,omitempty"`
			Start         *int32              `json:"start,omitempty"`
			Values        *[]RestMirrorServer `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveResponse parses an HTTP response from a RemoveWithResponse call
func ParseRemoveResponse(rsp *http.Response) (*RemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMirrorResponse parses an HTTP response from a GetMirrorWithResponse call
func ParseGetMirrorResponse(rsp *http.Response) (*GetMirrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpgradeResponse parses an HTTP response from a UpgradeWithResponse call
func ParseUpgradeResponse(rsp *http.Response) (*UpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePublishEventResponse parses an HTTP response from a PublishEventWithResponse call
func ParsePublishEventResponse(rsp *http.Response) (*PublishEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSynchronizationProgressResponse parses an HTTP response from a GetSynchronizationProgressWithResponse call
func ParseGetSynchronizationProgressResponse(rsp *http.Response) (*GetSynchronizationProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSynchronizationProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSyncProgress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProjectByIdResponse parses an HTTP response from a GetProjectByIdWithResponse call
func ParseGetProjectByIdResponse(rsp *http.Response) (*GetProjectByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAllReposForProjectResponse parses an HTTP response from a GetAllReposForProjectWithResponse call
func ParseGetAllReposForProjectResponse(rsp *http.Response) (*GetAllReposForProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllReposForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                 `json:"isLastPage,omitempty"`
			Limit         *float32              `json:"limit,omitempty"`
			NextPageStart *int32                `json:"nextPageStart,omitempty"`
			Size          *float32              `json:"size,omitempty"`
			Start         *int32                `json:"start,omitempty"`
			Values        *[]EnrichedRepository `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetAllContentHashesResponse parses an HTTP response from a GetAllContentHashesWithResponse call
func ParseGetAllContentHashesResponse(rsp *http.Response) (*GetAllContentHashesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllContentHashesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetContentHashByIdResponse parses an HTTP response from a GetContentHashByIdWithResponse call
func ParseGetContentHashByIdResponse(rsp *http.Response) (*GetContentHashByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentHashByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepositoryMirrorsResponse parses an HTTP response from a GetRepositoryMirrorsWithResponse call
func ParseGetRepositoryMirrorsResponse(rsp *http.Response) (*GetRepositoryMirrorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryMirrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirroredRepositoryDescriptor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseListRequestsResponse parses an HTTP response from a ListRequestsWithResponse call
func ParseListRequestsResponse(rsp *http.Response) (*ListRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                   `json:"isLastPage,omitempty"`
			Limit         *float32                `json:"limit,omitempty"`
			NextPageStart *int32                  `json:"nextPageStart,omitempty"`
			Size          *float32                `json:"size,omitempty"`
			Start         *int32                  `json:"start,omitempty"`
			Values        *[]RestMirroringRequest `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterResponse parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResponse(rsp *http.Response) (*RegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirroringRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteMirroringRequestResponse parses an HTTP response from a DeleteMirroringRequestWithResponse call
func ParseDeleteMirroringRequestResponse(rsp *http.Response) (*DeleteMirroringRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMirroringRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetMirroringRequestResponse parses an HTTP response from a GetMirroringRequestWithResponse call
func ParseGetMirroringRequestResponse(rsp *http.Response) (*GetMirroringRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirroringRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirroringRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAcceptResponse parses an HTTP response from a AcceptWithResponse call
func ParseAcceptResponse(rsp *http.Response) (*AcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRejectResponse parses an HTTP response from a RejectWithResponse call
func ParseRejectResponse(rsp *http.Response) (*RejectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetOutOfSyncRepositoriesResponse parses an HTTP response from a GetOutOfSyncRepositoriesWithResponse call
func ParseGetOutOfSyncRepositoriesResponse(rsp *http.Response) (*GetOutOfSyncRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutOfSyncRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8409 = &dest

	}

	return response, nil
}

// ParseGetRepositoryLockOwnerResponse parses an HTTP response from a GetRepositoryLockOwnerWithResponse call
func ParseGetRepositoryLockOwnerResponse(rsp *http.Response) (*GetRepositoryLockOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryLockOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryLockOwner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRepoSyncStatus1Response parses an HTTP response from a GetRepoSyncStatus1WithResponse call
func ParseGetRepoSyncStatus1Response(rsp *http.Response) (*GetRepoSyncStatus1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepoSyncStatus1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestMirrorRepositorySynchronizationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRefChangesQueueResponse parses an HTTP response from a GetRefChangesQueueWithResponse call
func ParseGetRefChangesQueueResponse(rsp *http.Response) (*GetRefChangesQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefChangesQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefSyncQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8401 = &dest

	}

	return response, nil
}

// ParseGetRefChangesQueueCountResponse parses an HTTP response from a GetRefChangesQueueCountWithResponse call
func ParseGetRefChangesQueueCountResponse(rsp *http.Response) (*GetRefChangesQueueCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefChangesQueueCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRepositoryLockOwnersResponse parses an HTTP response from a GetRepositoryLockOwnersWithResponse call
func ParseGetRepositoryLockOwnersResponse(rsp *http.Response) (*GetRepositoryLockOwnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryLockOwnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RestRepositoryLockOwner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RestErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUTF8401 = &dest

	}

	return response, nil
}

// ParseGetRepoSyncStatusResponse parses an HTTP response from a GetRepoSyncStatusWithResponse call
func ParseGetRepoSyncStatusResponse(rsp *http.Response) (*GetRepoSyncStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepoSyncStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                                        `json:"isLastPage,omitempty"`
			Limit         *float32                                     `json:"limit,omitempty"`
			NextPageStart *int32                                       `json:"nextPageStart,omitempty"`
			Size          *float32                                     `json:"size,omitempty"`
			Start         *int32                                       `json:"start,omitempty"`
			Values        *[]RestMirrorRepositorySynchronizationStatus `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetMirrorSettingsResponse parses an HTTP response from a GetMirrorSettingsWithResponse call
func ParseGetMirrorSettingsResponse(rsp *http.Response) (*GetMirrorSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirrorSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUpstreamSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetMirrorSettingsResponse parses an HTTP response from a SetMirrorSettingsWithResponse call
func ParseSetMirrorSettingsResponse(rsp *http.Response) (*SetMirrorSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMirrorSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUpstreamSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMirrorModeResponse parses an HTTP response from a GetMirrorModeWithResponse call
func ParseGetMirrorModeResponse(rsp *http.Response) (*GetMirrorModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirrorModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetMirrorModeResponse parses an HTTP response from a SetMirrorModeWithResponse call
func ParseSetMirrorModeResponse(rsp *http.Response) (*SetMirrorModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMirrorModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetMirroredProjectsResponse parses an HTTP response from a GetMirroredProjectsWithResponse call
func ParseGetMirroredProjectsResponse(rsp *http.Response) (*GetMirroredProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMirroredProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartMirroringProjectsResponse parses an HTTP response from a StartMirroringProjectsWithResponse call
func ParseStartMirroringProjectsResponse(rsp *http.Response) (*StartMirroringProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartMirroringProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopMirroringProjectResponse parses an HTTP response from a StopMirroringProjectWithResponse call
func ParseStopMirroringProjectResponse(rsp *http.Response) (*StopMirroringProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopMirroringProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartMirroringProjectResponse parses an HTTP response from a StartMirroringProjectWithResponse call
func ParseStartMirroringProjectResponse(rsp *http.Response) (*StartMirroringProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartMirroringProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUpstreamServerResponse parses an HTTP response from a GetUpstreamServerWithResponse call
func ParseGetUpstreamServerResponse(rsp *http.Response) (*GetUpstreamServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpstreamServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestUpstreamServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEndRollingUpgradeResponse parses an HTTP response from a EndRollingUpgradeWithResponse call
func ParseEndRollingUpgradeResponse(rsp *http.Response) (*EndRollingUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndRollingUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRollingUpgradeState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseStartRollingUpgradeResponse parses an HTTP response from a StartRollingUpgradeWithResponse call
func ParseStartRollingUpgradeResponse(rsp *http.Response) (*StartRollingUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartRollingUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRollingUpgradeState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRepositoryArchivePolicyResponse parses an HTTP response from a GetRepositoryArchivePolicyWithResponse call
func ParseGetRepositoryArchivePolicyResponse(rsp *http.Response) (*GetRepositoryArchivePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryArchivePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetRepositoryArchivePolicyResponse parses an HTTP response from a SetRepositoryArchivePolicyWithResponse call
func ParseSetRepositoryArchivePolicyResponse(rsp *http.Response) (*SetRepositoryArchivePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryArchivePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRepositoryDeletePolicyResponse parses an HTTP response from a GetRepositoryDeletePolicyWithResponse call
func ParseGetRepositoryDeletePolicyResponse(rsp *http.Response) (*GetRepositoryDeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryDeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSetRepositoryDeletePolicyResponse parses an HTTP response from a SetRepositoryDeletePolicyWithResponse call
func ParseSetRepositoryDeletePolicyResponse(rsp *http.Response) (*SetRepositoryDeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryDeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRepositoryPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateRequiredBuildsMergeCheckResponse parses an HTTP response from a CreateRequiredBuildsMergeCheckWithResponse call
func ParseCreateRequiredBuildsMergeCheckResponse(rsp *http.Response) (*CreateRequiredBuildsMergeCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequiredBuildsMergeCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRequiredBuildCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteRequiredBuildsMergeCheckResponse parses an HTTP response from a DeleteRequiredBuildsMergeCheckWithResponse call
func ParseDeleteRequiredBuildsMergeCheckResponse(rsp *http.Response) (*DeleteRequiredBuildsMergeCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRequiredBuildsMergeCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateRequiredBuildsMergeCheckResponse parses an HTTP response from a UpdateRequiredBuildsMergeCheckWithResponse call
func ParseUpdateRequiredBuildsMergeCheckResponse(rsp *http.Response) (*UpdateRequiredBuildsMergeCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRequiredBuildsMergeCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRequiredBuildCondition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPageOfRequiredBuildsMergeChecksResponse parses an HTTP response from a GetPageOfRequiredBuildsMergeChecksWithResponse call
func ParseGetPageOfRequiredBuildsMergeChecksResponse(rsp *http.Response) (*GetPageOfRequiredBuildsMergeChecksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPageOfRequiredBuildsMergeChecksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool                         `json:"isLastPage,omitempty"`
			Limit         *float32                      `json:"limit,omitempty"`
			NextPageStart *int32                        `json:"nextPageStart,omitempty"`
			Size          *float32                      `json:"size,omitempty"`
			Start         *int32                        `json:"start,omitempty"`
			Values        *[]RestRequiredBuildCondition `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteSshKeysResponse parses an HTTP response from a DeleteSshKeysWithResponse call
func ParseDeleteSshKeysResponse(rsp *http.Response) (*DeleteSshKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSshKeysResponse parses an HTTP response from a GetSshKeysWithResponse call
func ParseGetSshKeysResponse(rsp *http.Response) (*GetSshKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IsLastPage    *bool         `json:"isLastPage,omitempty"`
			Limit         *float32      `json:"limit,omitempty"`
			NextPageStart *int32        `json:"nextPageStart,omitempty"`
			Size          *float32      `json:"size,omitempty"`
			Start         *int32        `json:"start,omitempty"`
			Values        *[]RestSshKey `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddSshKeyResponse parses an HTTP response from a AddSshKeyWithResponse call
func ParseAddSshKeyResponse(rsp *http.Response) (*AddSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RestSshKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteSshKeyResponse parses an HTTP response from a DeleteSshKeyWithResponse call
func ParseDeleteSshKeyResponse(rsp *http.Response) (*DeleteSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetSshKeyResponse parses an HTTP response from a GetSshKeyWithResponse call
func ParseGetSshKeyResponse(rsp *http.Response) (*GetSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSshSettingsResponse parses an HTTP response from a SshSettingsWithResponse call
func ParseSshSettingsResponse(rsp *http.Response) (*SshSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SshSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestSshSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefSyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetEnabledResponse parses an HTTP response from a SetEnabledWithResponse call
func ParseSetEnabledResponse(rsp *http.Response) (*SetEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRefSyncStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSynchronizeResponse parses an HTTP response from a SynchronizeWithResponse call
func ParseSynchronizeResponse(rsp *http.Response) (*SynchronizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SynchronizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestRejectedRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest struct {
			Errors *[]RestErrorMessage `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}
